<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorials | IRunFasterThanMyCode</title>
    <link>/categories/tutorials/</link>
      <atom:link href="/categories/tutorials/index.xml" rel="self" type="application/rss+xml" />
    <description>Tutorials</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>© 2017 Sam Robson</copyright><lastBuildDate>Fri, 25 Oct 2019 00:00:00 +0000</lastBuildDate>
    <image>
      <url>/img/irunfasterthanmycode.jpg</url>
      <title>Tutorials</title>
      <link>/categories/tutorials/</link>
    </image>
    
    <item>
      <title>How To Use Python</title>
      <link>/resources/pythontutorial/</link>
      <pubDate>Fri, 25 Oct 2019 00:00:00 +0000</pubDate>
      <guid>/resources/pythontutorial/</guid>
      <description>

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introduction&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1&lt;/span&gt; Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#installing-python&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2&lt;/span&gt; Installing Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#basics-of-python&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3&lt;/span&gt; Basics of Python&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#getting-started&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.1&lt;/span&gt; Getting started&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#loading-new-packages&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.2&lt;/span&gt; Loading new packages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#white-space&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.3&lt;/span&gt; White-space&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#object-oriented-programming&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.4&lt;/span&gt; Object-oriented programming&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#data-types&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.5&lt;/span&gt; Data Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#function&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.6&lt;/span&gt; Function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#printing&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.7&lt;/span&gt; Printing&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#storing-multiple-values&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4&lt;/span&gt; Storing Multiple Values&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#lists-and-tuples&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4.1&lt;/span&gt; Lists and Tuples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dictionary&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4.2&lt;/span&gt; Dictionary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#numpy&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;5&lt;/span&gt; NumPy&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introduction-1&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;5.1&lt;/span&gt; Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#arrays&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;5.2&lt;/span&gt; Arrays&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#matrices&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;5.3&lt;/span&gt; Matrices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#indexing-and-slicing&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;5.4&lt;/span&gt; Indexing and slicing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#matrix-multiplication&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;5.5&lt;/span&gt; Matrix multiplication&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#sorting&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;5.6&lt;/span&gt; Sorting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#structured-array&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;5.7&lt;/span&gt; Structured Array&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pandas&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;6&lt;/span&gt; Pandas&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introduction-2&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;6.1&lt;/span&gt; Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#data-frames&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;6.2&lt;/span&gt; Data Frames&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#indexing-and-slicing-1&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;6.3&lt;/span&gt; Indexing and Slicing&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#data-filtering&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;7&lt;/span&gt; Data Filtering&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#data-sorting&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;7.1&lt;/span&gt; Data Sorting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#data-cleaning&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;7.2&lt;/span&gt; Data Cleaning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#combining-dataframes&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;7.3&lt;/span&gt; Combining DataFrames&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#reading-and-writing-data&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;7.4&lt;/span&gt; Reading and Writing Data&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#control-sequences&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;8&lt;/span&gt; Control Sequences&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#if-else&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;8.1&lt;/span&gt; IF ELSE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#for&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;8.2&lt;/span&gt; FOR&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#while&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;8.3&lt;/span&gt; WHILE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#loop-control&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;8.4&lt;/span&gt; Loop Control&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#writing-functions&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;9&lt;/span&gt; Writing Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#statistics&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;10&lt;/span&gt; Statistics&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#basic-statistics&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;10.1&lt;/span&gt; Basic Statistics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#variation&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;10.2&lt;/span&gt; Variation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#correlation&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;10.3&lt;/span&gt; Correlation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#linear-models&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;10.4&lt;/span&gt; Linear Models&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#plotting-with-python&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;11&lt;/span&gt; Plotting With Python&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#histograms&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;11.1&lt;/span&gt; Histograms&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#quantile-quantile-plots&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;11.2&lt;/span&gt; Quantile-Quantile Plots&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pie-chart&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;11.3&lt;/span&gt; Pie Chart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bar-plot&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;11.4&lt;/span&gt; Bar Plot&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#line-plots&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;11.5&lt;/span&gt; Line Plots&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#scatterplots&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;11.6&lt;/span&gt; Scatterplots&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#boxplots&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;11.7&lt;/span&gt; Boxplots&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#seaborn-package&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;11.8&lt;/span&gt; Seaborn package&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#subplots&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;11.9&lt;/span&gt; Subplots&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#saving-figures&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;11.10&lt;/span&gt; Saving Figures&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#example-analysis&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;12&lt;/span&gt; Example Analysis&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introduction-3&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;12.1&lt;/span&gt; Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#load-data&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;12.2&lt;/span&gt; Load Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#calculate-fold-change&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;12.3&lt;/span&gt; Calculate Fold Change&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#compare-data&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;12.4&lt;/span&gt; Compare Data&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id=&#34;introduction&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;1&lt;/span&gt; Introduction&lt;/h1&gt;
&lt;p&gt;As a bioinformatics researcher, I primarily use the statistical programming language R for my analyses, mainly due to the huge number of resources available in the &lt;a href=&#34;https://bioconductor.org&#34;&gt;Bioconductor&lt;/a&gt; libraries. I have previously written a &lt;a href=&#34;/resources/rtutorial/index.html&#34;&gt;Tutorial for R&lt;/a&gt;, so thought that I would do something similar for the data science programming language &lt;a href=&#34;https://www.python.org&#34;&gt;Python&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Python is an interpreted, high-level language that supports both object-oriented and structured programming. Both Python and R are widely used in the data science world, with both having very similar functionality, but specific pros and cons making the “correct” choice for which one to use being somewhat dependent on the task at hand. Python is typically considered to be more memory efficient than R, and has some amazingly powerful libraries for data science such as scikit-learn and &lt;a href=&#34;https://www.tensorflow.org&#34;&gt;TensorFlow&lt;/a&gt;, whilst R has amazing libraries for bioinformatics and superb data visualization through the &lt;a href=&#34;https://ggplot2.tidyverse.org&#34;&gt;ggplot2&lt;/a&gt; package and the other &lt;a href=&#34;https://www.tidyverse.org&#34;&gt;TidyVerse&lt;/a&gt; packages from Hadley Wickham.&lt;/p&gt;
&lt;p&gt;However, R has some amazingly memory-efficient implementations (including an interface to TensorFlow and other machine learning tools), and Python has a huge bioinformatics suite with the &lt;a href=&#34;https://biopython.org&#34;&gt;biopython&lt;/a&gt; suite and excellent plotting packages such as &lt;a href=&#34;https://seaborn.pydata.org&#34;&gt;seaborn&lt;/a&gt;. So ultimately, both are excellent, and knowing either can be a fantastic tool in your data science toolbox.&lt;/p&gt;
&lt;p&gt;This is an introduction to Python that should allow new users to understand how Python works. It will follow a similar flow to the R introduction, so the two can be compared to understand the differences between the two languages.&lt;/p&gt;
&lt;p&gt;As with R and other languages, comments can be added using the &lt;code&gt;#&lt;/code&gt; comment character. Everything to the right of this character is ignored by Python. This allows you to add words and descriptions to your code which are ignored entirely by the interpreter, but can be used for people looking at the source code to help document what a particular code chunk does. You can NEVER have too many comments!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;installing-python&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;2&lt;/span&gt; Installing Python&lt;/h1&gt;
&lt;p&gt;Python can be downloaded and installed from the &lt;a href=&#34;https://www.python.org/downloads/&#34;&gt;Python&lt;/a&gt; website. It is available for all major operating systems, and installation is quite straightforward. The current version is 3.8.0, but updates are released regularly. Additional packages can be installed by using the &lt;code&gt;pip&lt;/code&gt; Python package manager as follows:&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;pip install newpackage&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is also possible to use larger package managers such as the &lt;a href=&#34;https://anaconda.org&#34;&gt;Anaconda&lt;/a&gt; data science platform. This is an open-source distribution containing over 1,500 Python and R packages that ensures all dependencies are maintained and any required packages are present. &lt;code&gt;conda&lt;/code&gt; will allow you to generate multiple environments to work in depending on requirements.&lt;/p&gt;
&lt;p&gt;Unlike R, there is no specific Integrated Development Environment, but there are multiple different programs that can be sconsidered such as &lt;a href=&#34;https://www.spyder-ide.org&#34;&gt;Spyder&lt;/a&gt; and &lt;a href=&#34;https://www.jetbrains.com/pycharm&#34;&gt;PyCharm&lt;/a&gt;. There is also the &lt;a href=&#34;https://jupyter.org&#34;&gt;Jupyter&lt;/a&gt; notebook program, which allows interactive computing supporting many different programming languages. This is similar to R markdown (which is used to generate the content of this blog), in that it merges markdown formatted text with code chunks. This can be used to create auto-generated reports by including code output embedded into the text.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;basics-of-python&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;3&lt;/span&gt; Basics of Python&lt;/h1&gt;
&lt;div id=&#34;getting-started&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.1&lt;/span&gt; Getting started&lt;/h2&gt;
&lt;p&gt;If using a command line interface, Python can be run simply by typing the name as follows:&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;python&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will open up an interactive Python environment, which can be closed by pressing &lt;code&gt;Ctrl+D&lt;/code&gt;. This is a command line version allowing you to see the results of the commands that you enter as you run them. You can also generate Python scripts, which typically have the suffix &lt;code&gt;.py&lt;/code&gt; and can be run by calling Python on them:&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;python myfile.py&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The command line is shown by the &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; character. Simply type your command here and press return to see the results. If your command is not complete, then you will see a syntax error:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;print (&amp;quot;Hello World!&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is possible to store data values in objects in Python using the &lt;code&gt;=&lt;/code&gt; assignment command. Since these objects can have their value reassigned, they are known as variables. Unlike some other languages, variables do not need to be declared ahead of their use, and their type is declared automatically when you assign them based on their value. Basic data types include integers (a whole number), floating point numbers (fractions), and character strings:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;int = 3
float = 4.678
str = &amp;quot;hello&amp;quot;

print (int)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;print (float)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 4.678&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;print (str)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## hello&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Variables should ideally be named with some descriptor that gives some idea of what it represents. It must start with a letter or underscore, and can only contain alpha-numeric characters and underscores. It is worth bearing in mind that the names are case-sensitive, so &lt;code&gt;myvar&lt;/code&gt;, &lt;code&gt;MyVar&lt;/code&gt; and &lt;code&gt;MYVAR&lt;/code&gt; would be three different variables.&lt;/p&gt;
&lt;p&gt;There are lots of different variable naming conventions to choose from (e.g. see &lt;a href=&#34;https://en.wikipedia.org/wiki/Naming_convention_(programming)&#34;&gt;here&lt;/a&gt;), but once you have chosen one try and stick to it throughout.&lt;/p&gt;
&lt;p&gt;Simple arithmetic can be performed using the standard arithmetic operators (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;), as well as the exponent operator (&lt;code&gt;**&lt;/code&gt;). There is a level of precedence to these functions – the exponent will be calculated first, followed by multiplication and division, followed by plus and minus. For this reason, you must be careful that your arithmetic is doing what you expect it to do. You can get around this by encapsulating subsets of the sum in parentheses, which will be calculated from the inside out:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;1 + 2 * 3   # 2 times 3 is 6, then add 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 7&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;(1 + 2) * 3 # 1 plus 2 is 3, then times 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;1 + (2 * 3) # 2 times 3 is 6, then add 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 7&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;2**4+1      # 2 to the power of 4 is 16, then add 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 17&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The remainder left over following division can be returned by using the “modulo” operator (&lt;code&gt;%%&lt;/code&gt;), and can be important for instance when testing for even numbers:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;6%2 # 6 is divisible by 2 exactly three times&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 0&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;6%4 # 6 is divisible by 4 one time with a remainder of 2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can also use other variables in these assignments:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;x = 1
y = x
y&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;z = x + y 
z&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 2&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;loading-new-packages&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.2&lt;/span&gt; Loading new packages&lt;/h2&gt;
&lt;p&gt;Additional packages can be loaded into Python by using the &lt;code&gt;import&lt;/code&gt; command:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import newpackage&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can name the imported package something different to save having to type the full name every time:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import newpackage as new&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To use a method (e.g. &lt;code&gt;foo()&lt;/code&gt;) from an imported package, we use the dot notation as follows. If we have used a shorter name for the package, we can use this name to save typing the full name each time:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;new.foo()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Sometimes, we may want to only load a package subset which we can do as follows:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;from newpackage import subpackage&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All functions available from this package are now available for use.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;white-space&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.3&lt;/span&gt; White-space&lt;/h2&gt;
&lt;p&gt;One big difference with using Python compared with many other languages is that Python uses white-space to delineate code blocks rather than using curly brackets (&lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;). So indentations must align correctly to ensure that the interpreter is able to determine which code chunks are in the same block. An example of a code chunk is an &lt;code&gt;ifelse&lt;/code&gt; chunk, which will be described later. In R, using curly braces, this would look like this:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- 10
y &amp;lt;- 20
if (x &amp;gt;= y) {
  if (x &amp;gt; y) {
    cat(&amp;quot;x is bigger than y&amp;quot;)
  } else {
    cat(&amp;quot;x is equal to y&amp;quot;)
  }
} else {
  cat(&amp;quot;x is smaller than y&amp;quot;)
} &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## x is smaller than y&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In Python, this is done by ensuring the indentation level of the parent and child statements is kept consistent:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;x = 10
y = 20
if x &amp;gt;= y:
  if x &amp;gt; y:
    print (&amp;quot;x is bigger than y&amp;quot;)
  else:
    print (&amp;quot;x is equal to y&amp;quot;)
else:
  print (&amp;quot;x is smaller than y&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## x is smaller than y&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This ensures that the code looks more clean and elegant, but it does mean that it is possible to run into issues if you do not ensure that the indentation levels are correct. For instance, let’s see what happens if we change the indentation levels of the print functions:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;x = 10
y = 20
if x &amp;gt;= y:
  if x &amp;gt; y:
  print (&amp;quot;x is bigger than y&amp;quot;)
  else:
  print (&amp;quot;x is equal to y&amp;quot;)
else:
  print (&amp;quot;x is smaller than y&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;object-oriented-programming&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.4&lt;/span&gt; Object-oriented programming&lt;/h2&gt;
&lt;p&gt;Python supports an object-oriented programming (OOP) paradigm. The idea here is that each object that you use in Python is an instance of some well-defined class of data that has a set of attributes that can be accessed and methods that can be applied to it. New data classes can be specified which inherit the attributes and methods from other data types, making OOP a very modular programming approach. All of this information can be hidden away from the user, and only certain attributes and methods are made available whilst the rest are kept internal and private.&lt;/p&gt;
&lt;p&gt;An example of this is to consider a new class &lt;code&gt;Car&lt;/code&gt;. There are many different cars out there, but each specific car is an instance of this new class &lt;code&gt;Car&lt;/code&gt;. When creating the new class, we can assign it certain attributes, such as &lt;code&gt;model&lt;/code&gt;, &lt;code&gt;make&lt;/code&gt;, &lt;code&gt;colour&lt;/code&gt;, &lt;code&gt;horsepower&lt;/code&gt;, &lt;code&gt;engine size&lt;/code&gt;, etc.&lt;/p&gt;
&lt;p&gt;We can create such a new class as follows:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;class Car:
  def __init__(self):
    pass&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The class now exists, but there are no objects of this class. The class has an initializer function (the &lt;code&gt;__init(self)__&lt;/code&gt; function) that will create a new object of class &lt;code&gt;Car&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mycar = Car()
print(mycar)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;lt;__main__.Car object at 0x11f5a8a90&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So &lt;code&gt;mycar&lt;/code&gt; is an object of class &lt;code&gt;Car&lt;/code&gt;, but does not have any attributes associated with it. So let’s add a few:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;class Car:
  def __init__(self, make, model):
    self.make  = make
    self.model = model&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can instantiate a new object of class &lt;code&gt;Car&lt;/code&gt; with a specific make and model. The attributes are accessed using dot notation as follows:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mycar = Car(&amp;quot;Honda&amp;quot;, &amp;quot;Civic&amp;quot;)
print(mycar.make)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Honda&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;print(mycar.model)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Civic&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We may also want to include some methods that can be applied to our object, such as &lt;code&gt;drive&lt;/code&gt;, where we can input a new destination to drive to. So let’s add a &lt;code&gt;drive()&lt;/code&gt; method to the &lt;code&gt;Car&lt;/code&gt; class:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;class Car:
  def __init__(self, make, model):
    self.make  = make
    self.model = model
    
  def drive(self, where):
    print (&amp;quot;Driving to &amp;quot; + where)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And let’s drive home in our car:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mycar = Car(&amp;quot;Honda&amp;quot;, &amp;quot;Civic&amp;quot;)
mycar.drive(&amp;quot;home&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Driving to home&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I will describe some of these features in more detail later, but the dot notation for accessing object attributes and methods will feature in the following sections.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;data-types&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.5&lt;/span&gt; Data Types&lt;/h2&gt;
&lt;p&gt;There are many classes available in Python, as well as the ability to generate new classes as described above. The most common are “numeric” (which you can do numerical calculations on – integers or floating point numbers), character strings (can contain letters, numbers, symbols etc., but cannot run numerical calculations), and boolean (TRUE or FALSE). The speech marks character &lt;code&gt;&amp;quot;&lt;/code&gt; is used to show that the class of y is “character”. You can also use the apostrophe &lt;code&gt;&#39;&lt;/code&gt;. You can check the class of a variable by using the &lt;code&gt;type()&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;x = 12345
type(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;lt;class &amp;#39;int&amp;#39;&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;y = 12345.0
type(y)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;lt;class &amp;#39;float&amp;#39;&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;z = &amp;quot;12345&amp;quot;
type(z)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;lt;class &amp;#39;str&amp;#39;&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Addition is a well-defined operation on numerical objects, but is not defined on character class objects. Attempting to use a function which has not been defined for the object in question will throw an error:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;x + 1 # x is numeric, so addition is well defined
y + 1 # y is a character, so addition is not defined - produces an error&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The other important data class is “boolean”, which is simply a binary &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt; value. There are certain operators that are used to compare two variables. The obvious ones are “is less than” (&lt;code&gt;&amp;lt;&lt;/code&gt;), “is greater than” (&lt;code&gt;&amp;gt;&lt;/code&gt;), “is equal to”&amp;quot; (&lt;code&gt;==&lt;/code&gt;). You can also combine these to see “is less than or equal to” (&lt;code&gt;&amp;lt;=&lt;/code&gt;) or “is greater than or equal to” (&lt;code&gt;&amp;gt;=&lt;/code&gt;). If the statement is true, then it will return the output “True”. Otherwise it will return “False”:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;x = 2
y = 3

x &amp;lt;= y&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## True&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;x &amp;gt;= y&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## False&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can also combine these logical tests to ask complex questions by using the &lt;code&gt;and&lt;/code&gt; (&lt;code&gt;&amp;amp;&lt;/code&gt;) or the &lt;code&gt;or&lt;/code&gt; (&lt;code&gt;|&lt;/code&gt;) operators. You can also negate the output of a logical test by using the &lt;code&gt;not&lt;/code&gt; (&lt;code&gt;!&lt;/code&gt;) operator. This lets you test for very specific events in your data. Again, I recommend using parentheses to break up your tests to ensure that the tests occur in the order which you expect:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;x = 3
y = 7
z = 6

(x &amp;lt;= 3 &amp;amp; y &amp;gt;= 8) &amp;amp; z == 6  &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## False&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;(x &amp;lt;= 3 &amp;amp; y &amp;gt;= 8) | z == 6 &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## True&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;(x != y)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## True&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;function&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.6&lt;/span&gt; Function&lt;/h2&gt;
&lt;p&gt;A function (also known as a method, subroutine, or procedure) is a named block of code that takes in one or more values, does something to them, and returns a result. A simple example is the &lt;code&gt;sum()&lt;/code&gt; function, which takes in two or more values in the form of a list, and returns the sum of all of the values:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;sum([1,2,3]) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, the &lt;code&gt;sum()&lt;/code&gt; function takes only one variable (in this case a numeric list). Sometimes functions take more than one variable (also known as “arguments”). These are named values that must be specified for the function to run. The &lt;code&gt;sum()&lt;/code&gt; function takes two named arguments – &lt;code&gt;iterable&lt;/code&gt; (the list, tuple, etc whose items you wish to add together) and &lt;code&gt;start&lt;/code&gt; (an optional value to start the sum from). By default, the value of &lt;code&gt;start&lt;/code&gt; is 0, but you may want to add the sum to another value (for instance if you are calculating a cummulative sum):&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;sum([1,2,3], 10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 16&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you do not name arguments, they will be taken and assigned to the arguments in the order in which they are input. Any arguments not submitted will use their default value (0 for the case of &lt;code&gt;start&lt;/code&gt; here). We can however name the arguments and set the value using the &lt;code&gt;=&lt;/code&gt; sign.&lt;/p&gt;
&lt;p&gt;To see the documentation for a specific function, use the &lt;code&gt;help()&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;help(sum)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Help on built-in function sum in module builtins:
## 
## sum(iterable, start=0, /)
##     Return the sum of a &amp;#39;start&amp;#39; value (default: 0) plus an iterable of numbers
##     
##     When the iterable is empty, return the start value.
##     This function is intended specifically for use with numeric values and may
##     reject non-numeric types.&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;printing&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.7&lt;/span&gt; Printing&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;print()&lt;/code&gt; can be used to print whatever is stored in the variable the function is called on. Print is what is known as an “overloaded”&amp;quot; function, which means that there are many functions named &lt;code&gt;print()&lt;/code&gt;, each written to deal with an object of a different class. The correct one is used based on the object that you supply. So calling &lt;code&gt;print()&lt;/code&gt; on a numeric variable will print the value stored in the variable. Calling it on a list prints all of the values stored in the list:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;x = 1
print (x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;y = [1,2,3,4,5]
print (y)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1, 2, 3, 4, 5]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you notice, using &lt;code&gt;print()&lt;/code&gt; is the default when you just call the variable itself:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;x&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;y&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1, 2, 3, 4, 5]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we are supplying a single argument to &lt;code&gt;print()&lt;/code&gt;. Multiple different string values can be concatenated using the &lt;code&gt;+&lt;/code&gt; character, and this concatenated string can then be printed:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;x = &amp;quot;hello&amp;quot;
y = &amp;quot;world&amp;quot;
print(x + y)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## helloworld&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note here that the &lt;code&gt;+&lt;/code&gt; character will join the strings directly, so there is no space. However, &lt;code&gt;print()&lt;/code&gt; is also able to take any number of different arguments, and will print them one after the other with a space in between:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;x = &amp;quot;hello&amp;quot;
y = &amp;quot;world&amp;quot;
print(x, y)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## hello world&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The concatenate command is only able to concatanate strings, so could not deal with numerical values:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;x = 100
y = &amp;quot;bottles of beer on the wall&amp;quot;
print(x + y)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, it is possible to caste a numeric value to a string using the &lt;code&gt;str()&lt;/code&gt; function, but using the multi-parameter use of the &lt;code&gt;print()&lt;/code&gt; method will automatically take care of this:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;x = 100
y = &amp;quot;bottles of beer on the wall&amp;quot;
print(x, y)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 100 bottles of beer on the wall&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;\t&lt;/code&gt; is a special printing characters that you can use to print a tab character. Another similar special character that you may need to use is &lt;code&gt;\n&lt;/code&gt; which prints a new line:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;x = &amp;quot;hello&amp;quot;
y = &amp;quot;world&amp;quot;
print(x + &amp;quot;\t&amp;quot; + y + &amp;#39;\n&amp;#39; + &amp;quot;next line&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## hello    world
## next line&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are also other characters, such as &lt;code&gt;&#39;&lt;/code&gt;, &lt;code&gt;&amp;quot;&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;\&lt;/code&gt;, which may require “escaping” with a backslash to avoid being interpreted in a different context. For instance, if you have a string containing an apostrophe within a string defined using apostrophes, the string will be interpreted as terminating earlier, and the code will not do what you expect:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;print(&amp;#39;It&amp;#39;s very annoying when this happens...&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the string submitted to &lt;code&gt;print()&lt;/code&gt; is actual “It” rather than the intended “It’s very annoying when this happens…”. The function will not know what to do about the remainder of the string, so an error will occur. However, by escaping the apostrophe, the string will be interpreted correctly:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;print(&amp;#39;It\&amp;#39;s easily fixed though!&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## It&amp;#39;s easily fixed though!&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another alternative is to use double apostrophes as the delimiter, which will avoid the single apostrophe being misinterpreted:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;print(&amp;quot;It&amp;#39;s easily fixed though!&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## It&amp;#39;s easily fixed though!&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An alternative approach to using the concatanate operator that is able to cope with multiple different classes is to use %-formatting:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;print(&amp;quot;%10s\t%5s&amp;quot; % (&amp;quot;Hello&amp;quot;, &amp;quot;World&amp;quot;)) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      Hello   World&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;print(&amp;quot;%10s\t%5s&amp;quot; % (&amp;quot;Helloooooo&amp;quot;, &amp;quot;World&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Helloooooo   World&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first string shows how we want the inputs to be formatted, followed by a &lt;code&gt;%&lt;/code&gt; operator and a list of the inputs. Within the formatting string, placeholders of the form &lt;code&gt;%10s&lt;/code&gt; are replaced by the given inputs, with the first being replaced by the first argument in the list, and so on (so the number of additional arguments after the &lt;code&gt;%&lt;/code&gt; operator must match the number of placeholders). The number in the placeholder defines the width to allocate for printing that argument (positive is right aligned, negative is left aligned), decimal numbers in the placeholder define precision of floating point numbers, and the letter defines the type of argument to print (e.g. &lt;code&gt;s&lt;/code&gt; for string, &lt;code&gt;i&lt;/code&gt; for integer, &lt;code&gt;f&lt;/code&gt; for fixed point decimal, &lt;code&gt;e&lt;/code&gt; for exponential decimal). Here are some examples:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;print(&amp;quot;%20s&amp;quot;  % (&amp;quot;Hello&amp;quot;)) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                Hello&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;print(&amp;quot;%-20s&amp;quot; % (&amp;quot;Hello&amp;quot;)) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Hello&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;print(&amp;quot;%10i&amp;quot;  % (12345)) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      12345&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;print(&amp;quot;%10f&amp;quot;  % (12.345)) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  12.345000&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;print(&amp;quot;%10e&amp;quot;  % (12.345)) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 1.234500e+01&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;f-strings offer the same control on incorprating multiple variables into a string, but in a slightly more readable manner. In f-strings, the string is preceeded by the &lt;code&gt;f&lt;/code&gt; operator, and the variables are incorprated into the string by name within curly braces:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;forename = &amp;quot;Sam&amp;quot;
surname = &amp;quot;Robson&amp;quot;
job = &amp;quot;Bioinformatician&amp;quot;
f&amp;quot;My name is {forename} {surname} and I am a {job}&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;My name is Sam Robson and I am a Bioinformatician&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The contents of the curly braces are evaluated at runtime, so can contain any valid expression:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;f&amp;quot;2 times 3 is {2*3}&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;2 times 3 is 6&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For readibility, these can be split over multiple lines, provided that each new line begins with the &lt;code&gt;f&lt;/code&gt; operator:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;forename = &amp;quot;Sam&amp;quot;
surname = &amp;quot;Robson&amp;quot;
job = &amp;quot;Bioinformatician&amp;quot;
description = (f&amp;quot;My name is {forename} {surname}. &amp;quot;
               f&amp;quot;I am a {job}&amp;quot;)
description&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;My name is Sam Robson. I am a Bioinformatician&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;storing-multiple-values&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;4&lt;/span&gt; Storing Multiple Values&lt;/h1&gt;
&lt;div id=&#34;lists-and-tuples&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;4.1&lt;/span&gt; Lists and Tuples&lt;/h2&gt;
&lt;p&gt;In Python, vector-like lists of values are known as &lt;code&gt;lists&lt;/code&gt;. They can be declared simply by using square bracket notation as follows:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mylist = [1,2,3,4,5]
mylist&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1, 2, 3, 4, 5]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lists can store multiple variables of any data type, and are a very useful way of storing linked data together:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mylist = [1,2,3,4,5,&amp;quot;once&amp;quot;,&amp;quot;I&amp;quot;,&amp;quot;caught&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;fish&amp;quot;,&amp;quot;alive&amp;quot;,True]
mylist&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1, 2, 3, 4, 5, &amp;#39;once&amp;#39;, &amp;#39;I&amp;#39;, &amp;#39;caught&amp;#39;, &amp;#39;a&amp;#39;, &amp;#39;fish&amp;#39;, &amp;#39;alive&amp;#39;, True]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can use the &lt;code&gt;range()&lt;/code&gt; function to create a sequence of integer values from a starting value to an end value. However, note that the end value is &lt;em&gt;not&lt;/em&gt; included:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;myrange = range(0,5)
for i in myrange:
  print(i)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 0
## 1
## 2
## 3
## 4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that I will discuss the &lt;code&gt;for&lt;/code&gt; loop in a later section. You can also add a third parameter to define the step between the sequential values. So to take every &lt;em&gt;other&lt;/em&gt; value from 0 to 10, you would add a step value of 2:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;myrange = range(0,11,2)
for i in myrange:
  print(i)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 0
## 2
## 4
## 6
## 8
## 10&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can access the individual elements of the list by using square brackets (&lt;code&gt;[&lt;/code&gt;) to index the array. The elements in the vector are numbered from 0 upwards, so to take the first and last values we do the following:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mylist[0]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mylist[4]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mylist[5]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;once&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, an error is returned if you try to take an element that does not exist. The subset can be as long as you like, as long as it’s not longer than the full set:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mylist[1:4]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [2, 3, 4]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This process is known as “slicing”. It is also possible to tell Python how many values we want to increment by as we slice. So to take every &lt;em&gt;other&lt;/em&gt; value in the above slice, we would do the following:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mylist[1:4:2]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [2, 4]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This can also be used to reverse the order, by adding a minus sign to this final value. Here we do not specifically tell Python which values to use as the first and last value (which will take &lt;em&gt;all&lt;/em&gt; values), and increment by 1 again (which is implicit when no third value is included) using a minus sign to get the values in the reverse order:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mylist[::-1]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [True, &amp;#39;alive&amp;#39;, &amp;#39;fish&amp;#39;, &amp;#39;a&amp;#39;, &amp;#39;caught&amp;#39;, &amp;#39;I&amp;#39;, &amp;#39;once&amp;#39;, 5, 4, 3, 2, 1]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the &lt;code&gt;:&lt;/code&gt; in the brackets simply means to take all of the numbers from the first up to (but not including) the last. So &lt;code&gt;[0:2]&lt;/code&gt; will return the first 2 elements of the vector.&lt;/p&gt;
&lt;p&gt;Using negative values for the start or end values will start the counting from the end of the array. So the index -2 will be the position 2 from the end of the array. Thus to get the final 2 values from a list we can do the following:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mylist[-2:]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [&amp;#39;alive&amp;#39;, True]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also use the square bracket notation to reassign elements of the list:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mylist2 = [1,2,3,4,5]
mylist2[0] = &amp;quot;Hello World!&amp;quot;
mylist2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [&amp;#39;Hello World!&amp;#39;, 2, 3, 4, 5]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A &lt;code&gt;tuple&lt;/code&gt; is very similar to a list, with two main differences. The first is that we use normal parentheses &lt;code&gt;(&lt;/code&gt; rather than square brackets, and the second is that we cannot change the elements of the tuple. The tuple isordered and &lt;em&gt;immutable&lt;/em&gt;:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mylist2 = (1,2,3,4,5)
mylist2[0] = &amp;quot;Hello World!&amp;quot;
mylist2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can completely reassign the entire variable if you want to, but once the elements of the tuple have been set they cannot be changed.&lt;/p&gt;
&lt;p&gt;To drop elements from a list, you use the &lt;code&gt;pop()&lt;/code&gt; method. So to remove the value &lt;code&gt;2&lt;/code&gt; from the array we would do the following:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mylist = [1,2,3,4,5]
mylist.pop(1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mylist&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1, 3, 4, 5]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To add extra elements to a list, you can use the &lt;code&gt;append()&lt;/code&gt; method. So to add the value 2 back in we would do the following:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mylist.append(2)
mylist&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1, 3, 4, 5, 2]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note here that &lt;code&gt;append()&lt;/code&gt; will add the value to the very end of the list To add an element to a specified position, you can use the &lt;code&gt;insert()&lt;/code&gt; method, specifying the specific position to which you want to add the value in the list:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mylist.insert(1, &amp;quot;Hello World!&amp;quot;)
mylist&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1, &amp;#39;Hello World!&amp;#39;, 3, 4, 5, 2]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the list can take values of different types. You can even create lists of lists, which can be accessed using multiple square brackets:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mylist = [1,2,3]
mylist.append([&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;])
mylist&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1, 2, 3, [&amp;#39;hello&amp;#39;, &amp;#39;world&amp;#39;]]&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mylist[3][0]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;hello&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we select the first value from the array that makes up the fourth element of the array after appending.&lt;/p&gt;
&lt;p&gt;We can also sort data in a list simply using the &lt;code&gt;sort()&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mynum = [3, 94637, 67, 45, 23, 100, 45]
mynum.sort()
print(mynum)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [3, 23, 45, 45, 67, 100, 94637]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This works on both numeric and string data:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mystr = [&amp;#39;o&amp;#39;, &amp;#39;a&amp;#39;, &amp;#39;u&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;i&amp;#39;]
mystr.sort()
print(mystr)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [&amp;#39;a&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;u&amp;#39;]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By default sorting is from lowest to highest. By including the &lt;code&gt;reverse = True&lt;/code&gt; argument, we can get the list sorted in a reverse order:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mynum = [3, 94637, 67, 45, 23, 100, 45]
mynum.sort(reverse = True)
print(mynum)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [94637, 100, 67, 45, 45, 23, 3]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;dictionary&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;4.2&lt;/span&gt; Dictionary&lt;/h2&gt;
&lt;p&gt;A dictionary in Python is a named list, containing a series of key-value pairs, and is declared surrounded by curly braces. Each item in the dictionary is separated by commas and contains a key and a value separated by ‘:’ characters. Each key must be unique, whilst the values to which they refer may not be.&lt;/p&gt;
&lt;p&gt;Dictionaries have the benefit compared to lists that you can access values based on the key values, using standard square bracket notation with the key name. This means that you do not need to know the index number for the value that you wish to access:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mydict = {&amp;#39;forename&amp;#39;:&amp;#39;Sam&amp;#39;, &amp;#39;surname&amp;#39;:&amp;#39;Robson&amp;#39;, &amp;#39;job&amp;#39;:&amp;#39;Bioinformatician&amp;#39;}
print(mydict[&amp;quot;forename&amp;quot;], mydict[&amp;quot;surname&amp;quot;])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Sam Robson&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can use the square bracket notation to update the entry in the dictionary for the specified item:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mydict[&amp;quot;forename&amp;quot;] = &amp;quot;Samuel&amp;quot;
print(mydict[&amp;quot;forename&amp;quot;], mydict[&amp;quot;surname&amp;quot;])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Samuel Robson&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And new items can be added by using a key that does not exist in the dictionary already:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mydict[&amp;quot;skills&amp;quot;] = &amp;quot;Python&amp;quot;
print(mydict[&amp;quot;skills&amp;quot;])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Python&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;del&lt;/code&gt; statement can be used to remove specific entries in the dictionary:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;del mydict[&amp;quot;skills&amp;quot;]
print(mydict)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## {&amp;#39;forename&amp;#39;: &amp;#39;Samuel&amp;#39;, &amp;#39;surname&amp;#39;: &amp;#39;Robson&amp;#39;, &amp;#39;job&amp;#39;: &amp;#39;Bioinformatician&amp;#39;}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And all items can be cleared by calling the &lt;code&gt;clear()&lt;/code&gt; method:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mydict.clear()
print(mydict)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## {}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The length of a dictionary, specifically the number of key-value pairs, can be shown by using the &lt;code&gt;len()&lt;/code&gt; method:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mydict = {&amp;#39;forename&amp;#39;:&amp;#39;Sam&amp;#39;, &amp;#39;surname&amp;#39;:&amp;#39;Robson&amp;#39;, &amp;#39;job&amp;#39;:&amp;#39;Bioinformatician&amp;#39;}
len(mydict)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also pull out all of the key-value pairs in the dictionary using the &lt;code&gt;items()&lt;/code&gt; method:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mydict = {&amp;#39;forename&amp;#39;:&amp;#39;Sam&amp;#39;, &amp;#39;surname&amp;#39;:&amp;#39;Robson&amp;#39;, &amp;#39;job&amp;#39;:&amp;#39;Bioinformatician&amp;#39;}
mydict.items()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## dict_items([(&amp;#39;forename&amp;#39;, &amp;#39;Sam&amp;#39;), (&amp;#39;surname&amp;#39;, &amp;#39;Robson&amp;#39;), (&amp;#39;job&amp;#39;, &amp;#39;Bioinformatician&amp;#39;)])&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;numpy&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;5&lt;/span&gt; NumPy&lt;/h1&gt;
&lt;div id=&#34;introduction-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;5.1&lt;/span&gt; Introduction&lt;/h2&gt;
&lt;p&gt;Many calculations in data science require a field of mathematics called “linear algebra”, which is all about multiplication of data stored in vectors and matrices. &lt;a href=&#34;https://numpy.org&#34;&gt;NumPy&lt;/a&gt; is one of the most commonly used packages for scientific computing and provides very powerful tools for linear algebra using code from fast languages such as C/C++ and fortran. It allows you to generate arrays of values and offers vectorised calculations for linear algebra that offer huge improvements in performance. For instance, to sum two vectors of equal size (1 dimensional arrays), the result will be a vector where the i&lt;sup&gt;th&lt;/sup&gt; entry is the sum of the i&lt;sup&gt;th&lt;/sup&gt; entries from the input vectors.&lt;/p&gt;
&lt;p&gt;NumPy is imported by using the &lt;code&gt;import&lt;/code&gt; declaration, and access functions from the package directly using the package name. We can define a shortened name for the package so that we do not have to type &lt;code&gt;numpy&lt;/code&gt; every time:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import numpy as np&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;arrays&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;5.2&lt;/span&gt; Arrays&lt;/h2&gt;
&lt;p&gt;We can convert Python lists into NumPy arrays and use these to access the powerful additional methods associated with these data types:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;x = np.array([2,3,2,4,5])
y = np.array([4,1,1,2,3])

x+y&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## array([6, 4, 3, 6, 8])&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;x*y&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## array([ 8,  3,  2,  8, 15])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There is not much difference between the normal Python lists that we saw previously and the np arrays shown here, but the functionality is significantly improved. One function is the &lt;code&gt;np.arange()&lt;/code&gt; method, which allows us to generate a list of values between a start and end point incremented by a specific value. Unlike the &lt;code&gt;range()&lt;/code&gt; function seen previously, the step value does not need to be an integer:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;np.arange(0,10,2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## array([0, 2, 4, 6, 8])&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;np.arange(0,100,10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## array([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90])&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;np.arange(1,2,0.1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## array([1. , 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The three arguments are the starting value, the final value (note that this will &lt;em&gt;not&lt;/em&gt; be included in the final list), and the step size.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;matrices&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;5.3&lt;/span&gt; Matrices&lt;/h2&gt;
&lt;p&gt;As well as 1D arrays, we can look at 2D arrays, or &lt;code&gt;matrices&lt;/code&gt;. For example, this may be how you are used to seeing data in a spreadsheet context, with each row representing a different sample, and each row representing some measurement for that sample. An array is a special case of a matrix with only 1 row. We can use the &lt;code&gt;np.reshape()&lt;/code&gt; method to reshape an array into a different shape by giving the number of rows and columns of the output that we want to see:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;np.arange(1,10,1).reshape(3,3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## array([[1, 2, 3],
##        [4, 5, 6],
##        [7, 8, 9]])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note here that a matrix uses double square brackets &lt;code&gt;[[&lt;/code&gt; rather than the single square brackets used for 1-dimensional arrays. We can check the shape of the matrix by using the &lt;code&gt;shape()&lt;/code&gt; method:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;myarray = np.arange(1,10,1)
myarray.shape&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## (9,)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mymatrix = myarray.reshape(3,3)
mymatrix.shape&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## (3, 3)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The shape is given by a tuple where the first value gives the number of rows and the second gives the number of columns. Before reshaping, &lt;code&gt;myarray&lt;/code&gt; is a 1D array. After reshaping, &lt;code&gt;mymatrix&lt;/code&gt; becomes a 2D array, or matrix.&lt;/p&gt;
&lt;p&gt;You can also generate a matrix as an array of arrays using double square baracket notation. Note that when doing this the length of each array must match to create a matrix:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mymatrix = np.array([[1,2,3],[4,5,6]])
print(mymatrix)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1 2 3]
##  [4 5 6]]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;indexing-and-slicing&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;5.4&lt;/span&gt; Indexing and slicing&lt;/h2&gt;
&lt;p&gt;Indexing of 1D arrays works similarly to that of lists, by using the index of the value that you want to access in square brackets. Again, remember that indexing begins at 0, not 1, so to get the second value in the array you would use the index 1:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mymatrix = np.array([1,2,3,4,5,6])
print(mymatrix[1])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The syntax for slicing is also the same as for lists, using &lt;code&gt;:&lt;/code&gt; to define the range:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mymatrix = np.array([1,2,3,4,5,6])
print(mymatrix[2:4])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [3 4]&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;print(mymatrix[::2])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1 3 5]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For 2D matrix indexing, we need to specify two values - one for the index of the rows and another for the index of the columns:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mymatrix = np.array([[1,2,3],[4,5,6]])
print(mymatrix[0,0])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Slicing can be a little more complex, but you can use the same approach of specifying the row and column slices separated by a comma as above. So to take the first two columns we would do the following to take all of the rows (&lt;code&gt;:&lt;/code&gt;), but only the first two columns (&lt;code&gt;0:2&lt;/code&gt;):&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mymatrix = np.array([[1,2,3],[4,5,6]])
print(mymatrix[:,0:2])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1 2]
##  [4 5]]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;matrix-multiplication&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;5.5&lt;/span&gt; Matrix multiplication&lt;/h2&gt;
&lt;p&gt;Multiplication of matrices is probably too much to go into in too much detail here, but the &lt;code&gt;dot product&lt;/code&gt; of two matrices can only be performed if the number of &lt;em&gt;columns&lt;/em&gt; of the first matrix matches the number of &lt;em&gt;rows&lt;/em&gt; of the second. The dot product can be calculated for two such matrices using the &lt;code&gt;np.dot()&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;A = np.array([1,2,3]).reshape(1,3)
B = np.arange(1,10,1).reshape(3,3)
np.dot(A,B)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## array([[30, 36, 42]])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Matrix multiplication does not always follow the commutative law of multiplication, since it is not always the case that &lt;code&gt;A.B&lt;/code&gt; is the same as &lt;code&gt;B.A&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;np.dot(A,B)
np.dot(B,A)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The identity matrix is an example where matrix multiplication &lt;em&gt;is&lt;/em&gt; commutative, since any matrix multiplied by the identity matrix (of the correct dimensions) gives itself. To give an identity matrix, a square matrix with 1s on the diagonals and 0s everywhere else, you can use the &lt;code&gt;np.eye()&lt;/code&gt; function with the dimension specified:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;C = np.eye(3)
print(C)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1. 0. 0.]
##  [0. 1. 0.]
##  [0. 0. 1.]]&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;np.dot(B,C)
np.dot(C,B)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are a number of other useful functions available that are very useful in the field of linear algebra and matrix multiplication. For example, to generate a matrix of 0s, you can use the &lt;code&gt;np.zeros()&lt;/code&gt; function, giving a 2D tuple as input:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;np.zeros((2,3))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## array([[0., 0., 0.],
##        [0., 0., 0.]])&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;sorting&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;5.6&lt;/span&gt; Sorting&lt;/h2&gt;
&lt;p&gt;NumPy has a powerful sorting method, which can act much like the list &lt;code&gt;sort()&lt;/code&gt; function seen previously:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;myarray = np.array([3, 94637, 67, 45, 23, 100, 45])
myarray.sort()
print(myarray)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [    3    23    45    45    67   100 94637]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We are also able to use the &lt;code&gt;argsort()&lt;/code&gt; method to get the indexing of the input array, rather than the sorted array itself:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;myarray = np.array([3, 94637, 67, 45, 23, 100, 45])
myarray.argsort()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## array([0, 4, 3, 6, 2, 5, 1])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This sort function is more powerful than the standard Python sort function for lists as it is able to sort both 1D arrays and 2D (and indeed multi-dimensional in general) matrices, and can use multiple different sorting algorithms. For matrices, the default is to sort the values on the final axis, which in the case of the case of a 2D matrix will sort the values within each row individually:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mymatrix = np.array([[6,3,3],[1,2,4]])
mymatrix.sort()
print(mymatrix)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[3 3 6]
##  [1 2 4]]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we would instead prefer to sort on the columns, we can specify the &lt;code&gt;axis&lt;/code&gt; argument:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mymatrix = np.array([[6,3,3],[1,2,4]])
mymatrix.sort(axis=0)
print(mymatrix)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1 2 3]
##  [6 3 4]]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also specify which algorithm we want to use for sorting (e.g. &lt;code&gt;quicksort&lt;/code&gt;, &lt;code&gt;mergesort&lt;/code&gt; or &lt;code&gt;heapsort&lt;/code&gt;), which can have an impact on the speed and efficiency:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mymatrix = np.array([[6,3,3],[1,2,4]])
mymatrix.sort(kind = &amp;#39;mergesort&amp;#39;)
print(mymatrix)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[3 3 6]
##  [1 2 4]]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;structured-array&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;5.7&lt;/span&gt; Structured Array&lt;/h2&gt;
&lt;p&gt;NumPy arrays are homogenous, and contain a single class of data. Structured arrays on the other hand are arrays of structures, each of a different class. For this, we need to define ahead of time the class of data to be included by using a &lt;code&gt;dtype&lt;/code&gt; parameter. This is a list of tupels, where each tupel is a pair giving the name of the structure and the type of data that it will hold:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;dtype = [(&amp;#39;Name&amp;#39;, (np.str_, 10)), (&amp;#39;Age&amp;#39;, np.int32), (&amp;#39;Score&amp;#39;, np.float64)]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, we are defining 3 types of fields within the structure:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;code&gt;Name&lt;/code&gt; – A string with a maximum of 10 characters&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Age&lt;/code&gt; – A 32 bit integer&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Score&lt;/code&gt; – A 64 bit floating point value&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Then we can create a structured array where every element is a tuple containing exactly 3 values corresponding to the types as described in &lt;code&gt;dtype&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mystruct = np.array([(&amp;#39;John&amp;#39;, 37, 99.3), (&amp;#39;Paul&amp;#39;, 33, 92.6), (&amp;#39;Ringo&amp;#39;, 40, 97.5), (&amp;#39;George&amp;#39;, 35, 92.6)], dtype = dtype)
print(mystruct)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [(&amp;#39;John&amp;#39;, 37, 99.3) (&amp;#39;Paul&amp;#39;, 33, 92.6) (&amp;#39;Ringo&amp;#39;, 40, 97.5)
##  (&amp;#39;George&amp;#39;, 35, 92.6)]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This structured array is a table-like structure that can make it easier to access and modify elements of the data. For instance, the sort function on this data type can take the parameter &lt;code&gt;order&lt;/code&gt; to specify which field to use for sorting. So to sort by the &lt;code&gt;Score&lt;/code&gt; field, we would do the following:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mystruct.sort(order=&amp;quot;Score&amp;quot;)
print(mystruct)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [(&amp;#39;George&amp;#39;, 35, 92.6) (&amp;#39;Paul&amp;#39;, 33, 92.6) (&amp;#39;Ringo&amp;#39;, 40, 97.5)
##  (&amp;#39;John&amp;#39;, 37, 99.3)]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can order on multiple fields to break ties in the &lt;code&gt;Score&lt;/code&gt; field by organising also on the &lt;code&gt;Age&lt;/code&gt; field:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;mystruct.sort(order=[&amp;quot;Score&amp;quot;,&amp;quot;Age&amp;quot;])
print(mystruct)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [(&amp;#39;Paul&amp;#39;, 33, 92.6) (&amp;#39;George&amp;#39;, 35, 92.6) (&amp;#39;Ringo&amp;#39;, 40, 97.5)
##  (&amp;#39;John&amp;#39;, 37, 99.3)]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;pandas&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;6&lt;/span&gt; Pandas&lt;/h1&gt;
&lt;div id=&#34;introduction-2&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;6.1&lt;/span&gt; Introduction&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://pandas.pydata.org&#34;&gt;Pandas&lt;/a&gt; is another commonly used library in Python that introduces a number of incredibly powerful tools for data wrangling from Wes McKinney. Pandas can load data from a number of sources, including comma separated or tab-delimited text files (CSV or TSV files respectively) and creates aPython object in the sort of structure that one would expect from a spreadsheet type software such as Excel. This &lt;code&gt;data frame&lt;/code&gt; shows many similarities with the &lt;code&gt;data.frame&lt;/code&gt; class in R. This is a high-level data structure, offering more control in order to access specific data than working with dictionaries and structured arrays.&lt;/p&gt;
&lt;p&gt;To import the package, we use the &lt;code&gt;import&lt;/code&gt; command, and as with NumPy we can give it a local name to avoid having to write the whole name every time:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import pandas as pd&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;data-frames&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;6.2&lt;/span&gt; Data Frames&lt;/h2&gt;
&lt;p&gt;Data frames can be generated by converting lists, dictionaries or NumPy arrays by using the &lt;code&gt;pd.DataFrame()&lt;/code&gt; function. Unlike the structured array, we do not need to specify the data types ahead of time. DataFrames can be generated from a list of lists by specifying the column names as follows:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;array = [[&amp;#39;John&amp;#39;, 37, 99.3], [&amp;#39;Paul&amp;#39;, 33, 92.6], [&amp;#39;Ringo&amp;#39;, 40, 97.5], [&amp;#39;George&amp;#39;, 35, 92.6]]
df = pd.DataFrame(array, columns = [&amp;#39;Name&amp;#39;, &amp;#39;Age&amp;#39;, &amp;#39;Score&amp;#39;])
df&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      Name  Age  Score
## 0    John   37   99.3
## 1    Paul   33   92.6
## 2   Ringo   40   97.5
## 3  George   35   92.6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Alternatively, you can use the dict syntax, wherby each column of the DataFrame is a different key-value pair in the dictionary, and the value is a list of entries of the same type:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;dict = {&amp;#39;Name&amp;#39;:[&amp;#39;John&amp;#39;, &amp;#39;Paul&amp;#39;, &amp;#39;Ringo&amp;#39;, &amp;#39;George&amp;#39;], &amp;#39;Age&amp;#39;:[37,33,40,35], &amp;#39;Score&amp;#39;:[99.3,92.6,97.5,92.6]}
df = pd.DataFrame(dict)
df&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      Name  Age  Score
## 0    John   37   99.3
## 1    Paul   33   92.6
## 2   Ringo   40   97.5
## 3  George   35   92.6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The Pandas DataFrame class offers a large number of commonly used statistical functions which can generate summary statistics for the columns in the dataFrame. So to get the mean value of the numerical columns we would use &lt;code&gt;df.mean()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df.mean()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Age      36.25
## Score    95.50
## dtype: float64&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And for the standard deviation we would use df.std()`:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df.std()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Age      2.986079
## Score    3.428313
## dtype: float64&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;indexing-and-slicing-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;6.3&lt;/span&gt; Indexing and Slicing&lt;/h2&gt;
&lt;p&gt;Selecting data from a DataFrame is significantly easier than trying to do so from lower-level Python classes. Getting data from specific columns is simply done by using the name of the column in square brackets:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df[&amp;#39;Name&amp;#39;]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 0      John
## 1      Paul
## 2     Ringo
## 3    George
## Name: Name, dtype: object&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Multiple columns can be specified as a list:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df[[&amp;#39;Age&amp;#39;, &amp;#39;Score&amp;#39;]]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Age  Score
## 0   37   99.3
## 1   33   92.6
## 2   40   97.5
## 3   35   92.6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Selecting data in this way will return a new DataFrame. Rows of a DataFrame are labelled by an index, which can be accessed via the &lt;code&gt;index&lt;/code&gt; attribute:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df.index&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## RangeIndex(start=0, stop=4, step=1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By default, the index is a range of indices starting from 0, and these are immutable. However, these can be converted to anything that you like provided that they are unique:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df.index = [&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;c&amp;#39;,&amp;#39;d&amp;#39;]
df&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      Name  Age  Score
## a    John   37   99.3
## b    Paul   33   92.6
## c   Ringo   40   97.5
## d  George   35   92.6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is also possible to specify an index when you generate the DataFrame:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df = pd.DataFrame(dict, index = [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;])
df&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      Name  Age  Score
## a    John   37   99.3
## b    Paul   33   92.6
## c   Ringo   40   97.5
## d  George   35   92.6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These indexes can then be used select rows of interest. This can be done either by the index as we have done previously with lists, or by the index name. So to get the second row, we could either use the index number (2) or the index name (‘b’). To index by location, we use the &lt;code&gt;iloc&lt;/code&gt; attribute:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df.iloc[1]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Name     Paul
## Age        33
## Score    92.6
## Name: b, dtype: object&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or to index by the row index names we use te &lt;code&gt;loc&lt;/code&gt; attribute:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df.loc[&amp;#39;b&amp;#39;]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Name     Paul
## Age        33
## Score    92.6
## Name: b, dtype: object&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can of course slice multiple rows and multiple columns to select any combination of the DataFrame that we desire:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df.loc[[&amp;#39;b&amp;#39;,&amp;#39;d&amp;#39;],[&amp;#39;Name&amp;#39;,&amp;#39;Age&amp;#39;]]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      Name  Age
## b    Paul   33
## d  George   35&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;data-filtering&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;7&lt;/span&gt; Data Filtering&lt;/h1&gt;
&lt;p&gt;DataFrames can be filtered by using a conditional index to the rows or columns. So for instance, if we wanted to select only the people who scored greater than 95% in their test, we might run the following:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df[df[&amp;#39;Score&amp;#39;] &amp;gt; 95]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     Name  Age  Score
## a   John   37   99.3
## c  Ringo   40   97.5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Conditional statements can include any logical operators such as &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt;, provided that they result in a list of booleans.&lt;/p&gt;
&lt;div id=&#34;data-sorting&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;7.1&lt;/span&gt; Data Sorting&lt;/h2&gt;
&lt;p&gt;Sorting of the data can be done by using the &lt;code&gt;sort_values&lt;/code&gt; method. This is similar to the NumPy sort, but will sort the whole DataFrame using the sorted index of the column (or index) of interest. There are a number of important parameters to consider:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;code&gt;by&lt;/code&gt; – The name or index of the column (or row) to use for sorting&lt;/li&gt;
&lt;li&gt;&lt;code&gt;axis&lt;/code&gt; – Whether you want to sort over the indexes (0) or the columns (1)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ascending&lt;/code&gt; – Whether to sort in ascending (True) or descending order (False)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kind&lt;/code&gt; – The sorting algorithm to use&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So to sort the DataFrame in descending order on the &lt;code&gt;Score&lt;/code&gt; field, we would do the following:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df_srt = df.sort_values(by = [&amp;#39;Score&amp;#39;], ascending = False)
df_srt&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      Name  Age  Score
## a    John   37   99.3
## c   Ringo   40   97.5
## b    Paul   33   92.6
## d  George   35   92.6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In addition, there is another parameter, &lt;code&gt;inplace&lt;/code&gt;. If set to True, calling this method will replace the original object with its sorted output, rather than you having to explicitly assign this:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df.sort_values(by = [&amp;#39;Score&amp;#39;], ascending = False, inplace = True)
df&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      Name  Age  Score
## a    John   37   99.3
## c   Ringo   40   97.5
## b    Paul   33   92.6
## d  George   35   92.6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is also possible to use the function &lt;code&gt;sort_index()&lt;/code&gt; to sort on the index of the DataFrame rather than the values within the DataFrame itself. This can be used, for instance, to return a sorted DataFrame back to its original state. By sorting the DataFrame above, we have created DataFrame with a non-consecutive index. By sorting on the index, we will return the DataFrame to its original state before we sorted it:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df.sort_index(inplace = True)
df&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      Name  Age  Score
## a    John   37   99.3
## b    Paul   33   92.6
## c   Ringo   40   97.5
## d  George   35   92.6&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;data-cleaning&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;7.2&lt;/span&gt; Data Cleaning&lt;/h2&gt;
&lt;p&gt;One of the first steps for any data analysis is to ensure that the data set that you are starting with is clean and does not contain any missing values. Let’s create a DataFrame with some missing values using the &lt;code&gt;np.nan&lt;/code&gt; value:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;dict = {&amp;#39;Name&amp;#39;:[&amp;#39;John&amp;#39;, np.nan, &amp;#39;Ringo&amp;#39;, &amp;#39;George&amp;#39;], &amp;#39;Age&amp;#39;:[37,np.nan,40,35], &amp;#39;Score&amp;#39;:[99.3,92.6,97.5,np.nan]}
df = pd.DataFrame(dict)
df&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      Name   Age  Score
## 0    John  37.0   99.3
## 1     NaN   NaN   92.6
## 2   Ringo  40.0   97.5
## 3  George  35.0    NaN&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Missing values can be identified using the &lt;code&gt;isnull()&lt;/code&gt; method, which produces an array of True or False values depending on whether the data are missing or not:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df.isnull()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     Name    Age  Score
## 0  False  False  False
## 1   True   True  False
## 2  False  False  False
## 3  False  False   True&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since True is treated as 1, whilst False is treated as 0 in numerical calculations, we can count the number of missing values by simply summing the values in this array:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df.isnull().sum()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Name     1
## Age      1
## Score    1
## dtype: int64&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So we have 1 value missing in each column. There are different ways of dealing with missing values, and it largely depends on the context. Sometimes, we may want to simply drop the data if it is no longer useful. For instance, the second row gives us only the score but we cannot link this to the name nor the age. Similarly, we may not be able to use the data for individuals where we do not have a score. The &lt;code&gt;dropna()&lt;/code&gt; method will remove all rows that contain an NA value:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df.dropna()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     Name   Age  Score
## 0   John  37.0   99.3
## 2  Ringo  40.0   97.5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we want to instead remove all &lt;em&gt;columns&lt;/em&gt; that contain an NA value, we can use the &lt;code&gt;axis&lt;/code&gt; parameter:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df.dropna(axis = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Empty DataFrame
## Columns: []
## Index: [0, 1, 2, 3]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since every column contains a missing value, we end up with an empty DataFrame. Other times, it may make sense to replace missing values with another value. The following will replace every missing value with the value &lt;code&gt;Missing&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df.fillna(&amp;#39;Missing&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       Name      Age    Score
## 0     John       37     99.3
## 1  Missing  Missing     92.6
## 2    Ringo       40     97.5
## 3   George       35  Missing&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course, this is not a whole lot better than the missing values for the numeric data. For numeric values, we can attempt to impute a value that is suitable by using the other data in the data set. Sometimes, simply using the mean of all of the other values in the column may be suitable:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df.fillna(df.mean())&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      Name        Age      Score
## 0    John  37.000000  99.300000
## 1     NaN  37.333333  92.600000
## 2   Ringo  40.000000  97.500000
## 3  George  35.000000  96.466667&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;combining-dataframes&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;7.3&lt;/span&gt; Combining DataFrames&lt;/h2&gt;
&lt;p&gt;Very often, it is necessary to combine data from multiple sources. For instance, we may want to scrape data from multiple different websites, and then combine them into a single DataFrame for analysis. If we have two DataFrames containing the same columns, we can append the rows of one to the other using the &lt;code&gt;append()&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df1 = pd.DataFrame({&amp;#39;Name&amp;#39;:[&amp;#39;John&amp;#39;, &amp;#39;Paul&amp;#39;, &amp;#39;Ringo&amp;#39;, &amp;#39;George&amp;#39;], &amp;#39;Age&amp;#39;:[37,33,40,35], &amp;#39;Score&amp;#39;:[99.3,92.6,97.5,92.6]})
df2 = pd.DataFrame({&amp;#39;Name&amp;#39;:[&amp;#39;Yoko&amp;#39;, &amp;#39;Brian&amp;#39;], &amp;#39;Age&amp;#39;:[32,54], &amp;#39;Score&amp;#39;:[91.6,97.0]})
df1.append(df2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      Name  Age  Score
## 0    John   37   99.3
## 1    Paul   33   92.6
## 2   Ringo   40   97.5
## 3  George   35   92.6
## 0    Yoko   32   91.6
## 1   Brian   54   97.0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice here that the row indexes are appended as is, and should be regenerated to make this dataframe more usable.&lt;/p&gt;
&lt;p&gt;To add additional columns when the number of rows are identical, we use the &lt;code&gt;concat&lt;/code&gt; method:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df1 = pd.DataFrame({&amp;#39;Name&amp;#39;:[&amp;#39;John&amp;#39;, &amp;#39;Paul&amp;#39;, &amp;#39;Ringo&amp;#39;, &amp;#39;George&amp;#39;], &amp;#39;Age&amp;#39;:[37,33,40,35], &amp;#39;Score&amp;#39;:[99.3,92.6,97.5,92.6]})
df2 = pd.DataFrame({&amp;#39;Gender&amp;#39;:[&amp;#39;Male&amp;#39;, &amp;#39;Male&amp;#39;, &amp;#39;Male&amp;#39;, &amp;#39;Male&amp;#39;]})
pd.concat([df1,df2], axis = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      Name  Age  Score Gender
## 0    John   37   99.3   Male
## 1    Paul   33   92.6   Male
## 2   Ringo   40   97.5   Male
## 3  George   35   92.6   Male&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A slightly safer way to combine two DataFrames is to merge them using &lt;code&gt;join()&lt;/code&gt;, where you can combine two DataFrames that share Columns. This might happen where you have two different sets of data for the same set of samples:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df1 = pd.DataFrame({&amp;#39;Name&amp;#39;:[&amp;#39;John&amp;#39;, &amp;#39;Paul&amp;#39;, &amp;#39;Ringo&amp;#39;, &amp;#39;George&amp;#39;], &amp;#39;Age&amp;#39;:[37,33,40,35], &amp;#39;Score&amp;#39;:[99.3,92.6,97.5,92.6]})
df2 = pd.DataFrame({&amp;#39;Name&amp;#39;:[&amp;#39;John&amp;#39;, &amp;#39;Paul&amp;#39;], &amp;#39;Gender&amp;#39;:[&amp;#39;Male&amp;#39;, &amp;#39;Male&amp;#39;]})
pd.merge(df1, df2, on = &amp;#39;Name&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Name  Age  Score Gender
## 0  John   37   99.3   Male
## 1  Paul   33   92.6   Male&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By default, this uses an &lt;code&gt;inner&lt;/code&gt; join, such that outputs are only given where values for &lt;code&gt;Name&lt;/code&gt; are found for both &lt;code&gt;df1&lt;/code&gt; and &lt;code&gt;df2&lt;/code&gt;. However, if we want to create a DataFrame with all values in it, but missing values where necessary, we can use an &lt;code&gt;outer&lt;/code&gt; join:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;pd.merge(df1, df2, on = &amp;#39;Name&amp;#39;, how = &amp;#39;outer&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      Name  Age  Score Gender
## 0    John   37   99.3   Male
## 1    Paul   33   92.6   Male
## 2   Ringo   40   97.5    NaN
## 3  George   35   92.6    NaN&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;reading-and-writing-data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;7.4&lt;/span&gt; Reading and Writing Data&lt;/h2&gt;
&lt;p&gt;As well as generating DataFrames from arrays created in Python, we can directly read data from a variety of sources using Pandas. Examples include comma-separated value (CSV) files and tab-separated value (TSV) files, where rows are separated by new lines and columns are separated by a delimiter such as a comma or tab-character. In addition, Pandas can read directly from SQL databases, web sites, or Excel spreadsheets. There are some very basic example files available from &lt;a href=&#34;/files/RTutorial/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The function &lt;code&gt;read_csv&lt;/code&gt; is one of the most commonly used functions and will load in data from a CSV or TSV file. By default, it uses new lines (&lt;code&gt;\n&lt;/code&gt;) to delimit rows and commas (&lt;code&gt;,&lt;/code&gt;) to delimit columns. The &lt;code&gt;sep&lt;/code&gt; parameter can be used to set a different delimiter, for instance if the data are tab-delimited:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;pd.read_csv(&amp;quot;sample_annotation.txt&amp;quot;, sep = &amp;quot;\t&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   SampleName Treatment  Replicate CellType
## 0    sample1   Control          1     HeLa
## 1    sample2   Control          2     HeLa
## 2    sample3   Control          3     HeLa
## 3    sample4      Drug          1     HeLa
## 4    sample5      Drug          2     HeLa
## 5    sample6      Drug          3     HeLa&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are lots of additional arguments to the &lt;code&gt;read_csv()&lt;/code&gt; function; &lt;code&gt;header&lt;/code&gt; allows you to specify the row that should be used to name the columns of the data frame, &lt;code&gt;index_col&lt;/code&gt; allows you to specify the column that should be used as the row index, &lt;code&gt;sep&lt;/code&gt; gives the delimiter between column entries (e.g. &lt;code&gt;\t&lt;/code&gt; for tab-delimited files, or &lt;code&gt;,&lt;/code&gt; for comma-separated files), ‘usecols’ allows you to specify which subset of columns to load, &lt;code&gt;dtype&lt;/code&gt; allows you to specify which data types each column represent (as seen previously for structured arrays), &lt;code&gt;skiprows&lt;/code&gt; allows you to skip the given numbber of rows at the start of the file, &lt;code&gt;skipfooter&lt;/code&gt; does the same but skipping from the bottom of the file, &lt;code&gt;nrows&lt;/code&gt; gives the number of rows to read in, &lt;code&gt;na_values&lt;/code&gt; allows you to specify which values to count as being ‘NaN’. There are many more, but here is an example of using some of these different parameters:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;pd.read_csv(&amp;quot;sample_annotation.txt&amp;quot;, sep = &amp;quot;\t&amp;quot;, nrows = 4, index_col = 0)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##            Treatment  Replicate CellType
## SampleName                              
## sample1      Control          1     HeLa
## sample2      Control          2     HeLa
## sample3      Control          3     HeLa
## sample4         Drug          1     HeLa&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the unique &lt;code&gt;SampleName&lt;/code&gt; field has been used as the index, which may be more useful than simply numbering them as it is more descriptive.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;control-sequences&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;8&lt;/span&gt; Control Sequences&lt;/h1&gt;
&lt;p&gt;One of the most useful things to be able to do with computers is to repeat the same command multiple times without having to do it by hand each time. For this, control sequences can be used to give you close control over the progress of your program.&lt;/p&gt;
&lt;div id=&#34;if-else&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;8.1&lt;/span&gt; IF ELSE&lt;/h2&gt;
&lt;p&gt;The first control sequence to look at is the “if else” command, which acts as a switch to run one of a selection of possible commands given a switch that you specify. For instance, you may want to do something different depending on whether a value is odd or even:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;val = 3
if val%2 == 0:   # If it is even (exactly divisible by 2)
  print(&amp;quot;Value is even&amp;quot;)
else:             # Otherwise it must be odd
  print(&amp;quot;Value is odd&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Value is odd&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the expression in the parentheses following “if” is evaluated, and if it evaluates to True then the block of code contained within the following curly braces is evaluated. Otherwise, the block of code following the “else” statement is evaluated. You can add additional tests by using the &lt;code&gt;elif&lt;/code&gt; statement:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;my_val = 27
if my_val%2 == 0:
  print(&amp;quot;Value is divisible by 2\n&amp;quot;)
elif my_val%3 == 0:
  print(&amp;quot;Value is divisible by 3\n&amp;quot;)
else:
  print(&amp;quot;Value is not divisible by 2 or 3&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Value is divisible by 3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each switch is followed by a block of code in the same indentation level, and the conditional statements are evaluated until one evaluates to True, at which point the relevant output is produced. If none of them evaluate to True, then the default code block following &lt;code&gt;else&lt;/code&gt; is evaluated instead. If no &lt;code&gt;else&lt;/code&gt; block is present, then the default is to just do nothing. These blocks can be as complicated as you like, and you can have &lt;code&gt;elif&lt;/code&gt; statements within the blocks to create a hierarchical structure.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;for&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;8.2&lt;/span&gt; FOR&lt;/h2&gt;
&lt;p&gt;Another control structure is the &lt;code&gt;for&lt;/code&gt; loop, which will conduct the code in the block multiple times for a variety of values that you specify at the start. For instance, here is a simple countdown script:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;for i in range(10,0,-1):
  print(i)
  if i == 1:
    print(&amp;quot;Blastoff!&amp;quot;) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 10
## 9
## 8
## 7
## 6
## 5
## 4
## 3
## 2
## 1
## Blastoff!&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So the index &lt;code&gt;i&lt;/code&gt; is taken from the set of numbers (10, 9, …, 1), starting at the first value 10, and each time prints out the number followed by a newline. Then an &lt;code&gt;if&lt;/code&gt; statement checks to see if we have reached the final number, which we have not. It therefore returns to the start of the block, updates the number to the second value 9, and repeats. It does this until there are no more values to use.&lt;/p&gt;
&lt;p&gt;As a small aside, this is slightly inefficient. Evaluation of the &lt;code&gt;if&lt;/code&gt; statement is conducted every single time the loop is traversed (10 times in this example). It will only ever be True at the end of the loop, so we could always take this out of the loop and evaluate the final printout after the loop is finished and save ourselves 10 calculations. Whilst the difference here is negligible, thinking of things like this may save you time in the future:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;for i in range(10,0,-1):
  print(i)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 10
## 9
## 8
## 7
## 6
## 5
## 4
## 3
## 2
## 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;print(&amp;quot;Blastoff!&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Blastoff!&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;while&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;8.3&lt;/span&gt; WHILE&lt;/h2&gt;
&lt;p&gt;The final main control structure is the &lt;code&gt;while&lt;/code&gt; loop. This is similar to the &lt;code&gt;for&lt;/code&gt; loop, and will continue to evaluate the code chunk as long as the specified expression evaluates to True:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;i = 10
while i &amp;gt; 0:
  print(i)
  i -= 1 ## Equavalent to i = i-1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 10
## 9
## 8
## 7
## 6
## 5
## 4
## 3
## 2
## 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;print(&amp;quot;Blastoff!&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Blastoff!&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This does exactly the same as the &lt;code&gt;for&lt;/code&gt; loop above. In general, either can be used for a given purpose, but there are times when one would be more “elegant” than the other. For instance, here the for loop is better as you do not need to manually subtract 1 from the index each time.&lt;/p&gt;
&lt;p&gt;However, if you did not know how many iterations were required before finding what you are looking for (for instance searching through a number of files), a &lt;code&gt;while&lt;/code&gt; loop may be more suitable.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HOWEVER&lt;/strong&gt;: Be aware that it is possible to get caught up in an “infinite loop”. This happens if the conditional statement never evaluates to False. For instance, if we forget to decrement the index, &lt;code&gt;i&lt;/code&gt; will always be 10 and will therefore never be less than 0. This loop will therefore run forever:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;i = 10
while i &amp;gt; 0:
  print(i)
print(&amp;quot;Blastoff!&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;loop-control&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;8.4&lt;/span&gt; Loop Control&lt;/h2&gt;
&lt;p&gt;You can leave control loops early by using flow control constructs. &lt;code&gt;continue&lt;/code&gt; skips out of the current loop and moves onto the next in the sequence. In the following case, it will restart the loop when &lt;code&gt;i&lt;/code&gt; is 5 before printing:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;for i in range(1,11):
  if i == 5:
    continue
  print(i) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 1
## 2
## 3
## 4
## 6
## 7
## 8
## 9
## 10&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;print(&amp;quot;Finished loop&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Finished loop&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;break&lt;/code&gt; will leave the code chunk entirely, and in this case will move onto the final print function as soon as it is identified that &lt;code&gt;i&lt;/code&gt; is equal to 5:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;for i in range(1,11):
  if i == 5:
    break
  print(i) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 1
## 2
## 3
## 4&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;print(&amp;quot;Finished loop&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Finished loop&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;writing-functions&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;9&lt;/span&gt; Writing Functions&lt;/h1&gt;
&lt;p&gt;There are many functions available in Python, and chances are if you want to do something somebody has already written the function to do it. It is best to not re-invent the wheel if possible (or at least it is more efficient – sometimes it is good to reinvent the wheel to understand how it works), but very often you will want to create your own functions to save replicating code.&lt;/p&gt;
&lt;p&gt;A function takes in one or more variables, does something with them, and returns something (e.g. a value or a plot). For instance, calculating the mean of a number of values is simply a case of adding them together and dividing by the number of values. Let’s write a function to do this and check that it matches the &lt;code&gt;mean()&lt;/code&gt; function from NumPy:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;def my_mean (x): # Here, x is an array of numbers
  nvals = len(x)
  valsum = sum(x)
  return valsum/nvals

my_vals = [3,5,6,3,4,3,4,7]
my_mean(my_vals) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 4.375&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;np.mean(my_vals)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 4.375&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, as with the loops earlier, the function is contained within a block of code with the same indentation level. A numeric vector is given to the function, the mean is calculated, and this value is returned to the user using the &lt;code&gt;return()&lt;/code&gt; function. This value can be captured into a variable of your choosing in the same way as with any function. As we see here, the value returned by this user-defined function is identical to that from the NumPy pacakge.&lt;/p&gt;
&lt;p&gt;You can also add further arguments to the function call. If you want an argument to have a default value, you can specify this in the function declaration. This is the value that will be used if no argument value is specified. Any arguments that do not have a default value must be specified when calling the function, or an error will be thrown:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;def foo(x, arg):
  print(x, arg)
foo (&amp;quot;Hello&amp;quot;) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now let’s try and add a default value for &lt;code&gt;arg&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;def foo(x, arg = &amp;quot;World!&amp;quot;):
  print(x, arg)
foo (&amp;quot;Hello&amp;quot;) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Hello World!&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a good point to mention an idea known as “scope”. After running the following function, have a look at the value &lt;code&gt;valsum&lt;/code&gt; calculated within the function:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;def my_mean(x): # Here, x is a numeric vector 
  nvals = len(x)
  valsum = sum(x)
  return valsum/nvals
my_vals = [3,5,6,3,4,3,4,7]
my_mean(my_vals)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 4.375&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;print(valsum) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name &amp;#39;valsum&amp;#39; is not defined
## 
## Detailed traceback: 
##   File &amp;quot;&amp;lt;string&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So what went wrong? When we try to print the variable, Python is unable to find the object &lt;code&gt;valsum&lt;/code&gt;. So where is it? The “scope” of an object is the environment where it can be found. Up until now, we have been using what are known as “global variables”. That is we have created all of our objects within the “global environment”, which is the top level where Python searches for objects. These objects are available at all times.&lt;/p&gt;
&lt;p&gt;However, when we call a function, a new environment, or “scope”, is created, and all variables created within the function become “local variables” that can only be accessed from within the function itself. As soon as we leave the scope of the function, these local variables are deleted. If you think about it, this makes sense – otherwise, every time we called a function, memory would fill up with a whole load of temporary objects.&lt;/p&gt;
&lt;p&gt;So, the function itself is completely self-contained. A copy of the input variable is stored in a new local variable (called &lt;code&gt;x&lt;/code&gt; in this case), something is done to this object (possibly creating additional objects along the way), something is returned, and then all of these objects in the scope of the function are removed, and we move back into the global environment.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;statistics&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;10&lt;/span&gt; Statistics&lt;/h1&gt;
&lt;div id=&#34;basic-statistics&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;10.1&lt;/span&gt; Basic Statistics&lt;/h2&gt;
&lt;p&gt;Python is a commonly used programming language for data science, so statistical computation is incredibly important. The NumPy package provides a large number of in-built functions for caluclating a wide range of common statistics. The following example creates two vectors of 100 random values sampled from a normal distribution with mean 0 and standard deviation 1, then calculates various basic summary statistics:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;x = np.sort(np.random.normal(loc = 0, scale = 1, size = (100)))
np.min(x)   &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## -2.4936177591812254&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;np.max(x)   &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 2.4346192637266206&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;np.mean(x)  &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 0.10305460624251134&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;np.median(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 0.048237898575136356&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The minimum and maximum values are the smallest and largest values respectively. The mean is what most people would think of when you asked for the average, and is calculated by summing the values and dividing by the total number of values. The median is another way of looking at the average, and is essentially the middle value (&lt;code&gt;50^th^&lt;/code&gt; percentile). Other percentiles can be calculated, which can give you an idea of where the majority of your data lie:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;np.quantile(x, q = 0.25) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## -0.7902551896423177&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;np.quantile(x, q = 0.75) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 0.8634971745277915&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;np.quantile(x, q = np.arange(0, 1, 0.1))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## array([-2.49361776, -1.34501693, -0.9985679 , -0.46799033, -0.19239044,
##         0.0482379 ,  0.50111703,  0.78452833,  0.95597404,  1.60507094])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;stats.describe()&lt;/code&gt; function from the &lt;code&gt;stats&lt;/code&gt; &lt;code&gt;scipy&lt;/code&gt; package will calculate many of these basic statistics for you:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import scipy
from scipy import stats
scipy.stats.describe(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## DescribeResult(nobs=100, minmax=(-2.4936177591812254, 2.4346192637266206), mean=0.10305460624251134, variance=1.2117437337387318, skewness=0.01696019336609047, kurtosis=-0.6655411158316218)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The mean and variance show you the average value and the spread about this average value for these data. Skewness and kurtosis tell us how different from a standard normal distribution these data are, with skewness representing asymmmetry and kurtosis representing the presence of a significant tail in the data.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;variation&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;10.2&lt;/span&gt; Variation&lt;/h2&gt;
&lt;p&gt;Variance is the average of the squared distances of each individual value from their mean, and is a measure of how spread out the data are from the average. The standard deviation is simply the square root of this value &lt;span class=&#34;math inline&#34;&gt;\(var(x) = sd(x)^2\)&lt;/span&gt;:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;np.std(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 1.0952745301527578&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;np.var(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 1.1996262964013444&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The covariance is a measure of how much two sets of data vary together:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;y = np.sort(np.random.normal(loc = 0, scale = 1, size = (100)))
np.var(y)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 1.2383895497339992&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;np.cov(x, y)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## array([[1.21174373, 1.21899805],
##        [1.21899805, 1.25089854]])&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;correlation&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;10.3&lt;/span&gt; Correlation&lt;/h2&gt;
&lt;p&gt;The covariance is related to the correlation between two data sets, which is a number between -1 and 1 indicating the level of dependance between the two variables. A value of 1 indicates perfect correlation, so that as one value increases so does the other. A value of -1 indicates perfect anti-correlation, so that as one value increases the other decreases. A value of 0 indicates that the two values change independently of one another:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;np.cov(x, y)/(np.std(x) * np.std(y)) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## array([[0.99416657, 1.00011832],
##        [1.00011832, 1.02629085]])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This value is known as the Pearson correlation, which can be calculated using the &lt;code&gt;scipy.stats&lt;/code&gt; function &lt;code&gt;pearsonr()&lt;/code&gt;. The first value gives the Pearson correlation coefficient between the two arrays, and the second gives a p-value which gives some idea of the significance of the correlation (more on this later):&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;scipy.stats.pearsonr(x, y)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## (0.9901171336421961, 2.0126209521921334e-85)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An alternative method for calculating the correlation between two sets of values is to use the Spearman correlation, which is essentially the same as the Pearson correlation but is calculated on the &lt;em&gt;ranks&lt;/em&gt; of the data rather than the values themselves. In this way, each value increases by only one unit at a time in a monotonic fashion, meaning that the correlation score is more robust to the presence of outliers:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;scipy.stats.spearmanr(x, y)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## SpearmanrResult(correlation=0.9999999999999999, pvalue=0.0)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So these values are pretty highly dependent on one another – not surprising considering that they are both drawn randomly from the same distribution (notice that we sorted them such that the values were increasing for both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;linear-models&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;10.4&lt;/span&gt; Linear Models&lt;/h2&gt;
&lt;p&gt;We can calculate the line of best fit between the two vectors by using linear regression, which searches for the best model &lt;span class=&#34;math inline&#34;&gt;\(y = a + bx\)&lt;/span&gt; that minimises the squared distances between the line (estimated values) and the observed data points. We can implement this using the &lt;code&gt;OLS&lt;/code&gt; ordinary least squares function from package from &lt;code&gt;statsmodels&lt;/code&gt;. We will use &lt;code&gt;y&lt;/code&gt; as the response variable, and &lt;code&gt;x&lt;/code&gt; as the explanatory variable:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import statsmodels.api as sm
model = sm.OLS(y,x)
fit = model.fit()
fit.summary2()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;lt;class &amp;#39;statsmodels.iolib.summary2.Summary&amp;#39;&amp;gt;
## &amp;quot;&amp;quot;&amp;quot;
##                        Results: Ordinary least squares
## ==============================================================================
## Model:                  OLS              Adj. R-squared (uncentered): 0.980   
## Dependent Variable:     y                AIC:                         -84.9469
## Date:                   2019-11-07 14:08 BIC:                         -82.3417
## No. Observations:       100              Log-Likelihood:              43.473  
## Df Model:               1                F-statistic:                 4952.   
## Df Residuals:           99               Prob (F-statistic):          2.37e-86
## R-squared (uncentered): 0.980            Scale:                       0.024790
## ------------------------------------------------------------------------------------
##           Coef.        Std.Err.          t          P&amp;gt;|t|        [0.025       0.975]
## ------------------------------------------------------------------------------------
## x1        1.0072         0.0143       70.3704       0.0000       0.9788       1.0356
## ------------------------------------------------------------------------------
## Omnibus:                  6.488             Durbin-Watson:               0.290
## Prob(Omnibus):            0.039             Jarque-Bera (JB):            5.919
## Skew:                     -0.520            Prob(JB):                    0.052
## Kurtosis:                 3.582             Condition No.:               1    
## ==============================================================================
## 
## &amp;quot;&amp;quot;&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Explaining this output is beyond the scope of this short tutorial, but the coefficient estimates give us the values for the slope in the linear model, and tells us by how many units y increases as x increases by 1. The R-squared value is the proportion of variance in the data that is explained by the model, with a number closer to 1 indicating a better model fit.&lt;/p&gt;
&lt;p&gt;The p-value tells us how significant these estimates are, both for the model as a whole from the F-statistic, and from the individual variables from the t-statistics. In statistical terms, we are testing the null hypothesis that the coefficient is actually equal to zero (i.e. there is not an association between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;). The p-value gives the probability of detecting a coefficient at least as large as the one that we calculated in our model given that the null hypothesis is actually true. If this probability is low enough, we can safely reject the null hypothesis and say that this variable is statistically significant. Often a value of 0.05 (5%) is used as the cutoff for rejection of the null hypothesis.&lt;/p&gt;
&lt;p&gt;Hypothesis testing is a large part of statistics. The t-test is a commonly used test for comparing the means of two sets of numeric data. In simple terms we are looking to see if they are significantly different (e.g. does the expression of a particular gene change significantly following treatment with a drug). In statistical terms, we are testing to see if the change that we see in the means is greater than we would expect by chance alone.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;scipy.stats.ttest_ind(x, y) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Ttest_indResult(statistic=-0.09118866204337545, pvalue=0.9274348706347524)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are drawn from the same distribution, the test shows there is no evidence that there is a difference between the mean. Let’s try again with a different data set, drawn from a different distribution with mean 10:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;z = np.sort(np.random.normal(loc = 10, scale = 1, size = (100)))
scipy.stats.ttest_ind(x, z) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Ttest_indResult(statistic=-66.96892738302007, pvalue=5.646782976525004e-138)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This time, the p-value is much less than 0.05, so we can reject the null hypothesis and make the claim that the mean of &lt;code&gt;z&lt;/code&gt; is significantly different from that of &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;plotting-with-python&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;11&lt;/span&gt; Plotting With Python&lt;/h1&gt;
&lt;p&gt;Similarly to R, Python is able to generate publication quality figures simply and easily. One of the most common packages for plotting in Python is the &lt;a href=&#34;https://matplotlib.org&#34;&gt;&lt;code&gt;matplotlib&lt;/code&gt;&lt;/a&gt; package, in particular using the &lt;code&gt;pyplot&lt;/code&gt; module:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import matplotlib.pyplot as plt&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;pyplot&lt;/code&gt; module gives a Matlab-like interface for plotting figures in Python. The general layout is to call a plot function from &lt;code&gt;pyplot&lt;/code&gt; such as &lt;code&gt;plot()&lt;/code&gt;, &lt;code&gt;hist()&lt;/code&gt;, &lt;code&gt;scatter()&lt;/code&gt;, etc to initiate the plot, add various additional features (such as labels and legends), and finally use &lt;code&gt;show()&lt;/code&gt; to generate the image from the combined components.&lt;/p&gt;
&lt;p&gt;There are a huge number of features that can be added to any plot, including the following:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Label the x-axis and y-axis with &lt;code&gt;xlabel()&lt;/code&gt; and &lt;code&gt;ylabel()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Add a title to the plot with &lt;code&gt;title()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Add a legend with &lt;code&gt;legend()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Change the range of the x-axis and y-axis by using &lt;code&gt;xlim()&lt;/code&gt; and &lt;code&gt;ylim()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Define the position of the ticks in the x and y-axes with &lt;code&gt;xticks()&lt;/code&gt; and &lt;code&gt;yticks()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;There are also some common arguments in &lt;code&gt;pyplot&lt;/code&gt;&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;code&gt;color&lt;/code&gt; for specifying the color&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alpha&lt;/code&gt; to define the opacity of the colors (0 is entirely see through, 1 is solid)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;linestyle&lt;/code&gt; to define whether the line should be solid (&lt;code&gt;-&lt;/code&gt;), dashed (&lt;code&gt;--&lt;/code&gt;), dot-dashed (&lt;code&gt;-.&lt;/code&gt;, etc)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;linewidth&lt;/code&gt; to define the width of the line&lt;/li&gt;
&lt;li&gt;&lt;code&gt;marker&lt;/code&gt; to define the type of point to use (&lt;code&gt;.&lt;/code&gt; for points, &lt;code&gt;o&lt;/code&gt; for circles, &lt;code&gt;s&lt;/code&gt; for square, &lt;code&gt;v&lt;/code&gt; for downward triangle, &lt;code&gt;^&lt;/code&gt; for upward triangle, &lt;code&gt;$...$&lt;/code&gt; to render strings in mathtext style)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;markersize&lt;/code&gt; to define the size of the points to use&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Whilst this is not an in depth tutorial for plotting in Python, here are a selection of commonly used plots, and how to generate them. We will use two randomly generated independent normally distributed arrays as an example:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;x = np.random.normal(loc = 0, scale = 1, size = (100))
y = np.random.normal(loc = 0, scale = 1, size = (100))&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;histograms&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;11.1&lt;/span&gt; Histograms&lt;/h2&gt;
&lt;p&gt;A histogram is used to examine the distribution of 1-dimensional data, by counting up the number of values that fall into discrete bins. The size of the bins (or the number of bins) can be specified by using the &lt;code&gt;bins&lt;/code&gt; argument. The counts for each bin are returned in the form of an array for further analysis:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;h = plt.hist(x, bins = 20, range = (-3,3), color = &amp;quot;red&amp;quot;)
plt.title(&amp;quot;This is a histogram&amp;quot;)
plt.xlabel(&amp;quot;x&amp;quot;)
plt.ylabel(&amp;quot;count&amp;quot;)
plt.show()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/PythonTutorial/index_files/figure-html/histogram-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;quantile-quantile-plots&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;11.2&lt;/span&gt; Quantile-Quantile Plots&lt;/h2&gt;
&lt;p&gt;After looking at the histogram, we may think that our data follows some specific distribution (e.g. normal distribution). Quantile-quantile plots can be used to see if two data sets are drawn from the same distribution. To do this, it plots the quantiles of each data set against one another. That is, it plots the 0&lt;sup&gt;th&lt;/sup&gt; percentile of data set A (the minimum value) against the 0th percentile of data set B, the 50&lt;sup&gt;th&lt;/sup&gt; percentiles (the medians) against each other, the 100&lt;sup&gt;th&lt;/sup&gt; percentiles (the maximum values) against each other, etc. Simply, it sorts both data sets, and makes them both the same length by estimating any missing values, then plots a scatterplot of the sorted data. If the two data sets are drawn from the same distribution, this plot should follow the &lt;span class=&#34;math inline&#34;&gt;\(x = y\)&lt;/span&gt; identity line at all but the most extreme point.&lt;/p&gt;
&lt;p&gt;We can use the &lt;code&gt;api&lt;/code&gt; module from &lt;code&gt;statsmodels&lt;/code&gt; to plot a QQ plot to see if our randomly generated array was indeed drawn from a normal distribution, by comparing &lt;code&gt;x&lt;/code&gt; with a standard normal distribution (&lt;code&gt;scipy.stats.distributions.norm&lt;/code&gt;). A 45 degree line is added to show the theoretical identity between the two distributions. The closer the points lie to this line, the closer the two distributions are:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import statsmodels.api as sm
sm.qqplot(x, line = &amp;#39;45&amp;#39;, dist = scipy.stats.distributions.norm)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/PythonTutorial/index_files/figure-html/QQplot1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Indeed, these data seem to approximate a normal distribution.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;pie-chart&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;11.3&lt;/span&gt; Pie Chart&lt;/h2&gt;
&lt;p&gt;Now let’s say that we have a data set that shows the number of called peaks from a ChIPseq data set that fall into distinct genomic features (exons, introns, promoters and intergenic regions). One way to look at how the peaks fall would be to look at a pie graph, which shows proportions in a data set represented by slices of a circle:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;peaknums  = [1400,900,200,150]
peaknames = [&amp;quot;exons&amp;quot;, &amp;quot;intron&amp;quot;, &amp;quot;promoter&amp;quot;, &amp;quot;intergenic&amp;quot;]
p = plt.pie(peaknums, labels = peaknames)
plt.show()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/PythonTutorial/index_files/figure-html/pie1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;This figure shows that the majority of the peaks fall into exons.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;bar-plot&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;11.4&lt;/span&gt; Bar Plot&lt;/h2&gt;
&lt;p&gt;However, pie charts are typically discouraged by statisticians, because your eyes can often misjudge estimates of the area taken up by each feature. A better way of looking at data such as this would be in the form of a barplot:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;b = plt.bar(peaknames, peaknums)
plt.show()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/PythonTutorial/index_files/figure-html/barplot1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;line-plots&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;11.5&lt;/span&gt; Line Plots&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;pyplot&lt;/code&gt; function &lt;code&gt;plot()&lt;/code&gt; is the standard plotting method for 2-dimensional data, and is used to plot paired data &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; against one another, using markers and/or lines. Plots such as these are useful for looking at correlation between two data sets. By default, the &lt;code&gt;plot()&lt;/code&gt; function will plot a line plot:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;plt.plot(x,y)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/PythonTutorial/index_files/figure-html/lineplot1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Note that this looks very messy. This is due to the fact that the line starts with the first pair of values &lt;code&gt;($x_1$, $x_2$)&lt;/code&gt;, then plots a line to the second pair of values &lt;code&gt;($x_1$, $x_2$)&lt;/code&gt;, and so on. Since &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are completely random, there is no order from lowest to highest for either, and so we end up with this messy image. For a line plot, we need to sort the data so that the x-axis data run from left to right. Since both data sets need to remain paired, we only sort one data set, and use this ordering to rearrange both data sets using the &lt;code&gt;argsort()&lt;/code&gt; method:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;plt.plot(x[x.argsort()],y[x.argsort()])
plt.show()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/PythonTutorial/index_files/figure-html/lineplot2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We can use a number of the arguments described above to modify this plot, including adding axis labels, a title, and some markers for each of the points:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;plt.plot(x[x.argsort()],y[x.argsort()], marker = &amp;#39;o&amp;#39;, color = &amp;#39;red&amp;#39;, linestyle = &amp;#39;--&amp;#39;)
plt.title(&amp;quot;This is y vs. x&amp;quot;)
plt.xlabel(&amp;quot;This is x&amp;quot;)
plt.ylabel(&amp;quot;This is y&amp;quot;)
plt.show()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/PythonTutorial/index_files/figure-html/lineplot3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;scatterplots&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;11.6&lt;/span&gt; Scatterplots&lt;/h2&gt;
&lt;p&gt;Sometimes we may only want to look at the markers and not plot a line between them, for instance to save us worrying about ordering as we had to do above. This allows us to take a general look over the relationship between two numeric data sets. For instance, for every student in a class, we may have scores from tests taken at the start and at the end of the year, and we want to compare them against one another to see how they compare. We can use the same function, and simply set the &lt;code&gt;linestyle&lt;/code&gt; to &lt;code&gt;&#39;&#39;&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;plt.plot(x,y, color = &amp;quot;red&amp;quot;, marker = &amp;#39;o&amp;#39;, markersize = 10, linestyle = &amp;#39;&amp;#39;)
plt.title(&amp;quot;This is y vs. x&amp;quot;)
plt.xlabel(&amp;quot;This is x&amp;quot;)
plt.ylabel(&amp;quot;This is y&amp;quot;)
plt.show()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/PythonTutorial/index_files/figure-html/scatterplot1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Here we have coloured all of our points a single colour by using the &lt;code&gt;color = &amp;quot;red&amp;quot;&lt;/code&gt; argument. However, we may want to assign colours to each point separately by supplying an array of colours that is the same length as &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. This means that we can set colours based on the data themselves, e.g. to colour male and female samples differently to one another, or to color points that exceed some threshold of interest. To do this, we can use the &lt;code&gt;scatter()&lt;/code&gt; function, which can take a list of colors using the &lt;code&gt;c&lt;/code&gt; argument:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;## Create an array containing &amp;quot;black&amp;quot; for every element in x
mycols = np.repeat(&amp;quot;black&amp;quot;, len(x))

## Change the color based on the values in x and y
mycols[(x &amp;gt;  0.5) &amp;amp; (y &amp;gt;  0.5)] = &amp;quot;red&amp;quot;
mycols[(x &amp;lt; -0.5) &amp;amp; (y &amp;lt; -0.5)] = &amp;quot;blue&amp;quot;

## Plot the scatter plot
plt.scatter(x, y, color = mycols, marker = &amp;#39;o&amp;#39;)
plt.title(&amp;quot;This is y vs. x&amp;quot;)
plt.xlabel(&amp;quot;This is x&amp;quot;)
plt.ylabel(&amp;quot;This is y&amp;quot;)
plt.show()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/PythonTutorial/index_files/figure-html/scatterplot2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;boxplots&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;11.7&lt;/span&gt; Boxplots&lt;/h2&gt;
&lt;p&gt;To compare the distribution of multiple numeric data sets, we can use boxplots. A boxplot shows the overal distribution by plotting a box bounded by the first and third quartiles, with the median highlighted. This shows where the majority of the data lie. Additional values are plotted as whiskers coming out from the main box. Multiple boxes can be plotted next to one another allowing you to compare similarlities or differences between them. This can be used for instance to compare distributions of two different data sets, or to compare a numeric value in a data set after separating out multiple classes (e.g. comparing different age groups). The plot produces a &lt;code&gt;dict&lt;/code&gt; object:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;bp = plt.boxplot([x,y])
plt.show()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/PythonTutorial/index_files/figure-html/boxplot1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;There are a number of arguments that can be supplied, including &lt;code&gt;labels&lt;/code&gt; which allows you to specify the labels on the x-axis, &lt;code&gt;notch&lt;/code&gt; which will add a notch into the boxplot to represent the confident interval, &lt;code&gt;whis&lt;/code&gt; to determine the extent of the whiskers (any values not included within the whiskers are plotted as outliers), and &lt;code&gt;widths&lt;/code&gt; to change the widths of the boxes:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;bp = plt.boxplot([x,y], labels = [&amp;#39;x&amp;#39;, &amp;#39;y&amp;#39;], notch = 1, whis = 1, widths = [0.1, 1])
plt.show()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/PythonTutorial/index_files/figure-html/boxplot2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Pandas also has a &lt;code&gt;boxplot()&lt;/code&gt; function which can take the data in the form of a DataFrame, which is useful for instance if you want to compare the distribution of expression values over all genes for a number of different samples. It will do a pretty good job of pulling out only the numeric columns by default, or you can specify which columns you would like to plot:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df = pd.DataFrame({&amp;#39;Name&amp;#39;:[&amp;#39;John&amp;#39;, &amp;#39;Paul&amp;#39;, &amp;#39;Jean&amp;#39;, &amp;#39;Paula&amp;#39;], &amp;#39;Age&amp;#39;:[37,33,40,35], &amp;#39;Score&amp;#39;:[99.3,92.6,97.5,92.6], &amp;#39;Gender&amp;#39;:[&amp;#39;Male&amp;#39;, &amp;#39;Male&amp;#39;, &amp;#39;Female&amp;#39;, &amp;#39;Female&amp;#39;]})
df.boxplot(column = [&amp;#39;Age&amp;#39;, &amp;#39;Score&amp;#39;])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/PythonTutorial/index_files/figure-html/boxplot3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;seaborn-package&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;11.8&lt;/span&gt; Seaborn package&lt;/h2&gt;
&lt;p&gt;The &lt;a href=&#34;https://seaborn.pydata.org/generated/seaborn.boxplot.html&#34;&gt;Seaborn&lt;/a&gt; package is an incredibly powerful package for plotting using DataFrames, and is quite similar to the `&lt;code&gt;ggplots2&lt;/code&gt; package in R. It makes defining the components of a plot much simpler in cases when data are stored correctly in DataFrame objects. It is beyond the scope of this tutorial to go into this in too much detail, but the idea is to use the names of the variables in the DataFrame to define various elements of the plot. For instance, in the following plot, we split data on the x-axis by their Gender, and then for each subset we plot the score:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import seaborn as sb
sb.boxplot(x = &amp;#39;Gender&amp;#39;, y = &amp;#39;Score&amp;#39;, data = df)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/PythonTutorial/index_files/figure-html/unnamed-chunk-145-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Seaborn will use some defaults to make this figure look nice, such as filling in the boxes automatically, labelling the axes, etc. However, a lot of additional parameters can be set to change these. If you are interested, I recommend spending some time looking over this package to see the number of options available to you.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;subplots&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;11.9&lt;/span&gt; Subplots&lt;/h2&gt;
&lt;p&gt;By default, the graphics device will plot a single figure only. The &lt;code&gt;subplots()&lt;/code&gt; function can be used to create multiple subplots within a single plot. By default, the method will create a single figure and a single axis, but by including the number of rows and columns the axis can contain a list of multiple axes for plotting. Each element of the list can then be used to build up the plot as described above:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;fig, subplt = plt.subplots(2, 1)
subplt[0].plot(x,y)
subplt[1].plot(x,-y)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/PythonTutorial/index_files/figure-html/subplot1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;To plot them side-by side instead, this is as simple as changing the arguments to &lt;code&gt;subplots()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;fig, subplt = plt.subplots(1,2)
subplt[0].plot(x,y)
subplt[1].plot(x,-y)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/PythonTutorial/index_files/figure-html/subplot2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;For multiple rows and columns, the axis output is a 2-dimensional NumPy array so each plot can be accessed and modified using square brackets notation:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;fig, subplt = plt.subplots(2,2)
subplt[0,0].plot(x,y)
subplt[0,0].set_title(&amp;quot;Plot1&amp;quot;)
subplt[0,1].plot(x,-y)
subplt[0,1].set_title(&amp;quot;Plot2&amp;quot;)
subplt[1,0].plot(-x,y)
subplt[1,0].set_title(&amp;quot;Plot3&amp;quot;)
subplt[1,1].plot(-x,-y)
subplt[1,1].set_title(&amp;quot;Plot4&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/PythonTutorial/index_files/figure-html/subplot3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;You can also create specific objects for each of the plots directly when calling &lt;code&gt;subplots()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;fig, ((plt1,plt2), (plt3,plt4)) = plt.subplots(2,2)
plt1.plot(x,y, color = &amp;quot;red&amp;quot;)
plt1.set_title(&amp;quot;Plot1&amp;quot;)
plt2.plot(x,-y, color = &amp;quot;blue&amp;quot;)
plt2.set_title(&amp;quot;Plot2&amp;quot;)
plt3.plot(-x,y, color = &amp;quot;orange&amp;quot;)
plt3.set_title(&amp;quot;Plot3&amp;quot;)
plt4.plot(-x,-y, color = &amp;quot;green&amp;quot;)
plt4.set_title(&amp;quot;Plot4&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/PythonTutorial/index_files/figure-html/subplot4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;By default, each plot will have its axis limits calculated independently, but it is possible to use the &lt;code&gt;sharex&lt;/code&gt; and &lt;code&gt;sharey&lt;/code&gt; arguments to share the axis limits across all plots:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;fig, ((plt1,plt2), (plt3,plt4)) = plt.subplots(2,2, sharex = True, sharey = True)
plt1.plot(x,2*y, color = &amp;quot;red&amp;quot;)
plt1.set_title(&amp;quot;Plot1&amp;quot;)
plt2.plot(x,-y, color = &amp;quot;blue&amp;quot;)
plt2.set_title(&amp;quot;Plot2&amp;quot;)
plt3.plot(-3*x,2*y, color = &amp;quot;orange&amp;quot;)
plt3.set_title(&amp;quot;Plot3&amp;quot;)
plt4.plot(-x,-4*y, color = &amp;quot;green&amp;quot;)
plt4.set_title(&amp;quot;Plot4&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/PythonTutorial/index_files/figure-html/subplot5-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;saving-figures&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;11.10&lt;/span&gt; Saving Figures&lt;/h2&gt;
&lt;p&gt;By default, figures are generated in a separate window by using the &lt;code&gt;show()&lt;/code&gt; function. However, you can save the figure to an external file by using the &lt;code&gt;savefig()&lt;/code&gt; function. The output format can be defined simply by adding a suffix to the file – &lt;code&gt;.jpg&lt;/code&gt;, &lt;code&gt;.pdf&lt;/code&gt;, &lt;code&gt;.png&lt;/code&gt;, etc.:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;plt.plot(x,y)
plt.savefig(&amp;quot;test.png&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To change the size of the image, you can specify the size of the figure (in inches) before generating the plot using the &lt;code&gt;figsize&lt;/code&gt; argument in the &lt;code&gt;figure()&lt;/code&gt; method. To define the resolution of the output figure, you can set the &lt;code&gt;dpi&lt;/code&gt; argument for &lt;code&gt;savefig()&lt;/code&gt; to change the dots per inch value. Also, by default the margins for output figures can be quite large, so you can use the `bbox_inches’ argument to change this:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;plt.figure(figsize=(10,10))
plt.plot(x,y)
plt.savefig(&amp;quot;test.png&amp;quot;, bbox_inches=&amp;#39;tight&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;example-analysis&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;12&lt;/span&gt; Example Analysis&lt;/h1&gt;
&lt;div id=&#34;introduction-3&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;12.1&lt;/span&gt; Introduction&lt;/h2&gt;
&lt;p&gt;This is just a simple example analysis to give you an idea of the sort of things that we can do with Python. Suppose that we have two experiments, each looking at the effects on gene expression of using a particular drug (“Drug A” and “Drug B”). For each experiment we have two samples; one showing the gene expression when treated with the drug, and the other showing the gene expression when treated with some control agent. Obviously in a real experiment, we would have many replicates, but here we have &lt;span class=&#34;math inline&#34;&gt;\(n=1\)&lt;/span&gt;. We want to do the following:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;For each drug, we want to get the fold change for each gene&lt;/li&gt;
&lt;li&gt;For each drug, we want to identify the genes that are significantly changed when using the drug&lt;/li&gt;
&lt;li&gt;We want to compare the results for Drug A with those from Drug B to find genes that are affected similarly by both drugs&lt;/li&gt;
&lt;li&gt;We want to plot the correlation between the fold change values for the two drugs to see how similar they are&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For this, we will need four files. These files are in a tab-delimited text format. They are tables of values where each row is separated by a new line, and each column is separated by a tab character (&lt;code&gt;\t&lt;/code&gt;). These files can be created by and read into Excel for ease of use. To avoid errors when reading in files from text, it is good practice to ensure that there are no missing cells in your data. Instead try to get into the habit of using some “missing”&amp;quot; character (e.g. &lt;code&gt;NA&lt;/code&gt;).&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th&gt;File Name&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;a href=&#34;experiment1_control.txt&#34;&gt;experiment1_control.txt&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Expression levels for ctrl in expt 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;a href=&#34;experiment1_drug.txt&#34;&gt;experiment1_drug.txt&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Expression levels for drug A in expt 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;a href=&#34;experiment2_control.txt&#34;&gt;experiment2_control.txt&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Expression levels for control in expt 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;a href=&#34;experiment2_drug.txt&#34;&gt;experiment2_drug.txt&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Expression levels for drug A in expt 2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div id=&#34;load-data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;12.2&lt;/span&gt; Load Data&lt;/h2&gt;
&lt;p&gt;First let’s load in the data:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;expt1_ctrl = pd.read_csv(&amp;quot;experiment1_control.txt&amp;quot;, sep = &amp;quot;\t&amp;quot;)
expt1_drug = pd.read_csv(&amp;quot;experiment1_drug.txt&amp;quot;,    sep = &amp;quot;\t&amp;quot;)
expt2_ctrl = pd.read_csv(&amp;quot;experiment2_control.txt&amp;quot;, sep = &amp;quot;\t&amp;quot;)
expt2_drug = pd.read_csv(&amp;quot;experiment2_drug.txt&amp;quot;,    sep = &amp;quot;\t&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each of these files contains two columns; the gene name and some value that represents the expression level for that gene (assume that these values have been calculated after pre-processing, normalisation, etc.).&lt;/p&gt;
&lt;p&gt;In all of these cases, the list of gene names is identical, and in the same order which means that we could compare row 1 from the control-treated file with row 2 from the drug-treated file to get all of the comparisons. However, in a real data set you will not know for sure that the gene names match so I recommend merging the files together into a single data frame to ensure that all analyses are conducted on a gene by gene basis on the correct values.&lt;/p&gt;
&lt;p&gt;We therefore create a single DataFrame for both experiments using the &lt;code&gt;merge()&lt;/code&gt; command:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;expt1 = pd.merge(expt1_ctrl, expt1_drug, on = &amp;quot;GeneName&amp;quot;, suffixes = (&amp;quot;_Control&amp;quot;, &amp;quot;_Drug&amp;quot;))
expt2 = pd.merge(expt2_ctrl, expt2_drug, on = &amp;quot;GeneName&amp;quot;, suffixes = (&amp;quot;_Control&amp;quot;, &amp;quot;_Drug&amp;quot;))
expt1.head()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   GeneName  Expression_Control  Expression_Drug
## 0    gene1                  64               48
## 1    gene2                  50               62
## 2    gene3                  74               73
## 3    gene4                  31               34
## 4    gene5                  63               66&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;expt2.head()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   GeneName  Expression_Control  Expression_Drug
## 0    gene1                  55               60
## 1    gene2                  51               51
## 2    gene3                  77               74
## 3    gene4                  23               22
## 4    gene5                  72              101&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;calculate-fold-change&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;12.3&lt;/span&gt; Calculate Fold Change&lt;/h2&gt;
&lt;p&gt;Now we calculate the fold change for each gene by dividing the drug-treated expression by the control expression. To avoid divide by zero errors, we can set a minimum expression value. This will also ensure that we are only looking at expression changes between significant expression values. Since we want to do the same thing to both the experiment 1 and the experiment 2 data sets, it makes sense to write a single function to use for both. We will use the &lt;code&gt;apply()&lt;/code&gt; function from Pandas to calculate over every row in the DataFrame:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;def get_fold_change(x, min_expression = 10):
  ctrl_val = x[&amp;quot;Expression_Control&amp;quot;]
  drug_val = x[&amp;quot;Expression_Drug&amp;quot;]
  if ctrl_val &amp;lt; min_expression:
    ctrl_val = min_expression
  if drug_val &amp;lt; min_expression:
    drug_val = min_expression  
  return drug_val/ctrl_val
expt1[&amp;#39;FoldChange&amp;#39;] = expt1.apply(get_fold_change, axis = 1)
expt2[&amp;#39;FoldChange&amp;#39;] = expt2.apply(get_fold_change, axis = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;compare-data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;12.4&lt;/span&gt; Compare Data&lt;/h2&gt;
&lt;p&gt;Now let’s find the genes that are upregulated and downregulated in each experiment. Due to the lack of replicates, we do not have any estimate for the variance of these genes, so we cannot use any hypothesis testing methods such as a t-test. Instead, we will have to make do with using a threshold on the fold change:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;fold_change_threshold = 1.5
expt1_up   = expt1[expt1[&amp;#39;FoldChange&amp;#39;] &amp;gt;= fold_change_threshold][&amp;#39;GeneName&amp;#39;]
expt1_down = expt1[expt1[&amp;#39;FoldChange&amp;#39;] &amp;lt;= 1/fold_change_threshold][&amp;#39;GeneName&amp;#39;]
expt2_up   = expt2[expt2[&amp;#39;FoldChange&amp;#39;] &amp;gt;= fold_change_threshold][&amp;#39;GeneName&amp;#39;]
expt2_down = expt2[expt2[&amp;#39;FoldChange&amp;#39;] &amp;gt;= 1/fold_change_threshold][&amp;#39;GeneName&amp;#39;]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So let’s see which genes are changing:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;print(&amp;quot;Upregulated in Experiment 1:&amp;quot;,   expt1_up.str.cat(sep = &amp;quot;, &amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Upregulated in Experiment 1: gene8, gene12&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;print(&amp;quot;Downregulated in Experiment 1:&amp;quot;, expt1_down.str.cat(sep = &amp;quot;, &amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Downregulated in Experiment 1: gene32, gene46&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;print(&amp;quot;Upregulated in Experiment 2:&amp;quot;,   expt2_up.str.cat(sep = &amp;quot;, &amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Upregulated in Experiment 2: gene8, gene18, gene50&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;print(&amp;quot;Downregulated in Experiment 2:&amp;quot;, expt2_down.str.cat(sep = &amp;quot;, &amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Downregulated in Experiment 2: gene1, gene2, gene3, gene4, gene5, gene6, gene7, gene8, gene9, gene10, gene11, gene12, gene13, gene14, gene15, gene16, gene17, gene18, gene19, gene20, gene21, gene23, gene24, gene25, gene26, gene27, gene28, gene29, gene30, gene31, gene32, gene33, gene34, gene35, gene36, gene37, gene38, gene39, gene40, gene41, gene42, gene44, gene45, gene46, gene47, gene48, gene49, gene50&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So we now have the genes that change when each of the drugs is used. But now we want to compare the two drugs together. First, let’s see if there are any genes similarly affected by both drugs. We can do this using the &lt;code&gt;intersect1d()&lt;/code&gt; function from NumPy which gives the intersect of two arrays:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;common_up   = pd.Series(np.intersect1d(expt1_up, expt2_up))
common_down = pd.Series(np.intersect1d(expt1_down, expt2_down))
print(&amp;quot;Upregulated in Experiment 1 and Experiment 2:&amp;quot;,   common_up.str.cat(sep = &amp;quot;, &amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Upregulated in Experiment 1 and Experiment 2: gene8&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;print(&amp;quot;Downregulated in Experiment 1 and Experiment 2:&amp;quot;, common_down.str.cat(sep = &amp;quot;, &amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Downregulated in Experiment 1 and Experiment 2: gene32, gene46&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So we can see that only one gene is similarly affected by both drugs (“gene8”). Now let’s plot a figure to see how the fold change differs between the two drugs:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;fc = pd.merge(expt1[[&amp;#39;GeneName&amp;#39;, &amp;#39;FoldChange&amp;#39;]], expt2[[&amp;#39;GeneName&amp;#39;, &amp;#39;FoldChange&amp;#39;]], on = &amp;quot;GeneName&amp;quot;, suffixes = [&amp;quot;_Experiment1&amp;quot;, &amp;quot;_Experiment2&amp;quot;])
plt.scatter(np.log2(fc[&amp;quot;FoldChange_Experiment1&amp;quot;]), 
            np.log2(fc[&amp;#39;FoldChange_Experiment2&amp;#39;]),
            marker = &amp;quot;o&amp;quot;, color = &amp;quot;red&amp;quot;)
plt.xlim(-2,2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## (-2, 2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;plt.ylim(-2,2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## (-2, 2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;plt.title(&amp;quot;Experiment1 vs Experiment2&amp;quot;)
plt.xlabel(&amp;quot;log2(Experiment1 Fold Change)&amp;quot;)
plt.ylabel(&amp;quot;log2(Experiment2 Fold Change)&amp;quot;)
plt.show()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/PythonTutorial/index_files/figure-html/foldchange-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;This figure shows that the effect on the gene expression is actually quite different for the two drugs. We can also see this by looking at the correlation between the two experiments:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;scipy.stats.pearsonr(fc[&amp;quot;FoldChange_Experiment1&amp;quot;], fc[&amp;quot;FoldChange_Experiment2&amp;quot;])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## (0.0838161376824968, 0.5627922240659949)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can therefore conclude that the effect of the drug on gene expression is quite different between the two experiments.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>How To Use R</title>
      <link>/resources/rtutorial/</link>
      <pubDate>Wed, 23 Aug 2017 00:00:00 +0000</pubDate>
      <guid>/resources/rtutorial/</guid>
      <description>

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introduction&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1&lt;/span&gt; Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#installing-r&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2&lt;/span&gt; Installing R&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#basics-of-r&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3&lt;/span&gt; Basics of R&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introduction-1&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.1&lt;/span&gt; Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#data-classes&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.2&lt;/span&gt; Data Classes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#vectors&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.3&lt;/span&gt; Vectors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lists&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.4&lt;/span&gt; Lists&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#matrices&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.5&lt;/span&gt; Matrices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#functions&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.6&lt;/span&gt; Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#printing&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.7&lt;/span&gt; Printing&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#installing-packages&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4&lt;/span&gt; Installing Packages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#data-frames&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;5&lt;/span&gt; Data Frames&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#reading-and-writing-data&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;6&lt;/span&gt; Reading and Writing Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#control-sequences&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;7&lt;/span&gt; Control Sequences&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#if-else&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;7.1&lt;/span&gt; IF ELSE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#for&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;7.2&lt;/span&gt; FOR&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#while&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;7.3&lt;/span&gt; WHILE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#loop-control&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;7.4&lt;/span&gt; Loop Control&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#writing-functions-in-r&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;8&lt;/span&gt; Writing Functions in R&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#some-simple-statistics&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;9&lt;/span&gt; Some Simple Statistics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#plotting-with-r&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;10&lt;/span&gt; Plotting With R&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#scatterplots&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;10.1&lt;/span&gt; Scatterplots&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#histograms&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;10.2&lt;/span&gt; Histograms&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#quantile-quantile-plots&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;10.3&lt;/span&gt; Quantile-Quantile Plots&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#line-plots&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;10.4&lt;/span&gt; Line Plots&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#density-plots&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;10.5&lt;/span&gt; Density Plots&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#boxplots&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;10.6&lt;/span&gt; Boxplots&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bar-plots-and-pie-charts&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;10.7&lt;/span&gt; Bar Plots and Pie Charts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#graphical-control&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;10.8&lt;/span&gt; Graphical Control&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#subplots&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;10.9&lt;/span&gt; Subplots&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#saving-figures&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;10.10&lt;/span&gt; Saving Figures&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#example-analysis&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;11&lt;/span&gt; Example Analysis&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introduction-2&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;11.1&lt;/span&gt; Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#load-data&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;11.2&lt;/span&gt; Load Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#calculate-fold-change&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;11.3&lt;/span&gt; Calculate Fold Change&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#compare-data&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;11.4&lt;/span&gt; Compare Data&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id=&#34;introduction&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;1&lt;/span&gt; Introduction&lt;/h1&gt;
&lt;p&gt;This tutorial is a basic introduction to R that was originally written for biologists to get a basic understanding of how R functions. R is a software package that is a free to use open-source version of the S programming language. It is designed mainly for running statistical analyses and is very powerful in this regard. Follow through the tutorial and run the example commands by typing them into the command line as you go to see what happens. Don’t be afraid to play around with things as you go – it’s the best way to find out what certain functions do.&lt;/p&gt;
&lt;p&gt;You will notice that I have added comments to some of the code using the &lt;code&gt;#&lt;/code&gt; comment character. Everything to the right of this character is ignored by R. This can be used to add comments to your code, for instance to explain what a particular code chunk does. You can NEVER have too many comments!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;installing-r&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;2&lt;/span&gt; Installing R&lt;/h1&gt;
&lt;p&gt;First of all, you will need to download and install R. The R website can be found at &lt;a href=&#34;http://www.r-project.org&#34;&gt;r-project.org&lt;/a&gt;. R is updated quite regularly – there is an updated release roughly every 6 months, with various developmental versions released between the official versions. The functions in R are actively maintained to ensure that they run as they should, and new functionality is added all of the time.&lt;/p&gt;
&lt;p&gt;The current version is 3.3.2. To download it, go to the Comprehensive R Archive Network (&lt;a href=&#34;https://cran.r-project.org&#34;&gt;cran.r-project.org&lt;/a&gt;). There are ready-made binaries available for MAC, windows, and most Linux distributions, so follow the links and download as instructed. You can also download the source code in a tarball, and can compile and install it using &lt;code&gt;make&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It is also worth taking a look at the Integrated Development Environment &lt;a href=&#34;https://www.rstudio.com&#34;&gt;RStudio&lt;/a&gt;, which is a great open-source interface for R.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;basics-of-r&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;3&lt;/span&gt; Basics of R&lt;/h1&gt;
&lt;div id=&#34;introduction-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.1&lt;/span&gt; Introduction&lt;/h2&gt;
&lt;p&gt;Open the R environment. This is a command line version allowing you to see the results of the commands that you enter as you run them.&lt;/p&gt;
&lt;p&gt;The command line is shown by the &lt;code&gt;&amp;gt;&lt;/code&gt; character. Simply type your command here and press return to see the results. If your command is not complete, then the command line character will change to a &lt;code&gt;+&lt;/code&gt; to indicate that more input is required, for instance a missing parenthesis:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print (&amp;quot;Hello World!&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Error: &amp;lt;text&amp;gt;:2:0: unexpected end of input
## 1: print (&amp;quot;Hello World!&amp;quot;
##    ^&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;R stores “variables” using names made up of characters and numbers. A variable, as the name suggests, is a data “object” that can take any value that you want, and can be changed.&lt;/p&gt;
&lt;p&gt;The variable name can be anything that you like, although it must begin with a character. Whilst it is perfectly acceptable to use simple variable names such as &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, I recommend using a more descriptive name (e.g. &lt;code&gt;patient_height&lt;/code&gt; instead of &lt;code&gt;x&lt;/code&gt;). There are lots of different variable naming conventions to choose from (e.g. see &lt;a href=&#34;https://en.wikipedia.org/wiki/Naming_convention_(programming)&#34;&gt;here&lt;/a&gt;), but once you have chosen one try and stick to it.&lt;/p&gt;
&lt;p&gt;To assign a value to the variable, use the &lt;code&gt;&amp;lt;-&lt;/code&gt; command (less-than symbol followed by minus symbol). You can also use the &lt;code&gt;=&lt;/code&gt; symbol, but this has other uses (for instance using &lt;code&gt;==&lt;/code&gt; to test for equality) so I prefer to use the &lt;code&gt;&amp;lt;-&lt;/code&gt; command:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- 3
x # Returns the value stored in &amp;#39;x&amp;#39; - currently 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- 5
x # Returns the value stored in &amp;#39;x&amp;#39; - now 5&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Simple arithmetic can be performed using the standard arithmetic operators (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;), as well as the exponent operator (&lt;code&gt;^&lt;/code&gt;). There is a level of precedence to these functions – the exponent will be calculated first, followed by multiplication and division, followed by plus and minus. For this reason, you must be careful that your arithmetic is doing what you expect it to do. You can get around this by encapsulating subsets of the sum in parentheses, which will be calculated from the inside out:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;1+2*3 &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 7&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(1 + 2) * 3 &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;1 + (2 * 3) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 7&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Personally I think that you can NEVER have too many parentheses – they ensure that your equations are doing what they should, and they can help improve the readability of things making it easier to see what a calculation is trying to achieve.&lt;/p&gt;
&lt;p&gt;Another operator that you may not have seen before is the “modulo” operator (&lt;code&gt;%%&lt;/code&gt;), which gives you the remainder left after dividing by the number:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;6%%2 # 6 is divisible by 2 exactly three times&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;6%%4 # 6 is divisible by 4 one time with a remainder of 2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can also use other variables in these assignments:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- 1
y &amp;lt;- x
y&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;z &amp;lt;- x + y 
z&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;data-classes&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.2&lt;/span&gt; Data Classes&lt;/h2&gt;
&lt;p&gt;Variables can take many forms, or “classes”. The most common are “numeric” (which you can do numerical calculations on), character (can contain letters, numbers, symbols etc., but cannot run numerical calculations), and logical (TRUE or FALSE). The speech marks character &lt;code&gt;&amp;quot;&lt;/code&gt; is used to show that the class of y is “character”. You can also use the apostrophe &lt;code&gt;&#39;&lt;/code&gt;. There &lt;em&gt;is&lt;/em&gt; a difference between these, but for now this is not important. You can check the class of a variable by using the &lt;code&gt;class()&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- 12345
class(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;numeric&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;y &amp;lt;- &amp;quot;12345&amp;quot;
class(y)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;character&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Addition is a well-defined operation on numerical objects, but is not defined on character class objects. Attempting to use a function which has not been defined for the object in question will throw an error:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x + 1 # x is numeric, so addition is well defined&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 12346&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;y + 1 # y is a character, so addition is not defined - produces an error&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Error in y + 1: non-numeric argument to binary operator&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To see which objects are currently present in the R environment, use the &lt;code&gt;ls()&lt;/code&gt; command. To remove a particular object, use the &lt;code&gt;rm()&lt;/code&gt; command. &lt;em&gt;BE CAREFUL&lt;/em&gt; – once you have removed an object, it is gone forever!&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- 5
ls ()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;x&amp;quot; &amp;quot;y&amp;quot; &amp;quot;z&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rm(x)
ls ()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;y&amp;quot; &amp;quot;z&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rm(list=ls()) # Removes all objects in the current R session
ls ()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## character(0)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can also change the class of a variable by assigning to the &lt;code&gt;class()&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- &amp;quot;12345&amp;quot;
x+1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Error in x + 1: non-numeric argument to binary operator&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;class(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;character&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;class(x) &amp;lt;- &amp;quot;numeric&amp;quot; 
class(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;numeric&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x+1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 12346&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The other important data class is “logical”, which is simply a binary TRUE or FALSE value. There are certain operators that are used to compare two variables. The obvious ones are “is less than” (&lt;code&gt;&amp;lt;&lt;/code&gt;), “is greater than” (&lt;code&gt;&amp;gt;&lt;/code&gt;), “is equal to”&amp;quot; (&lt;code&gt;==&lt;/code&gt;). You can also combine these to see “is less than or equal to” (&lt;code&gt;&amp;lt;=&lt;/code&gt;) or “is greater than or equal to” (&lt;code&gt;&amp;gt;=&lt;/code&gt;). If the statement is true, then it will return the output “TRUE”. Otherwise it will return “FALSE”:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- 2
y &amp;lt;- 3
x &amp;lt;= y&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;gt;= y&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] FALSE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can also combine these logical tests to ask complex questions by using the “AND” (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;) or the “OR” (&lt;code&gt;||&lt;/code&gt;) operators. You can also negate the output of a logical test by using the “NOT” (&lt;code&gt;!&lt;/code&gt;) operator. This lets you test for very specific events in your data. Again, I recommend using parentheses to break up your tests to ensure that the tests occur in the order which you expect:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- 3
y &amp;lt;- 7
z &amp;lt;- 6
(x &amp;lt;= 3 &amp;amp;&amp;amp; y &amp;gt;= 8) &amp;amp;&amp;amp; z == 6  &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] FALSE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(x &amp;lt;= 3 &amp;amp;&amp;amp; y &amp;gt;= 8) || z == 6 &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One important set of functions are the log and exponential functions. The exponential function is the function &lt;span class=&#34;math inline&#34;&gt;\(e^x\)&lt;/span&gt;, such that &lt;span class=&#34;math inline&#34;&gt;\(e^x\)&lt;/span&gt; is its own derivative (&lt;span class=&#34;math inline&#34;&gt;\(\frac{d}{dx} e^x = e^x\)&lt;/span&gt;). The value e is the constant 2.718281828…, which is the limit &lt;span class=&#34;math inline&#34;&gt;\(\lim_{n \to \infty} (1+\frac{1}{n})^n\)&lt;/span&gt;. It is a very important value in mathematics (hence why it has its own constant). Logarithms are the inverse of exponents, with natural log being log base &lt;span class=&#34;math inline&#34;&gt;\(e\)&lt;/span&gt;. Here are some examples:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;log (8)     ## Natural logarithm - base e&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2.079442&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;log2 (8)    ## Log base 2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;exp (1)     ## e&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2.718282&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;exp (5)     ## e^5&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 148.4132&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;log(exp(8)) ## log and exponential cancel out - base e&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 8&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;exp(log(8)) ## log and exponential cancel out - base e&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 8&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;2^(log2(8)) ## log and exponential cancel out - base 2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 8&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;log2 (2^8)  ## log and exponential cancel out - base 2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 8&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;vectors&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.3&lt;/span&gt; Vectors&lt;/h2&gt;
&lt;p&gt;Single values are all well and good, but R has a number of ways to store multiple values in a single data structure. The simplest one of these is as a “vector” – simply a list of values of the same class. You create a vector by using the &lt;code&gt;c()&lt;/code&gt; (concatenate) function:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_vector &amp;lt;- c(1,2,3,4,5) 
my_vector&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1 2 3 4 5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a very useful way of storing linked data together. You can access the individual elements of the vector by using square brackets (&lt;code&gt;[&lt;/code&gt;) to take a subset of the data. The elements in the vector are numbered from 1 upwards, so to take the first and last values we do the following:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_vector &amp;lt;- c(10,20,30,40,50)
my_vector[1]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 10&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_vector[5]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_vector[6]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] NA&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, a value &lt;code&gt;NA&lt;/code&gt; (Not Applicable) is returned if you try to take an element that does not exist. The subset can be as long as you like, as long as it’s not longer than the full set:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_vector &amp;lt;- c(10,20,30,40,50)
my_vector[1:4]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 10 20 30 40&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the &lt;code&gt;:&lt;/code&gt; in the brackets simply means to take all of the numbers from 1 through to 4, so this returns the first 4 elements of the vector. For instance, this is a simple way to take the numbers from 1 to 20:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;1:20&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To drop elements from an array, you use the minus symbol:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_vector &amp;lt;- c(10,20,30,40,50) 
my_vector[-1] &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 20 30 40 50&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_vector[-length(my_vector)] &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 10 20 30 40&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_vector[-c(1,3,5)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 20 40&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another way to generate a regular sequence in R is to use the &lt;code&gt;seq()&lt;/code&gt; command. You supply the start number and the end number, and then either supply the parameter &lt;code&gt;by&lt;/code&gt; to define the regular interval between values, or the parameter &lt;code&gt;length&lt;/code&gt; to specify the total number of values to return between the start and end value:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;seq(from = 1, to = 20, by = 1) # Returns the same as 1:20&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;seq(from = 1, to = 20, by = 2) # Just the even numbers between 1 and 20 &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  1  3  5  7  9 11 13 15 17 19&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;seq(from = 1, to = 20, length = 10) # Slightly different to above&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  1.000000  3.111111  5.222222  7.333333  9.444444 11.555556 13.666667
##  [8] 15.777778 17.888889 20.000000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can also use the &lt;code&gt;rep()&lt;/code&gt; function to give a vector of the specified length containing repeated values:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rep(10, times = 5)      # Returns vector containing five copies of the number 10 &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 10 10 10 10 10&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rep(c(1,2,3), each = 5) # Returns five 1s, then five 2s, then five 3s&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One of the most powerful features of R is the fact that arithmetic can be conducted on entire vectors rather than having to loop through all values in the vector. Vectorisation of calculations in this way can give huge improvements in performance. For instance, if you sum two vectors (of equal size), the result will be a vector where the i&lt;sup&gt;th&lt;/sup&gt; entry is the sum of the i&lt;sup&gt;th&lt;/sup&gt; entries from the input vectors:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- c(2,3,2,4,5) 
y &amp;lt;- c(4,1,1,2,3) 
x+y&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 6 4 3 6 8&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x*y&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  8  3  2  8 15&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;lists&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.4&lt;/span&gt; Lists&lt;/h2&gt;
&lt;p&gt;Another data structure that is very useful is the “list”. A list contains a number of things in a similar way to the vector, but the things that it contains can all be completely different classes. They can even be vectors and other lists (a list of lists):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_list &amp;lt;- list(12345, &amp;quot;12345&amp;quot;, c(1,2,3,4,5)) 
my_list&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## [1] 12345
## 
## [[2]]
## [1] &amp;quot;12345&amp;quot;
## 
## [[3]]
## [1] 1 2 3 4 5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To subset a list, the syntax is slightly different and you use double square brackets:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_list &amp;lt;- list(12345, &amp;quot;12345&amp;quot;, c(1,2,3,4,5)) 
my_list[[1]]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 12345&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_list[[3]]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1 2 3 4 5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If your list contains lists or vectors, you can subset these as well by using multiple sets of square brackets:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_list &amp;lt;- list(12345, &amp;quot;12345&amp;quot;, c(1,2,3,4,5)) 
my_list[[3]][5]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Can you see the difference between subsetting using &lt;code&gt;[[&lt;/code&gt; and using &lt;code&gt;[&lt;/code&gt;?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_list &amp;lt;- list(12345, &amp;quot;12345&amp;quot;, c(1,2,3,4,5)) 
my_list[[3]]  ## Returns a vector&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1 2 3 4 5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_list[3]    ## Returns a list&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## [1] 1 2 3 4 5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_list[3][5] ## Not defined!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## NULL&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can give names to the values in a vector or in a list by using the &lt;code&gt;names()&lt;/code&gt; function to make it easier to follow what the values are:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_vector        &amp;lt;- c(1:5)
names(my_vector) &amp;lt;- c(&amp;quot;length&amp;quot;, &amp;quot;width&amp;quot;, &amp;quot;height&amp;quot;, &amp;quot;weight&amp;quot;, &amp;quot;age&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can use these names instead of the reference number to subset lists and vectors:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_vector        &amp;lt;- c(1:5)
names(my_vector) &amp;lt;- c(&amp;quot;length&amp;quot;, &amp;quot;width&amp;quot;, &amp;quot;height&amp;quot;, &amp;quot;weight&amp;quot;, &amp;quot;age&amp;quot;) 
my_vector[&amp;quot;age&amp;quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## age 
##   5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The number of values in a vector or list can be found by using the &lt;code&gt;length()&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_vector &amp;lt;- 1:5 
length(my_vector)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also sort the data simply using the &lt;code&gt;sort()&lt;/code&gt; function. If we want to get the indeces of the sorted vector (for instance to order a second vector based on the values in the first), we can use the &lt;code&gt;order()&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## Some values and their corresponding names
my_vals  &amp;lt;- c( 0.2, 1.7, 0.5, 3.4, 2.7 ) 
my_names &amp;lt;- c(&amp;quot;val1&amp;quot;, &amp;quot;val2&amp;quot;, &amp;quot;val3&amp;quot;, &amp;quot;val4&amp;quot;, &amp;quot;val5&amp;quot;)

## Sort the data
my_sorted &amp;lt;- sort(my_vals)  ## Returns the values in sorted order 
my_order  &amp;lt;- order(my_vals) ## Returns the indeces of the sorted values

## What is the difference between the two?
my_sorted &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.2 0.5 1.7 2.7 3.4&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_order&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1 3 2 5 4&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## Get the sorted value names
sort(my_names)     ## This won&amp;#39;t work as this will order names alphabetically &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;val1&amp;quot; &amp;quot;val2&amp;quot; &amp;quot;val3&amp;quot; &amp;quot;val4&amp;quot; &amp;quot;val5&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_names[my_order] ## This gives us the order based on the values themselves&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;val1&amp;quot; &amp;quot;val3&amp;quot; &amp;quot;val2&amp;quot; &amp;quot;val5&amp;quot; &amp;quot;val4&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By default the sort functions sort from lowest to highest. You can sort in decreasing by order by using the decreasing parameter:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sort(my_vals , decreasing = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3.4 2.7 1.7 0.5 0.2&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;matrices&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.5&lt;/span&gt; Matrices&lt;/h2&gt;
&lt;p&gt;Another data format is a “matrix”&amp;quot; (also known as an “array” in R). This is simply a table of values, and can be thought of as a multidimensional vector. To access specific values in the matrix, you again use the square bracket accessor function, but this time must specify both the row (first value) and column (second value):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_matrix &amp;lt;- matrix(1:20, nrow = 5, ncol = 4) 
my_matrix&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3] [,4]
## [1,]    1    6   11   16
## [2,]    2    7   12   17
## [3,]    3    8   13   18
## [4,]    4    9   14   19
## [5,]    5   10   15   20&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_matrix[3,4] &amp;lt;- 99999
my_matrix&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3]  [,4]
## [1,]    1    6   11    16
## [2,]    2    7   12    17
## [3,]    3    8   13 99999
## [4,]    4    9   14    19
## [5,]    5   10   15    20&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By default, the values are added to the matrix in a column-wise fashion (from top to bottom for column 1, then the same for column 2, etc.). To fill the matrix in a row-wise fashion, use the byrow parameter:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_matrix &amp;lt;- matrix(1:20, nrow = 5, ncol = 4, byrow = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can also use the square bracket accessor function to extract subsets of the matrix:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_matrix &amp;lt;- matrix(1:20, nrow = 5, ncol = 4) 
my_matrix&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3] [,4]
## [1,]    1    6   11   16
## [2,]    2    7   12   17
## [3,]    3    8   13   18
## [4,]    4    9   14   19
## [5,]    5   10   15   20&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sub_matrix &amp;lt;- my_matrix[1:2, 3:4]
sub_matrix&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2]
## [1,]   11   16
## [2,]   12   17&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;cbind()&lt;/code&gt; (column bind) and &lt;code&gt;rbind()&lt;/code&gt; (row bind) functions can also be used to concatenate vectors together by row or by column to give a matrix:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cbind(c(1,2,3), c(4,5,6), c(7,8,9)) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
## [3,]    3    6    9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rbind(c(1,2,3), c(4,5,6), c(7,8,9)) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3]
## [1,]    1    2    3
## [2,]    4    5    6
## [3,]    7    8    9&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can change the names of both the rows and the columns by using the &lt;code&gt;rownames()&lt;/code&gt; and &lt;code&gt;colnames()&lt;/code&gt; functions:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_matrix           &amp;lt;- matrix(1:20, nrow = 5, ncol = 4) 
rownames(my_matrix) &amp;lt;- c(&amp;quot;row1&amp;quot;, &amp;quot;row2&amp;quot;, &amp;quot;row3&amp;quot;, &amp;quot;row4&amp;quot;, &amp;quot;row5&amp;quot;) 
colnames(my_matrix) &amp;lt;- c(&amp;quot;col1&amp;quot;, &amp;quot;col2&amp;quot;, &amp;quot;col3&amp;quot;, &amp;quot;col4&amp;quot;) 
my_matrix&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      col1 col2 col3 col4
## row1    1    6   11   16
## row2    2    7   12   17
## row3    3    8   13   18
## row4    4    9   14   19
## row5    5   10   15   20&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The dimensions of the matrix can be found by using the &lt;code&gt;dim()&lt;/code&gt; function, which gives the number of rows (first value) and the number of columns (second value) of the matrix. You can access the number of rows or columns directly by using the &lt;code&gt;nrows()&lt;/code&gt; or &lt;code&gt;ncols()&lt;/code&gt; functions respectively:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_matrix &amp;lt;- matrix(1:20, nrow = 5, ncol = 4) 
dim(my_matrix)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5 4&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;nrow(my_matrix)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ncol(my_matrix)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 4&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;functions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.6&lt;/span&gt; Functions&lt;/h2&gt;
&lt;p&gt;R also uses functions (also known as methods, subroutines, and procedures) which simply take in one or more values, do something to them, and return a result. A simple example is the &lt;code&gt;sum()&lt;/code&gt; function, which takes in two or more values in the form of a vector, and returns the sum of all of the values:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_vector &amp;lt;- 1:5
sum(my_vector) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 15&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, the &lt;code&gt;sum()&lt;/code&gt; function takes only one variable (in this case a numeric vector). Sometimes functions take more than one variable (also known as “arguments”). These are named values that must be specified for the function to run. For example, the &lt;code&gt;cor()&lt;/code&gt; function returns the correlation between two vectors. This requires several variables to be supplied – two vectors, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, of equal length – and you can also supply a number of additional arguments to control how the function works, including the &lt;code&gt;method&lt;/code&gt; argument, which lets you specify which method to use to calculate the correlation:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sample1 &amp;lt;- c(0.9, 1.2, 8.9, -0.3, 6.4)
sample2 &amp;lt;- c(0.6, 1.3, 9.0, -0.5, 6.2)
cor(sample1, sample2 , method = &amp;quot;pearson&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9991263&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cor(sample1, sample2 , method = &amp;quot;spearman&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that we gave a name to the third argument (“method”), but not the first two. If you do not name arguments, they will be taken and assigned to the arguments in the order in which they are input. The first two arguments required by the function are &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; – the two vectors to compare. So there is no problem with not naming these (although you could, if you wanted to, say &lt;code&gt;x=sample1, y=sample2&lt;/code&gt;). Any arguments not submitted will use their default value. For instance, the Pearson correlation is the default for &lt;code&gt;method&lt;/code&gt;, so you could get this by simply typing:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pearson_cor &amp;lt;- cor(sample1 , sample2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, there is another argument for &lt;code&gt;cor()&lt;/code&gt;, &lt;code&gt;use&lt;/code&gt;, for which we are happy to use the default value before we get to &lt;code&gt;method&lt;/code&gt;. We therefore need to name &lt;code&gt;method&lt;/code&gt; to make sure that “pearson”&amp;quot; is not assigned to the &lt;code&gt;use&lt;/code&gt; argument in the function. It is always safer to name the arguments if you are unsure of the order. You can check the arguments using the &lt;code&gt;args()&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;args(cor)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## function (x, y = NULL, use = &amp;quot;everything&amp;quot;, method = c(&amp;quot;pearson&amp;quot;, 
##     &amp;quot;kendall&amp;quot;, &amp;quot;spearman&amp;quot;)) 
## NULL&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you want to find out what a function does, there is a lot of very helpful documentation available in R. To see the documentation for a specific function, use the &lt;code&gt;help()&lt;/code&gt; function. If you want to try and find a function, you can search using a keyword by using the &lt;code&gt;help.search()&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;help(cor)
?cor # Alternative for help() 
help.search(&amp;quot;correlation&amp;quot;)
??correlation # Alternative for help.search()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;printing&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.7&lt;/span&gt; Printing&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;print()&lt;/code&gt; can be used to print whatever is stored in the variable the function is called on. Print is what is known as an “overloaded”&amp;quot; function, which means that there are many functions named &lt;code&gt;print()&lt;/code&gt;, each written to deal with a variable of a different class. The correct one is used based on the variable that you supply. So calling &lt;code&gt;print()&lt;/code&gt; on a numeric variable will print the value stored in the variable. Calling it on a vector prints all of the values stored in the vector. Calling it on a list will print the contents of the list split into an easily identifiable way. There are also many more classes in R for which print is defined, but there are too many to describe here:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- 1
print (x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;y &amp;lt;- 1:5
print (y)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1 2 3 4 5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;z &amp;lt;- list(val1 = 1:5, val2 = 6:10)
print (z)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $val1
## [1] 1 2 3 4 5
## 
## $val2
## [1]  6  7  8  9 10&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you notice, using &lt;code&gt;print()&lt;/code&gt; is the default when you just call the variable itself:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;z &amp;lt;- list(val1 = 1:5, val2 = 6:10) 
print (z)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $val1
## [1] 1 2 3 4 5
## 
## $val2
## [1]  6  7  8  9 10&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;z&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $val1
## [1] 1 2 3 4 5
## 
## $val2
## [1]  6  7  8  9 10&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;cat()&lt;/code&gt; is similar to print in that the results of calling it are that text is printed to the console. The main use for &lt;code&gt;cat()&lt;/code&gt; is to con&lt;strong&gt;CAT&lt;/strong&gt;enate two or more variables together and instantly print them to the console. The additional argument &lt;code&gt;sep&lt;/code&gt; specifies the character to use to separate the different variables:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cat(&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;, sep = &amp;quot; &amp;quot;) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## hello world&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- 1:5
y &amp;lt;- &amp;quot;bottles of beer&amp;quot;
cat(x, y, sep = &amp;quot;\t&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 1    2   3   4   5   bottles of beer&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;\t&lt;/code&gt; is a special printing character that you can use with the &lt;code&gt;cat()&lt;/code&gt; function that prints a tab character. Another similar special character that you may need to use is &lt;code&gt;\n&lt;/code&gt; which prints a new line.&lt;/p&gt;
&lt;p&gt;Another similar function is the &lt;code&gt;paste()&lt;/code&gt; function, which also concatenates multiple values together. The differences between this and &lt;code&gt;cat()&lt;/code&gt; are that the results of &lt;code&gt;paste()&lt;/code&gt; can be saved to a different variable which requires a call to &lt;code&gt;print()&lt;/code&gt; to see the results, and &lt;code&gt;paste()&lt;/code&gt; can be used to concatenate individual elements of a vector by using the additional &lt;code&gt;collapse&lt;/code&gt; argument:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print(paste(&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;, sep = &amp;quot;\t&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;hello\tworld&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print(paste(&amp;quot;sample&amp;quot;, 1:5, sep=&amp;quot;_&amp;quot;)) # Returns a vector of values&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;sample_1&amp;quot; &amp;quot;sample_2&amp;quot; &amp;quot;sample_3&amp;quot; &amp;quot;sample_4&amp;quot; &amp;quot;sample_5&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print(paste(&amp;quot;sample&amp;quot;, 1:5, sep=&amp;quot;_&amp;quot;, collapse=&amp;quot;\n&amp;quot;)) # Prints values separated by new lines&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;sample_1\nsample_2\nsample_3\nsample_4\nsample_5&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Do you notice the difference between &lt;code&gt;print()&lt;/code&gt; and &lt;code&gt;cat()&lt;/code&gt;? While &lt;code&gt;print()&lt;/code&gt; prints the &lt;code&gt;\t&lt;/code&gt; character as is, &lt;code&gt;cat()&lt;/code&gt; prints the actual tab space. This is a process known as “interpolation”. In many programming languages, using double quotes in strings results in special characters being interpolated, whilst single quotes will print as is. However, in R the two can be used relatively interchangeably.&lt;/p&gt;
&lt;p&gt;There are also other characters, such as &lt;code&gt;&#39;&lt;/code&gt;, &lt;code&gt;&amp;quot;&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;\&lt;/code&gt;, which may require “escaping” with a backslash to avoid R interpreting the character in a different context. For instance, if you have a string containing an apostrophe within a string defined using apostrophes, the string will be interpreted as terminating earlier, and the code will not do what you expect:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cat(&amp;#39;It&amp;#39;s very annoying when this happens...&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Error: &amp;lt;text&amp;gt;:1:9: unexpected symbol
## 1: cat(&amp;#39;It&amp;#39;s
##             ^&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the string submitted to &lt;code&gt;cat()&lt;/code&gt; is actual “It” rather than the intended “It’s very annoying when this happens…”. The function will not know what to do about the remainder of the string, so an error will occur. However, by escaping the apostrophe, the string will be interpreted correctly:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cat(&amp;#39;It\&amp;#39;s easily fixed though!&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## It&amp;#39;s easily fixed though!&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another alternative is to use double apostrophes as the delimiter, which will avoid the single apostrophe being misinterpreted:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cat(&amp;quot;It&amp;#39;s easily fixed though!&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## It&amp;#39;s easily fixed though!&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One function that gives you slightly more control over the formatting of your data is the &lt;code&gt;sprintf()&lt;/code&gt; function. This function allows you to specify things like the width in which to print each variable, which is useful for arranging output in a table format (note that you need to use &lt;code&gt;cat()&lt;/code&gt; to actual print to the screen):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cat(sprintf(&amp;quot;%10s\t%5s\n&amp;quot;, &amp;quot;Hello&amp;quot;, &amp;quot;World&amp;quot;), 
    sprintf(&amp;quot;%10s\t%5s\n&amp;quot;, &amp;quot;Helloooooo&amp;quot;, &amp;quot;World&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      Hello   World
##  Helloooooo  World&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;sprintf()&lt;/code&gt; function takes as input a string telling R how you want your inputs to be formatted, followed by a list of the inputs. Within the formatting string, placeholders of the form &lt;code&gt;%10s&lt;/code&gt; are replaced by the given inputs, with the first being replaced by the first argument in the list, and so on (so the number of additional arguments to &lt;code&gt;sprintf&lt;/code&gt; must match the number of placeholders). The number in the placeholder defines the width to allocate for printing that argument (positive is right aligned, negative is left aligned), decimal numbers in the placeholder define precision of floating point numbers, and the letter defines the type of argument to print (e.g. &lt;code&gt;s&lt;/code&gt; for string, &lt;code&gt;i&lt;/code&gt; for integer, &lt;code&gt;f&lt;/code&gt; for fixed point decimal, &lt;code&gt;e&lt;/code&gt; for exponential decimal). Note that special characters are interpolated by &lt;code&gt;cat()&lt;/code&gt; as before. Here are some examples:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cat(sprintf(&amp;quot;%20s\n&amp;quot;, &amp;quot;Hello&amp;quot;)) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                Hello&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cat(sprintf(&amp;quot;%-20s\n&amp;quot;, &amp;quot;Hello&amp;quot;)) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Hello&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cat(sprintf(&amp;quot;%10i\n&amp;quot;, 12345)) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      12345&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cat(sprintf(&amp;quot;%10f\n&amp;quot;, 12.345)) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  12.345000&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cat(sprintf(&amp;quot;%10e\n&amp;quot;, 12.345)) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 1.234500e+01&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;installing-packages&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;4&lt;/span&gt; Installing Packages&lt;/h1&gt;
&lt;p&gt;The main R package contains a large number of commonly used functions. There are also additional functions available in other “packages” that you can get hold of from the Comprehensive R Archive Network, or &lt;a href=&#34;https://cran.r-project.org&#34;&gt;CRAN&lt;/a&gt;. To load in a package, first download and install the package from CRAN using the &lt;code&gt;install.packages()&lt;/code&gt; function (if it is not already downloaded), and then use the “library” command to make the libraries available to your current R session:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;?xtable &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## No documentation for &amp;#39;xtable&amp;#39; in specified packages and libraries:
## you could try &amp;#39;??xtable&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;install.packages(&amp;quot;xtable&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Error in contrib.url(repos, &amp;quot;source&amp;quot;): trying to use CRAN without setting a mirror&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(&amp;quot;xtable&amp;quot;) 
?xtable&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The function &lt;code&gt;xtable()&lt;/code&gt; is not available in the R environment until you have loaded the package. Only the most commonly used functions are made available in the R environment by default (for example the package “stats” is loaded by default, which contains all commonly used statistical fuctions). There are also a number of commonly used packages that are part of the R installation, but which are not automatically loaded when you start a new R session. There are also thousands of additional packages available, some written by users, which can perform most of the things that you would ever want to do. Chances are, if you want to do something it’s already available from somewhere. Don’t re-invent the wheel if you can help it.&lt;/p&gt;
&lt;p&gt;Since R is so useful for analysing biological data, the &lt;code&gt;bioconductor&lt;/code&gt; project was set up to bring together packages used for the analysis of high-throughput data (it started with microarrays, but now there are packages available for analysis of sequencing data). Bioconductor packages can be downloaded from &lt;a href=&#34;http://www.bioconductor.org&#34;&gt;bioconductor.org&lt;/a&gt;. However, there is also a simple way to install bioconductor packages directly from within R:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;source(&amp;quot;http://bioconductor.org/biocLite.R&amp;quot;) # Load the biocLite() script 
biocLite() # Installs the basic packages required to use bioconductor 
biocLite(&amp;quot;DESeq&amp;quot;) # Installs a specific bioconductor package&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;data-frames&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;5&lt;/span&gt; Data Frames&lt;/h1&gt;
&lt;p&gt;Data frames are the most powerful data types in R. They look similar to matrices, but the data structure is actually more similar to a list of vectors (all of the same length). The simplest way to think of them is as being similar to spreadsheets in Excel.&lt;/p&gt;
&lt;p&gt;You can create data frames either in a similar way to how you create a list, or also by converting a matrix object:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data.frame(val1 = c(1:3), val2 = c(4:6), val3 = c(7:9), val4 = c(10:12)) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   val1 val2 val3 val4
## 1    1    4    7   10
## 2    2    5    8   11
## 3    3    6    9   12&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;as.data.frame(matrix(1:12, nrow = 3, ncol = 4))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   V1 V2 V3 V4
## 1  1  4  7 10
## 2  2  5  8 11
## 3  3  6  9 12&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice how, in the second data frame, no column names are specified so R sets the defaults as &lt;code&gt;V1&lt;/code&gt;, &lt;code&gt;V2&lt;/code&gt;, &lt;code&gt;V3&lt;/code&gt;, etc. Whilst data frames do have row names, it is the column names that are the most important. As with lists, these can be changed by using the &lt;code&gt;names()&lt;/code&gt; command:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_df        &amp;lt;- as.data.frame(matrix(1:12, nrow = 3, ncol = 4)) 
names(my_df) &amp;lt;- c(&amp;quot;val1&amp;quot;, &amp;quot;val2&amp;quot;, &amp;quot;val3&amp;quot;, &amp;quot;val4&amp;quot;)
my_df&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   val1 val2 val3 val4
## 1    1    4    7   10
## 2    2    5    8   11
## 3    3    6    9   12&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You access the elements of a data frame either using single square bracket notation in the same way as for a matrix, or you can access the individual columns using double square bracket notation in the same way as for lists. You can also access the individual columns by using the special &lt;code&gt;$&lt;/code&gt; operator which is specifically used for data frames:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_df &amp;lt;- as.data.frame(matrix(1:12, nrow = 3, ncol = 4)) 
names(my_df) &amp;lt;- c(&amp;quot;val1&amp;quot;, &amp;quot;val2&amp;quot;, &amp;quot;val3&amp;quot;, &amp;quot;val4&amp;quot;)
my_df&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   val1 val2 val3 val4
## 1    1    4    7   10
## 2    2    5    8   11
## 3    3    6    9   12&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sub_df &amp;lt;- my_df[1:2, 3:4]
sub_df&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   val3 val4
## 1    7   10
## 2    8   11&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;val1 &amp;lt;- my_df[[1]]
val1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1 2 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;val2 &amp;lt;- my_df[[&amp;quot;val2&amp;quot;]] 
val2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 4 5 6&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;val3 &amp;lt;- my_df$val3
val3&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 7 8 9&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The beauty of data frames is that the data frame columns can be dealt with as if they were individual variables. For this reason, the column names must be suitable variable names (i.e. alphanumeric and not starting with a number) and must be unique. If you attach a data frame, you can access the columns as if they were variables:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_df &amp;lt;- data.frame(val1 = c(1:3), val2 = c(4:6), val3 = c(7:9), val4 = c(10:12))
attach(my_df)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following objects are masked _by_ .GlobalEnv:
## 
##     val1, val2, val3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_df&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   val1 val2 val3 val4
## 1    1    4    7   10
## 2    2    5    8   11
## 3    3    6    9   12&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;val1 + 1000 &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1001 1002 1003&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;detach(my_df)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As a slight aside, I dislike using the attach/detach approach to accessing elements of a data frame, as it can make it difficult when reading through your code to tell which variable is being accessed. For instance, if you have a variable named &lt;code&gt;myname&lt;/code&gt;, and a data frame with a column &lt;code&gt;myname&lt;/code&gt;, then using &lt;code&gt;df$myname&lt;/code&gt; in your code makes it much clearer where you are accessing your data from than simply using &lt;code&gt;myname&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Notice that to make changes to the data frame itself, we need to use the &lt;code&gt;$&lt;/code&gt; accessor function (or double square brackets), otherwise a new variable &lt;code&gt;val1&lt;/code&gt; will be created. Data frames should be set up in such a way that every row represents an independent observation, and the columns represent the independent variables that you may be interested in. For instance, if you have taken a measurement of say the weight of each sample in triplicate, you would not represent the data like this:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th&gt;SampleName&lt;/th&gt;
&lt;th&gt;Weight1&lt;/th&gt;
&lt;th&gt;Weight2&lt;/th&gt;
&lt;th&gt;Weight3&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Sample1&lt;/td&gt;
&lt;td&gt;67.1&lt;/td&gt;
&lt;td&gt;67.3&lt;/td&gt;
&lt;td&gt;66.8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;Sample2&lt;/td&gt;
&lt;td&gt;80.3&lt;/td&gt;
&lt;td&gt;79.8&lt;/td&gt;
&lt;td&gt;79.5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;But instead you would ensure that the two independent variables (weight and replicate number) were in their own columns:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th&gt;SampleName&lt;/th&gt;
&lt;th&gt;Replicate&lt;/th&gt;
&lt;th&gt;Weight&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Sample1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;67.1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;Sample1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;67.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Sample1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;66.8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;Sample2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;80.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Sample2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;79.8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;Sample2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;79.5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Now all of the weights are in a single column that can be analysed.&lt;/p&gt;
&lt;p&gt;Subsetting a data frame is also very powerful. The subset command allows you to look for the rows of a data frame that fit certain criteria. For instance, to pull out the genes that show more than 2-fold expression and a p-value less than 0.05, you would do the following:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gene_exp &amp;lt;- data.frame(geneName   = paste(&amp;quot;gene&amp;quot;, 1:10, sep = &amp;quot;&amp;quot;), 
                       foldChange = rnorm(10, mean = 2, sd = 1),
                       pVal       = rnorm(10, mean = 0.05, sd = 0.05)) 
signif_genes &amp;lt;- subset(gene_exp, foldChange &amp;gt; 2 &amp;amp; pVal &amp;lt;= 0.05)
signif_genes&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   geneName foldChange        pVal
## 9    gene9   3.298834 -0.02361531&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice here that we use a single &lt;code&gt;&amp;amp;&lt;/code&gt; rather than the double &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; that we used earlier. This is because we are doing a vector-based logical test (that is performing the test on each element of the vector to get a vector of logical values at the end). It is very easy to forget this and accidentally use the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, which will not give you what you want:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fake_signif_genes &amp;lt;- subset(gene_exp, foldChange &amp;gt; 2 &amp;amp;&amp;amp; pVal &amp;lt;= 0.05) 
fake_signif_genes&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] geneName   foldChange pVal      
## &amp;lt;0 rows&amp;gt; (or 0-length row.names)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another form of data that comes in very handy, particularly with data frames, is the “factor”. Factors are a way of dealing with categorical data, and simply encode the possible levels with numberic dummy values 0, 1, 2, etc. (which are used in modelling procedures such as ANOVA):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_vector &amp;lt;- c(&amp;quot;apples&amp;quot;, &amp;quot;pears&amp;quot;, &amp;quot;apples&amp;quot;, &amp;quot;oranges&amp;quot;, &amp;quot;pears&amp;quot;) 
my_vector&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;apples&amp;quot;  &amp;quot;pears&amp;quot;   &amp;quot;apples&amp;quot;  &amp;quot;oranges&amp;quot; &amp;quot;pears&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_factor &amp;lt;- as.factor(my_vector)
my_factor&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] apples  pears   apples  oranges pears  
## Levels: apples oranges pears&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;levels(my_factor)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;apples&amp;quot;  &amp;quot;oranges&amp;quot; &amp;quot;pears&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since data frames can hold data of different classes within its columns (a data frame is essentially a glorified list), it is very important to ensure that each column is assigned the correct class so that R functions that you use later do the correct thing with the data. For instance, R will automatically convert character entries to factors with all possible values as the factor levels. You can quickly see the class of all of your columns by using the &lt;code&gt;str()&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str(gene_exp)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;data.frame&amp;#39;:    10 obs. of  3 variables:
##  $ geneName  : Factor w/ 10 levels &amp;quot;gene1&amp;quot;,&amp;quot;gene10&amp;quot;,..: 1 3 4 5 6 7 8 9 10 2
##  $ foldChange: num  0.354 0.958 1.997 3.926 0.59 ...
##  $ pVal      : num  0.0456 -0.033 0.0172 0.1055 0.1327 ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Whilst factors are incredibly useful in modelling and plotting, they may not necessarily be exactly what you want. For instance, in this case the column &lt;code&gt;geneName&lt;/code&gt; has been converted into a factor, with levels &lt;code&gt;gene1&lt;/code&gt;, …, &lt;code&gt;gene10&lt;/code&gt;. If we try and add in a new gene, &lt;code&gt;gene11&lt;/code&gt;, this will not work as all entries of a factor must be one of the specified levels:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gene_exp_plus &amp;lt;- rbind(gene_exp, c(&amp;quot;gene11&amp;quot;, 1.789, 0.0034))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in `[&amp;lt;-.factor`(`*tmp*`, ri, value = &amp;quot;gene11&amp;quot;): invalid factor
## level, NA generated&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gene_exp_plus&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    geneName        foldChange                pVal
## 1     gene1 0.353952056887015  0.0456470018072924
## 2     gene2  0.95842475705983 -0.0329559670884031
## 3     gene3  1.99710708237021  0.0171717501160332
## 4     gene4  3.92632347531744   0.105501633069267
## 5     gene5 0.590158412290393   0.132696142295379
## 6     gene6  2.83069671142655   0.118224527859846
## 7     gene7 0.384428169315616  0.0313479445279774
## 8     gene8  1.90574885168176  0.0517571935686495
## 9     gene9  3.29883359578337 -0.0236153133950252
## 10   gene10   2.3433798728959   0.060028078125305
## 11     &amp;lt;NA&amp;gt;             1.789              0.0034&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Instead we would be better off treating &lt;code&gt;geneName&lt;/code&gt; as a character vector, since we are unlikely to treat it as a categorical variable in later model fitting analyses.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;reading-and-writing-data&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;6&lt;/span&gt; Reading and Writing Data&lt;/h1&gt;
&lt;p&gt;Reading and writing data in R is quite simple, and is most easily done by using pure text files. Functions exist for reading other formats as well (e.g. Excel tables), but for now we will concentrate on raw text. There are some very basic example files available from &lt;a href=&#34;/files/RTutorial/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Unless you give the complete path for a file, R will look in it’s current working directory for any files that you want to load in. By default, R will use your system’s home directory, but you can set this by using the setwd() function. You can check that the correct working directory is set by using the getwd() function:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;setwd(&amp;quot;/path/to/mydir/&amp;quot;) 
getwd ()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you have a list of data in a file (e.g. a list of gene names separated by new lines), then the simplest method to use is &lt;code&gt;scan()&lt;/code&gt;. You must tell &lt;code&gt;scan()&lt;/code&gt; where to find the data file (either the full path, or a relative path from the current working directory), as well as the format that the data should be read in as (generally either “character” or “numeric”):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_file &amp;lt;- &amp;quot;gene_list.txt&amp;quot;
gene_list &amp;lt;- scan(my_file, what = &amp;quot;character&amp;quot;, sep = &amp;quot;\n&amp;quot;) 
gene_list&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;gene1&amp;quot;  &amp;quot;gene2&amp;quot;  &amp;quot;gene3&amp;quot;  &amp;quot;gene4&amp;quot;  &amp;quot;gene5&amp;quot;  &amp;quot;gene6&amp;quot;  &amp;quot;gene7&amp;quot; 
##  [8] &amp;quot;gene8&amp;quot;  &amp;quot;gene9&amp;quot;  &amp;quot;gene10&amp;quot; &amp;quot;gene11&amp;quot; &amp;quot;gene12&amp;quot; &amp;quot;gene13&amp;quot; &amp;quot;gene14&amp;quot;
## [15] &amp;quot;gene15&amp;quot; &amp;quot;gene16&amp;quot; &amp;quot;gene17&amp;quot; &amp;quot;gene18&amp;quot; &amp;quot;gene19&amp;quot; &amp;quot;gene20&amp;quot; &amp;quot;gene21&amp;quot;
## [22] &amp;quot;gene22&amp;quot; &amp;quot;gene23&amp;quot; &amp;quot;gene24&amp;quot; &amp;quot;gene25&amp;quot; &amp;quot;gene26&amp;quot; &amp;quot;gene27&amp;quot; &amp;quot;gene28&amp;quot;
## [29] &amp;quot;gene29&amp;quot; &amp;quot;gene30&amp;quot; &amp;quot;gene31&amp;quot; &amp;quot;gene32&amp;quot; &amp;quot;gene33&amp;quot; &amp;quot;gene34&amp;quot; &amp;quot;gene35&amp;quot;
## [36] &amp;quot;gene36&amp;quot; &amp;quot;gene37&amp;quot; &amp;quot;gene38&amp;quot; &amp;quot;gene39&amp;quot; &amp;quot;gene40&amp;quot; &amp;quot;gene41&amp;quot; &amp;quot;gene42&amp;quot;
## [43] &amp;quot;gene43&amp;quot; &amp;quot;gene44&amp;quot; &amp;quot;gene45&amp;quot; &amp;quot;gene46&amp;quot; &amp;quot;gene47&amp;quot; &amp;quot;gene48&amp;quot; &amp;quot;gene49&amp;quot;
## [50] &amp;quot;gene50&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For tables (for instance tab-delimited files saved from Excel), the easiest way is to use the &lt;code&gt;read.table()&lt;/code&gt; function. This works by using &lt;code&gt;scan()&lt;/code&gt; to read in each line from the table, then splitting the line by the specified delimiter. It is easier (or at least you are less prone to mistakes) to read such files when there are no empty cells, so try to fill empty data with a missing data character, such as &lt;code&gt;NA&lt;/code&gt; (the default):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str(read.table(&amp;quot;sample_annotation.txt&amp;quot;, header = TRUE, sep = &amp;quot;\t&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;data.frame&amp;#39;:    6 obs. of  4 variables:
##  $ SampleName: Factor w/ 6 levels &amp;quot;sample1&amp;quot;,&amp;quot;sample2&amp;quot;,..: 1 2 3 4 5 6
##  $ Treatment : Factor w/ 2 levels &amp;quot;Control&amp;quot;,&amp;quot;Drug&amp;quot;: 1 1 1 2 2 2
##  $ Replicate : int  1 2 3 1 2 3
##  $ CellType  : Factor w/ 1 level &amp;quot;HeLa&amp;quot;: 1 1 1 1 1 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are lots of additional arguments to the &lt;code&gt;read.table()&lt;/code&gt; function; &lt;code&gt;header&lt;/code&gt; is a boolean value that says whether or not the first row should be used to name the columns of the data frame, &lt;code&gt;sep&lt;/code&gt; gives the delimiter between column entries (e.g. &lt;code&gt;\t&lt;/code&gt; for tab-delimited files, or &lt;code&gt;,&lt;/code&gt; for comma-separated files), &lt;code&gt;skip&lt;/code&gt; tells R to skip the first &lt;code&gt;n&lt;/code&gt; rows of the input, and &lt;code&gt;nrow&lt;/code&gt; tells R to only load the first &lt;code&gt;n&lt;/code&gt; rows that it sees:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str(read.table(&amp;quot;sample_annotation.txt&amp;quot;, header = TRUE, sep = &amp;quot;\t&amp;quot;, nrow = 2))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;data.frame&amp;#39;:    2 obs. of  4 variables:
##  $ SampleName: Factor w/ 2 levels &amp;quot;sample1&amp;quot;,&amp;quot;sample2&amp;quot;: 1 2
##  $ Treatment : Factor w/ 1 level &amp;quot;Control&amp;quot;: 1 1
##  $ Replicate : int  1 2
##  $ CellType  : Factor w/ 1 level &amp;quot;HeLa&amp;quot;: 1 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str(read.table(&amp;quot;sample_annotation.txt&amp;quot;, header = FALSE, sep = &amp;quot;\t&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;data.frame&amp;#39;:    7 obs. of  4 variables:
##  $ V1: Factor w/ 7 levels &amp;quot;sample1&amp;quot;,&amp;quot;sample2&amp;quot;,..: 7 1 2 3 4 5 6
##  $ V2: Factor w/ 3 levels &amp;quot;Control&amp;quot;,&amp;quot;Drug&amp;quot;,..: 3 1 1 1 2 2 2
##  $ V3: Factor w/ 4 levels &amp;quot;1&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;Replicate&amp;quot;: 4 1 2 3 1 2 3
##  $ V4: Factor w/ 2 levels &amp;quot;CellType&amp;quot;,&amp;quot;HeLa&amp;quot;: 1 2 2 2 2 2 2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that when the header is not used, the numeric column &lt;code&gt;Replicate&lt;/code&gt; is now interpreted in the same way as the character columns, because now the first entry is non-numeric. By default, &lt;code&gt;read.table()&lt;/code&gt; converts character columns into factors, which can be avoided by setting the &lt;code&gt;stringsAsFactors&lt;/code&gt; argument to &lt;code&gt;FALSE&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str(read.table(&amp;quot;sample_annotation.txt&amp;quot;, header = TRUE, sep = &amp;quot;\t&amp;quot;, stringsAsFactors = FALSE))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;data.frame&amp;#39;:    6 obs. of  4 variables:
##  $ SampleName: chr  &amp;quot;sample1&amp;quot; &amp;quot;sample2&amp;quot; &amp;quot;sample3&amp;quot; &amp;quot;sample4&amp;quot; ...
##  $ Treatment : chr  &amp;quot;Control&amp;quot; &amp;quot;Control&amp;quot; &amp;quot;Control&amp;quot; &amp;quot;Drug&amp;quot; ...
##  $ Replicate : int  1 2 3 1 2 3
##  $ CellType  : chr  &amp;quot;HeLa&amp;quot; &amp;quot;HeLa&amp;quot; &amp;quot;HeLa&amp;quot; &amp;quot;HeLa&amp;quot; ...&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;control-sequences&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;7&lt;/span&gt; Control Sequences&lt;/h1&gt;
&lt;p&gt;One of the most useful things to be able to do with computers is to repeat the same command multiple times without having to do it by hand each time. For this, control sequences can be used to give you close control over the progress of your program.&lt;/p&gt;
&lt;div id=&#34;if-else&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;7.1&lt;/span&gt; IF ELSE&lt;/h2&gt;
&lt;p&gt;The first control sequence to look at is the “if else” command, which acts as a switch to run one of a selection of possible commands given a switch that you specify. For instance, you may want to do something different depending on whether a value is odd or even:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_val &amp;lt;- 3
if (my_val%%2 == 0) { # If it is even (exactly divisible by 2)
  cat (&amp;quot;Value is even\n&amp;quot;)
} else {              # Otherwise it must be odd
  cat (&amp;quot;Value is odd\n&amp;quot;) 
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Value is odd&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the expression in the parentheses following “if” is evaluated, and if it evaluates to TRUE then the block of code contained within the following curly braces is evaluated. Otherwise, the block of code following the “else” statement is evaluated. You can add additional tests by using the “else if” statement:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_val &amp;lt;- 27
if (my_val%%2 == 0) {
  cat(&amp;quot;Value is divisible by 2\n&amp;quot;)
} else if (my_val%%3 == 0) { 
  cat(&amp;quot;Value is divisible by 3\n&amp;quot;)
} else if (my_val%%4 == 0) {
  ...
} else if (my_val%%n == 0) {
  cat(&amp;quot;Value is divisible by n\n&amp;quot;)
} else {
  cat(&amp;quot;Value is not divisible by 1:n\n&amp;quot;) 
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each switch is followed by a block of code surrounded by curly braces, and the conditional statements are evaluated until one evaluates to TRUE, at which point R avaluates this code bloack then exits. If none of them evaluate to TRUE, then the default code block following “else” is evaluated instead. If no “else” block is present, then the default is to just do nothing. These blocks can be as complicated as you like, and you can have “if else” statements within the blocks to create a hierarchical structure. Note that this ifelse block will ony return the smallest factor of &lt;code&gt;myval&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;for&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;7.2&lt;/span&gt; FOR&lt;/h2&gt;
&lt;p&gt;Another control structure is the “for loop”, which will conduct the code in the block multiple times for a variety of values that you specify at the start. For instance, here is a simple countdown script:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;for (i in 10:1) {
  cat(i, &amp;quot;...\n&amp;quot;, sep = &amp;quot;&amp;quot;) 
  if (i == 1) {
    cat(&amp;quot;Blastoff!\n&amp;quot;) 
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 10...
## 9...
## 8...
## 7...
## 6...
## 5...
## 4...
## 3...
## 2...
## 1...
## Blastoff!&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So the index &lt;code&gt;i&lt;/code&gt; is taken from the set of numbers (10, 9, …, 1), starting at the first value 10, and each time prints out the number followed by a newline. Then an &lt;code&gt;if&lt;/code&gt; statement checks to see if we have reached the final number, at which point it is time for blast off! At this point, it returns to the start of the block, updates the number to the second value 9, and repeats. It does this until there are no more values to use.&lt;/p&gt;
&lt;p&gt;As a small aside, this is slightly inefficient. Evaluation of the &lt;code&gt;if&lt;/code&gt; statement is conducted every single time the loop is traversed (10 times in this example). It will only ever be true at the end of the loop, so we could always take this out of the loop and evaluate the final printout after the loop is finished and save ourselves 10 calculations. Whilst the difference here is negligible, thinking of things like this may save you time in the future:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;for (i in 10:1) {
  cat(i, &amp;quot;...\n&amp;quot;, sep = &amp;quot;&amp;quot;)
} 
cat(&amp;quot;Blastoff!\n&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 10...
## 9...
## 8...
## 7...
## 6...
## 5...
## 4...
## 3...
## 2...
## 1...
## Blastoff!&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;while&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;7.3&lt;/span&gt; WHILE&lt;/h2&gt;
&lt;p&gt;The final main control structure is the “while loop”. This is similar to the “for loop”, and will continue to evaluate the code chunk as long as the specified expression evaluates to TRUE:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;i &amp;lt;- 10
while (i &amp;gt; 0) {
  cat(i, &amp;quot;...\n&amp;quot;, sep = &amp;quot;&amp;quot;) 
  i &amp;lt;- i - 1
} 
cat(&amp;quot;Blastoff!\n&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 10...
## 9...
## 8...
## 7...
## 6...
## 5...
## 4...
## 3...
## 2...
## 1...
## Blastoff!&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This does exactly the same as the “for loop” above. In general, either can be used for a given purpose, but there are times when one would be more “elegant” than the other. For instance, here the for loop is better as you do not need to manually subtract 1 from the index each time.&lt;/p&gt;
&lt;p&gt;However, if you did not know how many iterations were required before finding what you are looking for (for instance searching through a number of files), a “while loop” may be more suitable.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HOWEVER&lt;/strong&gt;: Be aware that it is possible to get caught up in an “infinite loop”. This happens if the conditional statement never evaluates to FALSE. If this happens, press either ESCAPE or press the &lt;code&gt;CONROL&lt;/code&gt; key and the letter &lt;code&gt;c&lt;/code&gt; (&lt;code&gt;CTRL+c&lt;/code&gt;) to quit out of the current function (&lt;code&gt;CMD+c&lt;/code&gt;) for Mac). For instance, if we forget to decrement the index, &lt;code&gt;i&lt;/code&gt; will always be 10 and will therefore never be less than 0. This loop will therefore run forever:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;i &amp;lt;- 10
while (i &amp;gt; 0) {
  cat(i, &amp;quot;...\n&amp;quot;, sep = &amp;quot;&amp;quot;) 
}
cat(&amp;quot;Blastoff!\n&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;loop-control&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;7.4&lt;/span&gt; Loop Control&lt;/h2&gt;
&lt;p&gt;You can leave control loops early by using flow control constructs. &lt;code&gt;next&lt;/code&gt; skips out of the current loop and moves onto the next in the sequence:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;for (i in 1:10) { 
  if (i == 5) {
    next 
  }
  cat (i, &amp;quot;\n&amp;quot;, sep = &amp;quot;&amp;quot;) 
}
cat(&amp;quot;Finished loop\n&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 1
## 2
## 3
## 4
## 6
## 7
## 8
## 9
## 10
## Finished loop&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;break&lt;/code&gt; will leave the loop entirely, and will return to the function after the last curly brace in the code chunk:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;for (i in 1:10) { 
  if (i == 5) {
    break 
  }
  cat (i, &amp;quot;\n&amp;quot;, sep = &amp;quot;&amp;quot;) 
}
cat(&amp;quot;Finished loop\n&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 1
## 2
## 3
## 4
## Finished loop&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;writing-functions-in-r&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;8&lt;/span&gt; Writing Functions in R&lt;/h1&gt;
&lt;p&gt;There are many functions available in R, and chances are if you want to do something somebody has already written the function to do it. It is best to not re-invent the wheel if possible (or at least it is more efficient – sometimes it is good to reinvent the wheel to understand how it works), but very often you will want to create your own functions to save replicating code.&lt;/p&gt;
&lt;p&gt;A function takes in one or more variables, does something with them, and returns something (e.g. a value or a plot). For instance, calculating the mean of a number of values is simply a case of adding them together and dividing by the number of values. Let’s write a function to do this and check that it matches the &lt;code&gt;mean()&lt;/code&gt; function in R:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_mean &amp;lt;- function (x) { # Here, x is a numeric vector 
  nvals &amp;lt;- length(x)
  valsum &amp;lt;- sum(x)
  return (valsum/nvals)
}
my_vals &amp;lt;- c(3,5,6,3,4,3,4,7) 
my_mean(my_vals) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 4.375&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mean(my_vals)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 4.375&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, as with the loops earlier, the function is contained within a block of curly braces. A numeric vector is given to the function, the mean is calculated, and this value is returned to the user using the &lt;code&gt;return()&lt;/code&gt; function. This value can be captured into a variable of your choosing in the same way as with any function.&lt;/p&gt;
&lt;p&gt;You can also add further arguments to the function call. If you want an argument to have a default value, you can specify this in the function declaration. This is the value that will be used if no argument value is specified. Any arguments that do not have a default value must be specified when calling the function, or an error will be thrown:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;foo &amp;lt;- function(x, arg) { 
  return(paste(x, arg, sep = &amp;quot; &amp;quot;))
}
foo (&amp;quot;Hello&amp;quot;) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Error in paste(x, arg, sep = &amp;quot; &amp;quot;): argument &amp;quot;arg&amp;quot; is missing, with no default&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now let’s try and add a default value for &lt;code&gt;arg&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;foo &amp;lt;- function(x, arg = &amp;quot;World!&amp;quot;) { 
  return(paste(x, arg, sep = &amp;quot; &amp;quot;))
}
foo (&amp;quot;Hello&amp;quot;) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Hello World!&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a good point to mention an idea known as “scope”. After running the following function, have a look at the value &lt;code&gt;valsum&lt;/code&gt; calculated within the function:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_mean &amp;lt;- function (x) { # Here, x is a numeric vector 
  nvals &amp;lt;- length(x)
  valsum &amp;lt;- sum(x)
  return (valsum/nvals)
}
my_vals &amp;lt;- c(3,5,6,3,4,3,4,7)
my_mean(my_vals)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 4.375&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print(valsum) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Error in print(valsum): object &amp;#39;valsum&amp;#39; not found&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So what went wrong? The error message says that R cannot find the object &lt;code&gt;valsum&lt;/code&gt;. So where is it? The “scope” of an object is the environment where it can be found. Up until now, we have been using what are known as “global variables”. That is we have created all of our objects within the “global environment”, which is the top level where R searches for objects. These objects are available at all times.&lt;/p&gt;
&lt;p&gt;However, when we call a function, a new environment, or “scope”, is created, and all variables created within the function become “local variables” that can only be accessed from within the function itself. As soon as we leave the function, these local variables are deleted. If you think about it, this makes sense – otherwise, every time we called a function, memory would fill up with a whole load of temporary objects. Also, how many functions do you think create an object called &lt;code&gt;x&lt;/code&gt;? Pretty much all of them (it’s generally the name of the first argument, as in my example). If we created an object &lt;code&gt;x&lt;/code&gt;, then ran a couple of functions, and then went to use &lt;code&gt;x&lt;/code&gt; again, chances are it would no longer be what we thought it was.&lt;/p&gt;
&lt;p&gt;So, the function itself is completely self-contained. A copy of the input variable is stored in a new local variable called &lt;code&gt;x&lt;/code&gt;, something is done to this object (possibly creating additional objects along the way), something is returned, and then all of these objects in the scope of the function are removed, and we move back into the global environment.&lt;/p&gt;
&lt;p&gt;Functions are incredibly useful when we want to repeat the same set of actions on multiple sets of data. The “apply”&amp;quot; set of functions are very useful for running a single function multiple times on input data.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;apply()&lt;/code&gt; works on a matrix or data frame, and applies the function named by the argument &lt;code&gt;FUN&lt;/code&gt; across either the rows or the columns of the table, as specified with the &lt;code&gt;MAR&lt;/code&gt; (margin) argument (&lt;code&gt;MAR=1&lt;/code&gt; for rows, &lt;code&gt;MAR=2&lt;/code&gt; for columns). For instance, suppose that you had a matrix of expression values from a microarray, where each row was a different gene, and each column is the signal from a different probe on the array. We may want to calculate the mean value across these probes for each gene:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;probe_file  &amp;lt;- &amp;quot;probe_values.txt&amp;quot;
probe_dat   &amp;lt;- read.table(probe_file, header = TRUE, sep = &amp;quot;\t&amp;quot;) 
probe_means &amp;lt;- apply(probe_dat[, -1], MAR = 1, FUN = mean) 
probe_means&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 21.2 29.8 85.8 63.6 25.6 44.8 70.8 88.4 47.6 35.8 90.2 57.8 24.2 23.2
## [15] 25.0 57.6 83.0 62.8 33.8 28.4 13.2 58.4 24.6 28.2 47.2  6.4 94.6 14.2
## [29] 39.6 53.4 80.2 47.8  9.8 58.8 59.8  0.4 63.8 33.0 22.4 53.8 37.8 68.8
## [43] 99.6 97.6  5.0 59.8 95.4 -0.2  1.4 52.2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Additionally, apply can be used to apply a function to all values by using &lt;code&gt;MAR=c(1,2)&lt;/code&gt; to run across rows and columns:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;probe_file    &amp;lt;- &amp;quot;probe_values.txt&amp;quot;
probe_dat     &amp;lt;- read.table(probe_file, header = TRUE, sep = &amp;quot;\t&amp;quot;) 
probe_dat_log &amp;lt;- apply(probe_dat[, -1], MAR = c(1,2), FUN = exp) 
probe_dat_log&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##             Probe1       Probe2       Probe3       Probe4       Probe5
##  [1,] 4.424134e+05 7.896296e+13 2.648912e+10 2.980958e+03 3.931334e+12
##  [2,] 3.931334e+12 1.907347e+21 8.886111e+06 5.987414e+04 1.285160e+19
##  [3,] 2.235247e+37 5.052394e+31 1.811239e+41 1.220403e+39 8.223013e+36
##  [4,] 3.404276e+29 4.607187e+28 5.685720e+24 1.373383e+32 1.041376e+23
##  [5,] 3.584913e+09 1.068647e+13 1.484132e+02 7.896296e+13 8.659340e+16
##  [6,] 3.493427e+19 2.581313e+20 1.142007e+26 3.185593e+16 5.834617e+14
##  [7,] 2.758513e+33 1.545539e+25 6.837671e+30 1.373383e+32 1.373383e+32
##  [8,] 2.451246e+40 1.373383e+32 4.375039e+48 3.025077e+36 2.038281e+34
##  [9,] 3.185593e+16 1.907347e+21 1.041376e+23 1.545539e+25 2.353853e+17
## [10,] 2.146436e+14 6.565997e+07 1.285160e+19 2.581313e+20 1.171914e+16
## [11,] 2.235247e+37 6.076030e+37 5.399228e+44 6.837671e+30 1.467662e+45
## [12,] 1.142007e+26 8.438357e+26 4.201210e+25 7.016736e+20 1.142007e+26
## [13,] 1.784823e+08 1.784823e+08 4.311232e+15 5.987414e+04 4.311232e+15
## [14,] 9.744803e+09 1.627548e+05 9.744803e+09 2.353853e+17 6.565997e+07
## [15,] 1.957296e+11 7.200490e+10 4.851652e+08 2.146436e+14 1.318816e+09
## [16,] 2.091659e+24 3.493427e+19 1.858672e+31 1.014800e+33 8.659340e+16
## [17,] 2.038281e+34 2.451246e+40 4.923458e+41 5.540622e+34 1.252363e+29
## [18,] 9.253782e+29 3.831008e+22 4.093997e+35 1.545539e+25 1.041376e+23
## [19,] 4.311232e+15 1.907347e+21 1.957296e+11 2.146436e+14 7.200490e+10
## [20,] 1.446257e+12 1.318816e+09 5.834617e+14 5.320482e+11 7.896296e+13
## [21,] 8.103084e+03 2.648912e+10 3.584913e+09 5.459815e+01 1.096633e+03
## [22,] 6.235149e+27 5.685720e+24 7.694785e+23 2.515439e+30 9.496119e+19
## [23,] 3.584913e+09 6.398435e+17 2.415495e+07 1.318816e+09 3.584913e+09
## [24,] 3.584913e+09 5.987414e+04 4.311232e+15 8.659340e+16 2.146436e+14
## [25,] 1.409349e+22 8.659340e+16 1.285160e+19 4.201210e+25 4.727839e+18
## [26,] 1.096633e+03 7.389056e+00 1.957296e+11 1.096633e+03 4.539993e-05
## [27,] 1.811239e+41 1.112864e+36 4.093997e+35 7.307060e+43 4.375039e+48
## [28,] 1.627548e+05 3.931334e+12 1.353353e-01 1.627548e+05 4.851652e+08
## [29,] 1.739275e+18 1.285160e+19 1.907347e+21 8.659340e+16 2.648912e+10
## [30,] 7.016736e+20 4.201210e+25 2.091659e+24 1.739275e+18 8.438357e+26
## [31,] 4.093997e+35 1.858672e+31 6.663176e+40 4.093997e+35 6.837671e+30
## [32,] 1.409349e+22 2.830753e+23 3.831008e+22 8.659340e+16 4.727839e+18
## [33,] 2.415495e+07 1.484132e+02 2.648912e+10 1.000000e+00 2.008554e+01
## [34,] 6.837671e+30 1.409349e+22 1.041376e+23 1.694889e+28 2.830753e+23
## [35,] 1.252363e+29 1.041376e+23 6.837671e+30 3.104298e+26 2.581313e+20
## [36,] 5.459815e+01 3.059023e-07 4.424134e+05 8.315287e-07 1.202604e+06
## [37,] 9.253782e+29 1.142007e+26 4.093997e+35 1.041376e+23 7.694785e+23
## [38,] 1.068647e+13 3.185593e+16 5.320482e+11 1.586013e+15 1.586013e+15
## [39,] 2.415495e+07 9.744803e+09 1.586013e+15 3.931334e+12 2.980958e+03
## [40,] 7.694785e+23 6.398435e+17 5.685720e+24 1.041376e+23 2.293783e+27
## [41,] 5.834617e+14 1.068647e+13 4.727839e+18 1.446257e+12 2.830753e+23
## [42,] 9.253782e+29 1.858672e+31 5.540622e+34 7.694785e+23 3.404276e+29
## [43,] 1.338335e+42 6.493134e+50 1.084464e+46 1.220403e+39 1.651636e+38
## [44,] 1.811239e+41 4.093997e+35 3.989520e+45 1.986265e+44 1.467662e+45
## [45,] 5.459815e+01 5.459815e+01 6.565997e+07 6.144212e-06 5.987414e+04
## [46,] 4.607187e+28 4.201210e+25 7.694785e+23 3.831008e+22 1.252363e+29
## [47,] 4.489613e+38 2.178204e+47 2.758513e+33 3.989520e+45 1.338335e+42
## [48,] 7.389056e+00 3.678794e-01 1.831564e-02 1.125352e-07 6.565997e+07
## [49,] 5.459815e+01 1.234098e-04 6.565997e+07 9.118820e-04 2.718282e+00
## [50,] 9.496119e+19 7.694785e+23 1.142007e+26 6.398435e+17 4.201210e+25&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The same results can be generated by using a &lt;code&gt;for&lt;/code&gt; loop to loop over all entries, but this is much slower.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lapply()&lt;/code&gt; (“list apply”) is similar but runs over a list of values, and returns the output as a list of values. In this example, the mean is calculated for a number of vectors, but these vectors can be different sizes (unlike for a matrix or data frame):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_list &amp;lt;- list(val1 = c(2,4,2,3,4,3,4), 
                val2 = c(1,2), 
                val3 = c(10,2,5,9)) 
lapply(my_list, FUN = mean)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $val1
## [1] 3.142857
## 
## $val2
## [1] 1.5
## 
## $val3
## [1] 6.5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, since the output is a list, the output could also be a list of vectors:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_list &amp;lt;- list(val1 = c(2,4,2,3,4,3,4), 
                val2 = c(1,2), 
                val3 = c(10,2,5,9)) 
lapply(my_list, FUN = sort)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $val1
## [1] 2 2 3 3 4 4 4
## 
## $val2
## [1] 1 2
## 
## $val3
## [1]  2  5  9 10&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;sapply()&lt;/code&gt; (“simple apply”) is similar to &lt;code&gt;lapply()&lt;/code&gt;, but returns the results as a vector rather than a list. This is a better method to use when returning a single value for each list entry:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_list &amp;lt;- list(val1 = c(2,4,2,3,4,3,4), 
                val2 = c(1,2), 
                val3 = c(10,2,5,9)) 
sapply(my_list, FUN = mean)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     val1     val2     val3 
## 3.142857 1.500000 6.500000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;mapply()&lt;/code&gt; (“multivariate apply”) is very useful for vectorization, and works by applying the function &lt;code&gt;FUN&lt;/code&gt; to the first elements of each object, then to the second element, and so on. The following example will replicate the number &lt;code&gt;n&lt;/code&gt; n-times for numbers 1 to 5. This could also be done using loops, but loops do not scale as well as vectorised functions such as this:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mapply(rep, 1:5, 1:5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## [1] 1
## 
## [[2]]
## [1] 2 2
## 
## [[3]]
## [1] 3 3 3
## 
## [[4]]
## [1] 4 4 4 4
## 
## [[5]]
## [1] 5 5 5 5 5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;tapply()&lt;/code&gt; is a little more complicated, but essentially applies a function after breaking data up based on some index variable. It is useful for calculating summary statistics of different groups of data, and uses a factor parameter &lt;code&gt;INDEX&lt;/code&gt; to define the groups over which to apply the function &lt;code&gt;FUN&lt;/code&gt;. So in the following code, &lt;code&gt;tapply&lt;/code&gt; will apply the function &lt;code&gt;mean()&lt;/code&gt; on the values of &lt;code&gt;Expression&lt;/code&gt; for the two different treatment classes defined in the &lt;code&gt;INDEX&lt;/code&gt; variable:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_dat &amp;lt;- data.frame(Treatment = c(&amp;quot;Control&amp;quot;, &amp;quot;Control&amp;quot;, &amp;quot;Control&amp;quot;, 
                                   &amp;quot;Treated&amp;quot;, &amp;quot;Treated&amp;quot;, &amp;quot;Treated&amp;quot;),
                     Expression = c(13, 17, 9,
                                    28, 37, 34))
tapply(my_dat$Expression, INDEX = my_dat$Treatment, FUN = mean)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Control Treated 
##      13      33&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;some-simple-statistics&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;9&lt;/span&gt; Some Simple Statistics&lt;/h1&gt;
&lt;p&gt;R is mainly designed for easy computation of statistics and there are many in-built functions and additional libraries that allow you to carry out most tasks. Most simple statistics can be easily calculated using in-built functions. The following example creates two vectors of 100 random values sampled from a normal distribution with mean 0 and standard deviation 1, then calculates various basic summary statistics:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- sort(rnorm(100, mean = 0, sd = 1))
min(x)   &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] -2.469406&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;max(x)   &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2.456791&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mean(x)  &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] -0.1545429&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;median(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] -0.05459327&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The minimum and maximum values are the smallest and largest values respectively. The mean is what most people would think of when you asked for the average, and is calculated by summing the values and dividing by the total number of values. The median is another way of looking at the average, and is essentially the middle value (&lt;code&gt;50^th^&lt;/code&gt; percentile). Other percentiles can be calculated, which can give you an idea of where the majority of your data lie:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;quantile(x, probs = 0.25) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##        25% 
## -0.8799137&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;quantile(x, probs = 0.75) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       75% 
## 0.5016485&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;quantile(x, probs = seq(0, 1, 0.1))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          0%         10%         20%         30%         40%         50% 
## -2.46940647 -1.40227823 -0.99043502 -0.70290442 -0.39528086 -0.05459327 
##         60%         70%         80%         90%        100% 
##  0.13332282  0.41401259  0.65654592  1.10042294  2.45679115&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;summary()&lt;/code&gt; function will calculate many of these basic statistics for you:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
## -2.46941 -0.87991 -0.05459 -0.15454  0.50165  2.45679&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The variance is the average of the squared distances from the mean, and is a measure of how spread out the data are from the average. The standard deviation is simply the square root of this value &lt;span class=&#34;math inline&#34;&gt;\(var(x) = sd(x)^2\)&lt;/span&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sd(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.009332&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;var(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.018752&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;all.equal(sd(x)^2, var(x))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sum((x-mean(x))^2)/(length(x)-1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.018752&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The covariance is a measure of how much two sets of data vary together:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;y &amp;lt;- sort(rnorm(100, mean = 0, sd = 1))
var(y)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.8662482&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cov(x, y)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9318779&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The covariance is related to the correlation between two data sets, which is a number between -1 and 1 indicating the level of dependance between the two variables. A value of 1 indicates perfect correlation, so that as one value increases so does the other. A value of -1 indicates perfect anti-correlation, so that as one value increases the other decreases. A value of 0 indicates that the two values change independently of one another:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cor(x, y)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9919817&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cov(x, y)/(sd(x) * sd(y)) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9919817&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This value is known as the Pearson correlation. An alternative method for calculating the correlation between two sets of values is to use the Spearman correlation, which is essentially the same as the Pearson correlation but is calculated on the ranks of the data rather than the values themselves. In this way, each value increases by only one unit at a time, meaning that the correlation score is more robust to the presence of outliers:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cor(x, y, method = &amp;quot;spearman&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So these values are pretty highly dependent on one another – not surprising considering that they are both drawn randomly from the same distribution. We can calculate the line of best fit between the two vectors by using linear regression, which searches for the best straight line model &lt;span class=&#34;math inline&#34;&gt;\(y = a + bx\)&lt;/span&gt; that minimises the squared distances between the line (estimated values) and the observed data points:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_lin_mod &amp;lt;- lm(y ~ x)
summary(my_lin_mod)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = y ~ x)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -0.20933 -0.07078  0.00838  0.06544  0.33903 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept)  0.15961    0.01196   13.34   &amp;lt;2e-16 ***
## x            0.91473    0.01177   77.70   &amp;lt;2e-16 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 0.1182 on 98 degrees of freedom
## Multiple R-squared:  0.984,  Adjusted R-squared:  0.9839 
## F-statistic:  6038 on 1 and 98 DF,  p-value: &amp;lt; 2.2e-16&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Explaining this output is beyond the scope of this short tutorial, but the coefficient estimates give us the values for &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;0.1596068&lt;/code&gt;) and &lt;code&gt;b&lt;/code&gt; (&lt;code&gt;0.9147252&lt;/code&gt;) in the linear model. The p-value tells us how significant these estimates are. In statistical terms, we are testing the null hypothesis that the coefficient is actually equal to zero (i.e. there is not an association between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;). The p-value gives the probability of detecting a coefficient at least as large as the one that we calculated in our model given that the null hypothesis is actually true. If this probability is low enough, we can safely reject the null hypothesis and say that this variable is statistically significant. Often a value of 0.05 (5%) is used as the cutoff for rejection of the null hypothesis.&lt;/p&gt;
&lt;p&gt;Hypothesis testing is a large part of statistics. The t-test is a commonly used test for comparing the means of two sets of data. In simple terms we are looking to see if they are significantly different (e.g. does the expression of a particular gene change significantly following treatment with a drug). In statistical terms, we are testing to see if the change that we see in the means is greater than we would expect by chance alone.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;t.test(x, y) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Welch Two Sample t-test
## 
## data:  x and y
## t = -1.2585, df = 196.71, p-value = 0.2097
## alternative hypothesis: true difference in means is not equal to 0
## 95 percent confidence interval:
##  -0.44354509  0.09797417
## sample estimates:
##  mean of x  mean of y 
## -0.1545429  0.0182426&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are drawn from the same distribution, the test shows there is no evidence that there is a difference between the mean. Let’s try again with a different data set, drawn from a different distribution:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;z &amp;lt;- rnorm(100, mean = 10, sd = 1) 
t.test(x, z)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Welch Two Sample t-test
## 
## data:  x and z
## t = -69.957, df = 197.94, p-value &amp;lt; 2.2e-16
## alternative hypothesis: true difference in means is not equal to 0
## 95 percent confidence interval:
##  -10.358041  -9.790083
## sample estimates:
##  mean of x  mean of y 
## -0.1545429  9.9195190&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This time, the p-value is much less than 0.05, so we can make the claim that the mean of &lt;code&gt;z&lt;/code&gt; is significantly different from that of &lt;code&gt;x&lt;/code&gt;. By default, the &lt;code&gt;t.test()&lt;/code&gt; function is 2-sided, meaning that it does not distinguish between whether or not the difference in the means is an increase or a decrease in &lt;code&gt;z&lt;/code&gt;. We can specify the &lt;code&gt;alternative&lt;/code&gt; parameter to define the alternative hypothesis that we want to test:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;t.test(x, z, alternative = &amp;quot;less&amp;quot;)    ## Tests if mean(x) &amp;lt; mean(z) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Welch Two Sample t-test
## 
## data:  x and z
## t = -69.957, df = 197.94, p-value &amp;lt; 2.2e-16
## alternative hypothesis: true difference in means is less than 0
## 95 percent confidence interval:
##       -Inf -9.836083
## sample estimates:
##  mean of x  mean of y 
## -0.1545429  9.9195190&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;t.test(x, z, alternative = &amp;quot;greater&amp;quot;) ## Tests if mean(x) &amp;gt; mean(z)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Welch Two Sample t-test
## 
## data:  x and z
## t = -69.957, df = 197.94, p-value = 1
## alternative hypothesis: true difference in means is greater than 0
## 95 percent confidence interval:
##  -10.31204       Inf
## sample estimates:
##  mean of x  mean of y 
## -0.1545429  9.9195190&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This tells us that the difference in the means between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt; is less than 0, or that the mean of &lt;code&gt;z&lt;/code&gt; is greater than that of &lt;code&gt;x&lt;/code&gt; (as we expect).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;plotting-with-r&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;10&lt;/span&gt; Plotting With R&lt;/h1&gt;
&lt;p&gt;One of the most useful functions of R is the ability to plot publication-quality figures simply and easily. The vast number of tools available to users for plotting figures is beyond the scope of this tutorial, but I will mention a few of the most commonly used plotting functions to allow you to have a quick look at your data. These functions are all part of the &lt;code&gt;base&lt;/code&gt; plotting package, but I also recommend looking into the &lt;a href=&#34;http://ggplot2.org&#34;&gt;ggplot2()&lt;/a&gt; package for an incredibly intuative appraoch to plotting data.&lt;/p&gt;
&lt;div id=&#34;scatterplots&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;10.1&lt;/span&gt; Scatterplots&lt;/h2&gt;
&lt;p&gt;Scatterplots are probably the simplest plot that we can look at. Here we take two sets of values and plot one against the other to see how they correlate. This means that the two data sets are paired, such that the first element of each data set represents one event, the second represents another, and so on. For instance, for every student in a class, we may have scores from tests taken at the start and at the end of the year, and we want to compare them against one another to see how they compare. Here is how to plot a simple scatterplot:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(x, y, 
     pch = 19,                  ## Plot each point as a filled circle
     col = &amp;quot;red&amp;quot;,               ## Colour each point red
     xlab = &amp;quot;This is x&amp;quot;,        ## Add a label to the x-axis
     ylab = &amp;quot;This is y&amp;quot;,        ## Add a label to the y-axis
     main = &amp;quot;This is y vs. x&amp;quot;,  ## Add a main title to the plot
     cex.main = 1.4,            ## Change the size of the title
     cex.lab  = 1.2,            ## Change the size of the axis labels
     cex.axis = 1.1             ## Change the size of the axis values
     )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/RTutorial/index_files/figure-html/scatterplot1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;There are lots of additional plotting arguments that can be set in the &lt;code&gt;plot()&lt;/code&gt; command. These are just a few. These arguments will typically work for any plotting function that you may want to use.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;plot()&lt;/code&gt; is the standard plotting function, and works differently depending on the type of data on which it is called. Most of the following plots use this function in some way, even though it may not be obvious.&lt;/p&gt;
&lt;p&gt;Here we have coloured all of our points a single colour by using the &lt;code&gt;col = &amp;quot;red&amp;quot;&lt;/code&gt; argument. However, we can assign colours to each point separately by supplying a vector of colours that is the same length as &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. This means that we can set colours based on the data themselves:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_cols &amp;lt;- rep(&amp;quot;black&amp;quot;, length(x)) 
my_cols[x &amp;gt; 1 &amp;amp; y &amp;gt;  1] &amp;lt;- &amp;quot;red&amp;quot;
my_cols[x &amp;gt; 1 &amp;amp; y &amp;lt; -1] &amp;lt;- &amp;quot;green&amp;quot; 
my_cols[x &amp;lt; 0 &amp;amp; y &amp;gt;  0] &amp;lt;- &amp;quot;blue&amp;quot;
plot(x, y, col = my_cols, pch = 19)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/RTutorial/index_files/figure-html/scatterplot2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Since this plot is useful for observing the level of correlation between two data sets, it may be useful to add a couple of lines in to the plot to help us determine if there is a trend indicating that x is well correlated with y. First of all we will add lines in through the origin, and then we will add in a dotted line along the x = y line (since, if the two datasets were exactly correlated, the points would lie on this line). To do this, we use the &lt;code&gt;abline()&lt;/code&gt; function. This plots a straight line in one of three ways. We can either specify a horizontal line by specifying the &lt;code&gt;h&lt;/code&gt; argument, or we can specify a vertical line by using the &lt;code&gt;v&lt;/code&gt; argument, or we can specify a straight line in the format &lt;span class=&#34;math inline&#34;&gt;\(y = a + bx\)&lt;/span&gt; (where &lt;code&gt;a&lt;/code&gt; is the intercept term and &lt;code&gt;b&lt;/code&gt; is the gradient term):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(x, y, ylim = c(-3,3), xlim = c(-3,3))
abline(h = 0)
abline(v = 0)
abline(a = 0, b = 1, lty = 2) ## lty gives the line type - in this case dotted&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/RTutorial/index_files/figure-html/scatterplot3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Notice that &lt;code&gt;abline()&lt;/code&gt; does not create a new plot, but instead adds to the plot that we already have. This is because it does not call the &lt;code&gt;plot.new()&lt;/code&gt; function, which would otherwise create a new plotting region.&lt;/p&gt;
&lt;p&gt;We may be particularly interested in how the line of best fit looks as compared to the &lt;span class=&#34;math inline&#34;&gt;\(x = y\)&lt;/span&gt; line, as this will show us if there is a general trend in the data or not. To do this we can use a linear model to predict &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; from the data:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(x, y, ylim = c(-3,3), xlim = c(-3,3))
my_lin_model &amp;lt;- lm(y ~ x) 
abline(my_lin_model, lty = 2, col = &amp;quot;red&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/RTutorial/index_files/figure-html/scatterplot4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;If you want to explicitly pull out &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, use the &lt;code&gt;coef()&lt;/code&gt; function to get the coefficients:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;coef(my_lin_model)[1] ## Get the intercept from the coefficients of the model &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## (Intercept) 
##   0.1596068&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;coef(my_lin_model)[2] ## Get the gradient from the coefficients of the model&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         x 
## 0.9147252&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;histograms&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;10.2&lt;/span&gt; Histograms&lt;/h2&gt;
&lt;p&gt;Now let’s look at the distribution of the data. A histogram is useful for this. Here we count up the number of values that fall into discrete bins. The size of the bins (or the number of bins) can be specified by using the &lt;code&gt;breaks&lt;/code&gt; argument:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- rnorm (1000)
par(mfrow=c(1,2))
hist(x) ## Shows a nice bell shape curve about mean 0 
hist(x, breaks = 200) ## More fine-grained&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/RTutorial/index_files/figure-html/histogram-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;quantile-quantile-plots&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;10.3&lt;/span&gt; Quantile-Quantile Plots&lt;/h2&gt;
&lt;p&gt;Quantile-quantile plots are a particular type of scatterplot that are used to see if two data sets are drawn from the same distribution. To do this, it plots the quantiles of each data set against each other. That is it plots the 0&lt;sup&gt;th&lt;/sup&gt; percentile of data set A (the minimum value) against the 0th percentile of data set B, the 50&lt;sup&gt;th&lt;/sup&gt; percentiles (the medians) against each other, the 100&lt;sup&gt;th&lt;/sup&gt; percentiles (the maximum values) against each other, etc. Simply, it sorts both data sets, and makes them both the same length by estimating any missing values, then plots a scatterplot of the sorted data. If the two data sets are drawn from the same distribution, this plot should follow the &lt;span class=&#34;math inline&#34;&gt;\(x = y\)&lt;/span&gt; identity line at all but the most extreme point.&lt;/p&gt;
&lt;p&gt;Here is a QQ plot for two data sets drawn from the same normal distribution:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x1 &amp;lt;- rnorm(100, mean = 0, sd = 1) 
x2 &amp;lt;- rnorm(1000, mean = 0, sd = 1) 
qqplot(x1, x2)
abline(a = 0, b = 1, lty = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/RTutorial/index_files/figure-html/QQplot1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;And here is a QQ plot for two data sets drawn from different normal distributions:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x1 &amp;lt;- rnorm(100, mean = 0, sd = 1) 
x2 &amp;lt;- rnorm(1000, mean = 1, sd = 3) 
qqplot(x1, x2)
abline(a = 0, b = 1, lty = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/RTutorial/index_files/figure-html/QQplot2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;line-plots&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;10.4&lt;/span&gt; Line Plots&lt;/h2&gt;
&lt;p&gt;Scatterplots are useful for generating correlation plots for pairs of data. Another form of data is a set of values along a continuum, for instance we may have the read count along the length of the genome. For this, a scatterplot may not be the most sensible way of viewing these data. Instead, a line plot may be a more fitting way of viewing the data. To do this we simply specify the &lt;code&gt;type&lt;/code&gt; argument to be &lt;code&gt;line&lt;/code&gt; (or simply &lt;code&gt;l&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;One thing to be careful of with data such as this is that you must make sure that the data are ordered from left to right (or right to left) on the x axis so that connecting the points makes sense on the continuum. For instance, the following plot is not terribly useful:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x = c(2,4,5,3,1,7,9,8,6,10)
y = c(4,2,5,4,10,6,6,5,6,9)
plot(x = x, y = y, type = &amp;#39;l&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/RTutorial/index_files/figure-html/lineplot1-1.png&#34; width=&#34;672&#34; /&gt;
But if we order the data from left to right then it will be a lot more useful:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(x = x[order(x)], y = y[order(x)], type = &amp;#39;l&amp;#39;) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/RTutorial/index_files/figure-html/lineplot2-1.png&#34; width=&#34;672&#34; /&gt;
You can also plot both points and lines by setting the &lt;code&gt;type&lt;/code&gt; argument to &lt;code&gt;both&lt;/code&gt; (or &lt;code&gt;b&lt;/code&gt;):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(x = x[order(x)], y = y[order(x)], type = &amp;#39;b&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/RTutorial/index_files/figure-html/lineplot3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;density-plots&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;10.5&lt;/span&gt; Density Plots&lt;/h2&gt;
&lt;p&gt;We can use a line plot like this to plot the density of the data, which gives us a similar plot to the histogram. The benefit of this type of plot over a histogram is that you can overlay the distribution of multiple data sets. The &lt;code&gt;density()&lt;/code&gt; function is a kernal density estimator function that basically calculates the density of the data within each bin such that the total area under the resulting curve is 1. This makes these plots useful for comparing data sets of different sizes as they are essentially normalised. We can add a legend to this plot to make it clear which line represents which sample. Again, this does not call &lt;code&gt;plot.new()&lt;/code&gt; so will appear on top of the current plot:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## Create 2 random normal distributions about 5 and 10 respectively
x1 &amp;lt;- rnorm(100, mean = 5, sd = 1) 
x2 &amp;lt;- rnorm(1000, mean = 10, sd = 1)

## Calculate the density of each
x1dens &amp;lt;- density(x1) 
x2dens &amp;lt;- density(x2)

## Set up a plotting region explicitly
plot.new()
plot.window(xlim = c(0,15), 
            ylim = c(0,0.5))
range&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## function (..., na.rm = FALSE)  .Primitive(&amp;quot;range&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;title(xlab = &amp;quot;Value&amp;quot;, ylab = &amp;quot;Density&amp;quot;, main = &amp;quot;Density Plot&amp;quot;) 
axis(1)
axis(2)

## Add the data (notice that these do not call plot.new() so will add onto the current figure
lines(x1dens , col = &amp;quot;red&amp;quot;) 
lines(x2dens , col = &amp;quot;blue&amp;quot;)

## Add a legend
legend(&amp;quot;topleft&amp;quot;, legend = c(&amp;quot;Mean = 5&amp;quot;, &amp;quot;Mean = 10&amp;quot;), col = c(&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;), lty = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/RTutorial/index_files/figure-html/density1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;boxplots&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;10.6&lt;/span&gt; Boxplots&lt;/h2&gt;
&lt;p&gt;Another way to compare the distribution of two (or more) data sets is by using a boxplot. A boxplot shows the overal distribution by plotting a box bounded by the first and third quartiles, with the median highlighted. This shows where the majority of the data lie. Additional values are plotted as whiskers coming out from the main box:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;boxplot(x1, x2, names = c(&amp;quot;Mean = 5&amp;quot;, &amp;quot;Mean = 10&amp;quot;), ylab = &amp;quot;Value&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/RTutorial/index_files/figure-html/boxplot1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;boxplot()&lt;/code&gt; can also take the data in the form of a data frame, which is useful for instance if you want to compare the distribution of expression values over all genes for a number of different samples. This will automatically label the boxes with the column names from the data frame:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_data &amp;lt;- data.frame(Sample1 = rnorm(100), 
                      Sample2 = rnorm(100), 
                      Sample3 = rnorm(100), 
                      Sample4 = rnorm(100), 
                      Sample5 = rnorm(100))
boxplot(my_data)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/RTutorial/index_files/figure-html/boxplot2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;bar-plots-and-pie-charts&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;10.7&lt;/span&gt; Bar Plots and Pie Charts&lt;/h2&gt;
&lt;p&gt;Now let’s say that we have a data set that shows the number of called peaks from a ChIPseq data set that fall into distinct genomic features (exons, introns, promoters and intergenic regions). One way to look at how the peaks fall would be to look at a pie graph:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_peak_nums &amp;lt;- c(&amp;quot;exon&amp;quot;       = 1400, 
                  &amp;quot;intron&amp;quot;     = 900, 
                  &amp;quot;promoter&amp;quot;   = 200, 
                  &amp;quot;intergenic&amp;quot; = 150) 
pie(my_peak_nums)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/RTutorial/index_files/figure-html/pie1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;This figure shows that the majority of the peaks fall into exons. However, pie graphs are typically discouraged by statisticians, because your eyes can often misjudge estimates of the area taken up by each feature. A better way of looking at data such as this would be in the form of a barplot:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;barplot(my_peak_nums, 
        ylab = &amp;quot;Number of Peaks in Feature&amp;quot;, 
        main = &amp;quot;Peaks in Gene Features&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/RTutorial/index_files/figure-html/barplot1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Now let’s suppose that we had data showing the number of peaks in different genomic features for multiple samples. We could plot multiple pie charts:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_peak_nums &amp;lt;- data.frame(GeneFeature = c(&amp;quot;exon&amp;quot;, &amp;quot;intron&amp;quot;, &amp;quot;promoter&amp;quot;, &amp;quot;intergenic&amp;quot;),
                           Sample1 = c( 1400, 900, 200, 150 ),
                           Sample2 = c( 2400, 1000, 230,250 ),
                           Sample3 = c( 40,30, 5,7 )
                           )
par(mfrow = c(1,3))
pie(my_peak_nums[[2]], main = &amp;quot;Sample1&amp;quot;, labels = my_peak_nums[[1]])
pie(my_peak_nums[[3]], main = &amp;quot;Sample2&amp;quot;, labels = my_peak_nums[[1]])
pie(my_peak_nums[[4]], main = &amp;quot;Sample3&amp;quot;, labels = my_peak_nums[[1]])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/RTutorial/index_files/figure-html/pie2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;par(mfrow = c(1,1)) ## Reset the plotting region&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However comparing across multiple pie charts is very difficult. Instead, a single barplot will work better. Note that here the number of peaks is different for each sample, so it makes more sense to convert the data into a format whereby the bar height represents the percentage of peaks within a particular feature:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## Convert to percentages so that the samples are comparable
my_peak_percent &amp;lt;- my_peak_nums[, 2:4] 
for (i in 1:3) {
  my_peak_percent[[i]] &amp;lt;- 100*my_peak_percent[[i]]/sum(my_peak_percent[[i]]) 
}

## Convert to a matrix to satisfy requirements for barplot()
my_peak_percent &amp;lt;- as.matrix(my_peak_percent)

## Plot the bar plot
barplot(my_peak_percent ,
        ylab = &amp;quot;Percentage of Peaks in Feature&amp;quot;, 
        main = &amp;quot;Peaks in Gene Features&amp;quot;, 
        legend.text = my_peak_nums[[&amp;quot;GeneFeature&amp;quot;]])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/RTutorial/index_files/figure-html/barplot2-1.png&#34; width=&#34;672&#34; /&gt;
Notice that the default way that &lt;code&gt;barplot()&lt;/code&gt; works is to plot the bars in a single stack for each sample. This is fine for comparing the exons, but trying to compare the other classes is much harder. A better way to plot these data would be to plot the bars side by side for each sample:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;barplot(my_peak_percent ,
        ylab = &amp;quot;Percentage of Peaks in Feature&amp;quot;, 
        main = &amp;quot;Peaks in Gene Features&amp;quot;, 
        legend.text = my_peak_nums[[&amp;quot;GeneFeature&amp;quot;]], 
        beside = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/RTutorial/index_files/figure-html/barplot3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;graphical-control&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;10.8&lt;/span&gt; Graphical Control&lt;/h2&gt;
&lt;p&gt;That covers the majority of the basic plotting functions that you may want to use. You can change the standard plotting arguments by using the par() command:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;par(mar = c(5,10,0,3))  ## Sets the figure margins (in &amp;#39;number of lines&amp;#39;) - b,l,t,r
par(las = 1)            ## Changes axis labels to always be horizontal
par(tcl = -0.2)         ## Change the size of the axis ticks
plot(x = rnorm(100), y = rnorm(100))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/RTutorial/index_files/figure-html/barplot4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;subplots&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;10.9&lt;/span&gt; Subplots&lt;/h2&gt;
&lt;p&gt;By default, the graphics device will plot a single figure only. There are several ways to create subfigures within this region. The first is to set the &lt;code&gt;mfrow&lt;/code&gt; argument in &lt;code&gt;par()&lt;/code&gt;. This will split the graphics region into equally sized subplots:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;par(mfrow = c(3, 2)) ## Creates a figure region with 3 rows and 2 columns 
for (i in 1:6) {
  plot(x = rnorm(100), y = rnorm(100)) 
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/RTutorial/index_files/figure-html/subplot1-1.png&#34; width=&#34;672&#34; /&gt;
However, if you want more control over your plotting, you can use the &lt;code&gt;layout()&lt;/code&gt; function which allows you to specify the size and layout of the subplots. This function takes a matrix specifying where in the grid of subplots each plot should be drawn to. So the first call to &lt;code&gt;plot()&lt;/code&gt; will put its figure in the grid regions labelled &lt;code&gt;1&lt;/code&gt;, the scond call will put its figure anywhere that there is a &lt;code&gt;2&lt;/code&gt;, etc. Anywhere that you do not want a figure should have a &lt;code&gt;0&lt;/code&gt;. The heights and widths arguments allow you to specify the size of each grid region. You can check what the resulting figure layout will look like by using &lt;code&gt;layout.show(n)&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the number of subplots in your figure. With a bit of work, you can get some very good layouts:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_layout &amp;lt;- matrix(c(1,1,1,1,2,2,3,4,2,2,3,4,0,0,3,4,0,0,5,5), nrow = 5, ncol = 4, byrow = TRUE)
layout(my_layout, widths = c(10,10,2,2), heights = c(1,5,5,5,2)) 
my_layout&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3] [,4]
## [1,]    1    1    1    1
## [2,]    2    2    3    4
## [3,]    2    2    3    4
## [4,]    0    0    3    4
## [5,]    0    0    5    5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;layout.show(5) ## Can you see how this matrix leads to this layout? &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/RTutorial/index_files/figure-html/subplot2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;saving-figures&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;10.10&lt;/span&gt; Saving Figures&lt;/h2&gt;
&lt;p&gt;By default, figures are generated in a seperate window from R. However, you can save the figure to an external file by using one of the functions &lt;code&gt;png()&lt;/code&gt;, &lt;code&gt;pdf()&lt;/code&gt;, &lt;code&gt;jpeg()&lt;/code&gt;, etc. These functions open a new “device”, which R can use to plot to. After the figure has been plotted, the device must be turned off again using the &lt;code&gt;dev.off()&lt;/code&gt; function. There are many arguments that can be used for these functions. In general, these define the dimensions and resolution of the resulting figure. It can be difficult to get these right, so play around to see how they affect things:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;png(&amp;quot;figures/test_figure.png&amp;quot;, height = 10, width = 10, unit = &amp;quot;in&amp;quot;, res = 300)
plot(1:10, 1:10, type = &amp;quot;l&amp;quot;, main = &amp;quot;My Test Figure&amp;quot;, xlab = &amp;quot;x axis&amp;quot;, ylab = &amp;quot;y axis&amp;quot;) 
dev.off()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;example-analysis&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;11&lt;/span&gt; Example Analysis&lt;/h1&gt;
&lt;div id=&#34;introduction-2&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;11.1&lt;/span&gt; Introduction&lt;/h2&gt;
&lt;p&gt;This is just a simple example analysis to give you an idea of the sort of things that we can do with R. Suppose that we have two experiments, each looking at the effects on gene expression of using a particular drug (“Drug A” and “Drug B”). For each experiment we have two samples; one showing the gene expression when treated with the drug, and the other showing the gene expression when treated with some control agent. Obviously in a real experiment, we would have many replicates, but here we have &lt;span class=&#34;math inline&#34;&gt;\(n=1\)&lt;/span&gt;. We want to do the following:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;For each drug, we want to get the fold change for each gene&lt;/li&gt;
&lt;li&gt;For each drug, we want to identify the genes that are significantly changed when using the drug&lt;/li&gt;
&lt;li&gt;We want to compare the results for Drug A with those from Drug B to find genes that are affected similarly by both drugs&lt;/li&gt;
&lt;li&gt;We want to plot the correlation between the fold change values for the two drugs to see how similar they are&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For this, we will need four files. These files are in a tab-delimited text format. They are tables of values where each row is separated by a new line, and each column is separated by a tab character (&lt;code&gt;\t&lt;/code&gt;). These files can be created by and read into Excel for ease of use. To avoid errors when reading in files from text, it is good practice to ensure that there are no missing cells in your data. Instead try to get into the habit of using some “missing”&amp;quot; character (e.g. &lt;code&gt;NA&lt;/code&gt;).&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th&gt;File Name&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;a href=&#34;experiment1_control.txt&#34;&gt;experiment1_control.txt&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Expression levels for ctrl in expt 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;a href=&#34;experiment1_drug.txt&#34;&gt;experiment1_drug.txt&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Expression levels for drug A in expt 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;a href=&#34;experiment2_control.txt&#34;&gt;experiment2_control.txt&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Expression levels for control in expt 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;a href=&#34;experiment2_drug.txt&#34;&gt;experiment2_drug.txt&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Expression levels for drug A in expt 2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div id=&#34;load-data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;11.2&lt;/span&gt; Load Data&lt;/h2&gt;
&lt;p&gt;First let’s load in the data:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;expt1_ctrl &amp;lt;- read.table(&amp;quot;experiment1_control.txt&amp;quot;, 
                         header = TRUE, sep = &amp;quot;\t&amp;quot;, 
                         stringsAsFactors = FALSE)
expt1_drug &amp;lt;- read.table(&amp;quot;experiment1_drug.txt&amp;quot;, 
                         header = TRUE, sep = &amp;quot;\t&amp;quot;, 
                         stringsAsFactors = FALSE)
expt2_ctrl &amp;lt;- read.table(&amp;quot;experiment2_control.txt&amp;quot;, 
                         header = TRUE, sep = &amp;quot;\t&amp;quot;, 
                         stringsAsFactors = FALSE)
expt2_drug &amp;lt;- read.table(&amp;quot;experiment2_drug.txt&amp;quot;, 
                         header = TRUE, sep = &amp;quot;\t&amp;quot;, 
                         stringsAsFactors = FALSE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Use &lt;code&gt;head()&lt;/code&gt; to look at the data. Each of these files contains two columns; the gene name and some value that represents the expression level for that gene (assume that these values have been calculated after pre-processing, normalisation, etc.).&lt;/p&gt;
&lt;p&gt;In all of these cases, the list of gene names is identical, and in the same order which means that we could compare row 1 from the control-treated file with row 2 from the drug-treated file to get all of the comparisons. However, in a real data set you will not know for sure that the gene names match so I recommend merging the files together into a single data frame to ensure that all analyses are conducted on a gene by gene basis on the correct values.&lt;/p&gt;
&lt;p&gt;We therefore create a single data frame for both experiments using the merge() command:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;expt1 &amp;lt;- merge(expt1_ctrl, expt1_drug, 
               by = &amp;quot;GeneName&amp;quot;) ## The &amp;#39;by&amp;#39; variable tells merge which column to merge
names(expt1)[2] &amp;lt;- &amp;quot;Control&amp;quot; 
names(expt1)[3] &amp;lt;- &amp;quot;Drug&amp;quot; 
expt2 &amp;lt;- merge(expt2_ctrl, expt2_drug, 
               by = &amp;quot;GeneName&amp;quot;) 
names(expt2)[2] &amp;lt;- &amp;quot;Control&amp;quot;
names(expt2)[3] &amp;lt;- &amp;quot;Drug&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;calculate-fold-change&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;11.3&lt;/span&gt; Calculate Fold Change&lt;/h2&gt;
&lt;p&gt;Now we calculate the fold change for each gene by dividing the drug-treated expression by the control expression. To avoid divide by zero errors, we can set a minimum expression value. This will also ensure that we are only looking at expression changes between significant expression values. Since we want to do the same thing to both the experiment 1 and the experiment 2 data sets, it makes sense to write a single function to use for both:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_fold_change &amp;lt;- function (x, min_expression = 10) {
  ctrl_val &amp;lt;- as.numeric(x[&amp;quot;Control&amp;quot;]) 
  drug_val &amp;lt;- as.numeric(x[&amp;quot;Drug&amp;quot;])
  ctrl_val &amp;lt;- ifelse(ctrl_val &amp;lt;= min_expression, min_expression, ctrl_val)
  drug_val &amp;lt;- ifelse(drug_val &amp;lt;= min_expression, min_expression, drug_val)
  return(drug_val/ctrl_val) 
}
expt1[[&amp;quot;FoldChange&amp;quot;]] &amp;lt;- apply(expt1, MAR = 1, FUN = get_fold_change) 
expt2[[&amp;quot;FoldChange&amp;quot;]] &amp;lt;- apply(expt2, MAR = 1, FUN = get_fold_change)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;compare-data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;11.4&lt;/span&gt; Compare Data&lt;/h2&gt;
&lt;p&gt;Now let’s find the genes that are upregulated and downregulated in each experiment. Due to the lack of replicates, we do not have any estimate for the variance of these genes, so we will have to make do with using a threshold on the fold change:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fold_change_threshold &amp;lt;- 1.5
expt1_up   &amp;lt;- subset(expt1, FoldChange &amp;gt;= fold_change_threshold)[[&amp;quot;GeneName&amp;quot;]]
expt1_down &amp;lt;- subset(expt1, FoldChange &amp;lt;= 1/fold_change_threshold)[[&amp;quot;GeneName&amp;quot;]]
expt2_up   &amp;lt;- subset(expt2, FoldChange &amp;gt;= fold_change_threshold)[[&amp;quot;GeneName&amp;quot;]]
expt2_down &amp;lt;- subset(expt2, FoldChange &amp;lt;= 1/fold_change_threshold)[[&amp;quot;GeneName&amp;quot;]]
cat(&amp;quot;Upregulated in Experiment 1:&amp;quot;,   paste(expt1_up,   collapse = &amp;quot;\n&amp;quot;), sep = &amp;quot;\n&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Upregulated in Experiment 1:
## gene12
## gene8&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cat(&amp;quot;Downregulated in Experiment 1:&amp;quot;, paste(expt1_down, collapse = &amp;quot;\n&amp;quot;), sep = &amp;quot;\n&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Downregulated in Experiment 1:
## gene32
## gene46&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cat(&amp;quot;Upregulated in Experiment 2:&amp;quot;,   paste(expt2_up,   collapse = &amp;quot;\n&amp;quot;), sep = &amp;quot;\n&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Upregulated in Experiment 2:
## gene18
## gene50
## gene8&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cat(&amp;quot;Downregulated in Experiment 2:&amp;quot;, paste(expt2_down, collapse = &amp;quot;\n&amp;quot;), sep = &amp;quot;\n&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Downregulated in Experiment 2:
## gene22
## gene43&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So we now have the genes that change when each of the drugs is used. But now we want to compare the two drugs together. First, let’s see if there are any genes similarly affected by both drugs. We can do this using the &lt;code&gt;intersect()&lt;/code&gt; function which gives the intersect of two lists:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;common_up   &amp;lt;- intersect(expt1_up, expt2_up) 
common_down &amp;lt;- intersect(expt1_down, expt2_down)
cat(&amp;quot;Upregulated in Experiment 1 and Experiment 2:&amp;quot;, paste(common_up, collapse = &amp;quot;\n&amp;quot;), sep = &amp;quot;\n&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Upregulated in Experiment 1 and Experiment 2:
## gene8&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cat(&amp;quot;Downregulated in Experiment 1 and Experiment 2:&amp;quot;, paste(common_down, collapse = &amp;quot;\n&amp;quot;), sep = &amp;quot;\n&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Downregulated in Experiment 1 and Experiment 2:&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So we can see that only one gene is similarly affected by both drugs (“gene8”). Now let’s plot a figure to see how the fold change differs between the two drugs:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fold_change_data &amp;lt;- merge(expt1[, c(&amp;quot;GeneName&amp;quot;, &amp;quot;FoldChange&amp;quot;)], 
                          expt2[, c(&amp;quot;GeneName&amp;quot;, &amp;quot;FoldChange&amp;quot;)], 
                          by = &amp;quot;GeneName&amp;quot;)
names(fold_change_data)[2] &amp;lt;- &amp;quot;Experiment1&amp;quot;
names(fold_change_data)[3] &amp;lt;- &amp;quot;Experiment2&amp;quot;
plot(x = log2(fold_change_data[[&amp;quot;Experiment1&amp;quot;]]), 
     y = log2(fold_change_data[[&amp;quot;Experiment2&amp;quot;]]), 
     pch = 19,
     xlab = &amp;quot;log2(Experiment1 Fold Change)&amp;quot;,
     ylab = &amp;quot;log2(Experiment2 Fold Change)&amp;quot;,
     main = &amp;quot;Experiment1 Fold Change vs Experiment2 Fold Change&amp;quot;, 
     cex.lab = 1.3,
     cex.axis = 1.2,
     cex.main = 1.4,
     xlim = c(-2,2),
     ylim = c(-2,2)
     )
abline(h = 0) 
abline(v = 0)
abline(a = 0, b = 1, lty = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/resources/RTutorial/index_files/figure-html/foldchange-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;This figure shows that the effect on the gene expression is actually quite different for the two drugs. We can also see this by looking at the correlation between the two experiments:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cor(x = fold_change_data[[&amp;quot;Experiment1&amp;quot;]], 
    y = fold_change_data[[&amp;quot;Experiment2&amp;quot;]], 
    method = &amp;quot;pearson&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.08381614&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cor(x = fold_change_data[[&amp;quot;Experiment1&amp;quot;]], 
    y = fold_change_data[[&amp;quot;Experiment2&amp;quot;]], 
    method = &amp;quot;spearman&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] -0.02618115&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
