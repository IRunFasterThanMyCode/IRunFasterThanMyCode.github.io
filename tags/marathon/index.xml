<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Marathon | IRunFasterThanMyCode</title>
    <link>/tags/marathon/</link>
      <atom:link href="/tags/marathon/index.xml" rel="self" type="application/rss+xml" />
    <description>Marathon</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>© 2017 Sam Robson</copyright><lastBuildDate>Tue, 24 Apr 2018 00:00:00 +0000</lastBuildDate>
    <image>
      <url>/img/irunfasterthanmycode.jpg</url>
      <title>Marathon</title>
      <link>/tags/marathon/</link>
    </image>
    
    <item>
      <title>How Predictable Are Ultra Runners?</title>
      <link>/post/2018-04-24-how-predictable-are-ultrarunners/</link>
      <pubDate>Tue, 24 Apr 2018 00:00:00 +0000</pubDate>
      <guid>/post/2018-04-24-how-predictable-are-ultrarunners/</guid>
      <description>

&lt;h1 id=&#34;note&#34;&gt;Note&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;This blog post was originally written in 2017 for a less formal personal blog with a focus on ultramarathon running, which is a hobby that I am quite passionate about. I have decided to include all of my data science related blog posts here to keep things centralised, but please excuse the more informal language used throughout.&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;This post is a continuation from my &lt;a href=&#34;/post/2018-04-18-Suunto-Or-Garmin/index.html&#34;&gt;previous post&lt;/a&gt;, looking at various aspects of the posting habits of the Ultra Running Community (URC). This was originally intended to be just an additional section in that blog post, but it was getting a little unwieldy so I decided to split it off into its own post to stop it from getting too crazy. This post is probably a lot less interesting than the last post, as it is really looking at one central question; can I predict which group member is posting based on the content of the message? Spoiler alert, you can&amp;rsquo;t! The posters on this forum are apparently &lt;em&gt;all&lt;/em&gt; sarcastic bastards, so it is difficult to pick them apart. But it was quite interesting trying.&lt;/p&gt;

&lt;p&gt;So as a bit of an experiment, I decided to play around with these data to see if the language that people use in their posts is specific enough to allow us to predict who has written something based on what the post says. This is a job for &lt;em&gt;machine-learning&lt;/em&gt;, which is really a lot less grandiose than it sounds. Essentially what we are doing here is using data to train a model of some description that can be applied to a new set of data to make predictions. In this case, we are looking to fit a model that is able to classify posts into one of a number of groups, where each group represents a single user. As an example of a classification problem, think of the spam filter in your email client. This is essentially a model that has been trained to look at the email message content and determine whether it is spam or not (e.g. if it is full of words like &lt;em&gt;viagra&lt;/em&gt;, &lt;em&gt;Nigerian Prince&lt;/em&gt;, &lt;em&gt;penis enlargement&lt;/em&gt;, &lt;em&gt;make money today&lt;/em&gt;, etc. then it is clearly all kosher). This would be a 2-class classification problem.&lt;/p&gt;

&lt;p&gt;For classification problems such as this, we require a training set on which to fit our model, and a validation set to determine the quality of the model. The validation set must be independent of the training set, as we want to test how the model will generalize to new data. The idea of &lt;em&gt;cross validation&lt;/em&gt; is essentially to split your training data into a training set and a validation set such that the validation is independent of the model fitting (to avoid the effects of over-fitting in the training set). There are various ways to split your data in this way. For now I will simply randomly select a subset for training and a smaller subset for validation (the &lt;em&gt;Holdout Method&lt;/em&gt;), but for true cross-validation this should then be repeated several times so that the average over several validation sets is used. For example, in &lt;em&gt;k-fold cross validation&lt;/em&gt; you would randomly distribute the data into &lt;code&gt;k&lt;/code&gt; equally sized subsets, and use exactly one of these as the validation set and &lt;code&gt;k-1&lt;/code&gt; as the training set. This is then repeated &lt;code&gt;k&lt;/code&gt; times, each time using a different subset as the validation set.&lt;/p&gt;

&lt;p&gt;It makes sense to restrict this analysis to the most active posters, and so I will limit the analysis to only users who have contributed 50 or more posts to the forum. This gives us 5,233 posts, from 48 users. I will randomly select 4,000 posts for the training set, and use the remainder for validation:&lt;/p&gt;

&lt;p&gt;{% highlight r %}
posts50 &amp;lt;- URC                 %&amp;gt;%
           group_by(from_name) %&amp;gt;%    ## Group by poster
           filter(n() &amp;gt;= 50)   %&amp;gt;%    ## Select only posters with &amp;gt;50 posts
           select(from_name, message) ## Keep poster name and message content
set.seed(0) ## Set seed for random number generation for reproducibility
ids   &amp;lt;- sample(1:nrow(posts50), 4000) ## Randomly select 4000
train &amp;lt;- posts50[ids,]  ## Keep random ids as training set
test  &amp;lt;- posts50[-ids,] ## Use remaining ids as validation
{% endhighlight %}&lt;/p&gt;

&lt;h1 id=&#34;natural-language-programming&#34;&gt;Natural Language Programming&lt;/h1&gt;

&lt;p&gt;The model that we will be using is the &lt;a href=&#34;https://en.wikipedia.org/wiki/Bag-of-words_model&#34; target=&#34;_blank&#34;&gt;Bag Of Words&lt;/a&gt; model, which is a natural language programming technique that aims to represent text based on the frequency of words within it. There are some things that we can do to reduce the vector space of available terms, such as removing capital letters and removing so called &amp;ldquo;stop words&amp;rdquo; (common words like &amp;ldquo;is&amp;rdquo;, &amp;ldquo;and&amp;rdquo;, &amp;ldquo;but&amp;rdquo;, &amp;ldquo;the&amp;rdquo;, etc.). We can also limit the analysis to only words that occur frequently in the text, although there is a possibility of missing specific terms used by only one or two individuals, say, that may help the predictiveness of the model.&lt;/p&gt;

&lt;p&gt;I will be using the &lt;a href=&#34;https://cran.r-project.org/web/packages/text2vec&#34; target=&#34;_blank&#34;&gt;text2vec&lt;/a&gt; package in R which is efficient at generating the required document-term matrix (DTM) for fitting our model. In particular, it generates unique tokens for each term rather than using the terms themselves, which reduces computational overheads. An iterative function can then be applied to generate the DTM. So let&amp;rsquo;s generate such an iterator over the term tokens:&lt;/p&gt;

&lt;p&gt;{% highlight r %}
library(text2vec)
train_tokens &amp;lt;- train$message                      %&amp;gt;%
                iconv(&amp;ldquo;latin1&amp;rdquo;, &amp;ldquo;ASCII&amp;rdquo;, sub = &amp;ldquo;&amp;rdquo;) %&amp;gt;% # Convert to ASCII format
                tolower                            %&amp;gt;% # Make lower case
                word_tokenizer                         # Break terms into tokens
it_train &amp;lt;- itoken(train_tokens, ids = train$from_name, progressbar = FALSE)
it_train
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;{% highlight text %}&lt;/p&gt;

&lt;h2 id=&#34;itoken&#34;&gt;&lt;itoken&gt;&lt;/h2&gt;

&lt;h2 id=&#34;inherits-from-iterator&#34;&gt;Inherits from: &lt;iterator&gt;&lt;/h2&gt;

&lt;h2 id=&#34;public&#34;&gt;Public:&lt;/h2&gt;

&lt;h2 id=&#34;chunk-size-400&#34;&gt;chunk_size: 400&lt;/h2&gt;

&lt;h2 id=&#34;clone-function-deep-false&#34;&gt;clone: function (deep = FALSE)&lt;/h2&gt;

&lt;h2 id=&#34;counter-0&#34;&gt;counter: 0&lt;/h2&gt;

&lt;h2 id=&#34;ids-nici-griffin-tremayne-dill-cowdry-iain-edward-smuts-neil&#34;&gt;ids: Nici Griffin Tremayne Dill Cowdry Iain Edward Smuts Neil &amp;hellip;&lt;/h2&gt;

&lt;h2 id=&#34;initialize-function-iterable-ids-null-chunks-number-10-progress-interactive&#34;&gt;initialize: function (iterable, ids = NULL, chunks&lt;em&gt;number = 10, progress&lt;/em&gt; = interactive(),&lt;/h2&gt;

&lt;h2 id=&#34;is-complete-active-binding&#34;&gt;is_complete: active binding&lt;/h2&gt;

&lt;h2 id=&#34;iterable-list&#34;&gt;iterable: list&lt;/h2&gt;

&lt;h2 id=&#34;length-active-binding&#34;&gt;length: active binding&lt;/h2&gt;

&lt;h2 id=&#34;nextelem-function&#34;&gt;nextElem: function ()&lt;/h2&gt;

&lt;h2 id=&#34;preprocessor-list&#34;&gt;preprocessor: list&lt;/h2&gt;

&lt;h2 id=&#34;progress-false&#34;&gt;progress: FALSE&lt;/h2&gt;

&lt;h2 id=&#34;progressbar-null&#34;&gt;progressbar: NULL&lt;/h2&gt;

&lt;h2 id=&#34;tokenizer-list&#34;&gt;tokenizer: list&lt;/h2&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Next we use this iterator to create a vocabulary DTM for fitting the model. To start with, I will use all of the words, but later we could look at filtering out stop words and less frequent terms:&lt;/p&gt;

&lt;p&gt;{% highlight r %}
vocab      &amp;lt;- create_vocabulary(it_train)
vectorizer &amp;lt;- vocab_vectorizer(vocab)
train_dtm  &amp;lt;- create_dtm(it_train, vectorizer)
dim(train_dtm)
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;{% highlight text %}&lt;/p&gt;

&lt;h2 id=&#34;1-4000-13209&#34;&gt;[1]  4000 13209&lt;/h2&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;The result is a matrix with 4,000 rows (the number of messages in the training set) and 13,209 columns (the number of unique terms in the training set). So each message is now represented as a vector of counts for all possible terms in the search space. The hope now is that we will be able to fit a model that is able to discriminate different users based on their word usage. Unlikely, but hey let&amp;rsquo;s give it a shot.&lt;/p&gt;

&lt;h1 id=&#34;random-forest&#34;&gt;Random Forest&lt;/h1&gt;

&lt;p&gt;In this case, our dependent variable is the name of the user who posted the message which is a categorical variable. The independent variables are the counts for each of the 13,209 terms across the data set. I am going to start by using a random forest model, which is one of the more popular classification models available. A decision tree is a quite simple (although incredibly powerful) stepwise model that you can think of like a flow chart. The model fitting will create a series of nodes where your independent variables are used to discrimate between one choice and another, eventually leading to a certain prediction depending on the values of the variables in your model. A random forest essentially fits a whole load of these classification decision trees and outputs the &lt;em&gt;modal&lt;/em&gt; (most common) class across all of them.&lt;/p&gt;

&lt;p&gt;One benefit of using random forests over something like generalised linear models (see later) is that, since they rely on fairly independent tests at each stage in the tree, they are more robust to correlated variables in the model. With such a large set of term variables there is undoubtedly correlation between many of these terms, particularly as many of these variables are likely to be largely made of zeroes. Of course, this sparsity itself causes somewhat of a problem, and should be taken into account in the analysis. But for now I will ignore it and just hope that it isn&amp;rsquo;t a problem&amp;hellip;&lt;/p&gt;

&lt;p&gt;To begin with,let&amp;rsquo;s fit a simple random forest model and see how it looks:&lt;/p&gt;

&lt;p&gt;{% highlight r %}
library(&amp;ldquo;randomForest&amp;rdquo;)
rf_model &amp;lt;- randomForest(x = as.matrix(train_dtm), y = as.factor(rownames(train_dtm)))
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Note that I set the &lt;code&gt;y&lt;/code&gt; parameter to be a factor so that it is clear that this is a classification model. Now we can test our model by seeing how it performs at predicting the user for our test data set. First we generate a similar DTM for the test data set. Note that we use the same &lt;code&gt;vectorizer&lt;/code&gt; as we used for the training set:&lt;/p&gt;

&lt;p&gt;{% highlight r %}
test_tokens &amp;lt;- test$message                       %&amp;gt;%
               iconv(&amp;ldquo;latin1&amp;rdquo;, &amp;ldquo;ASCII&amp;rdquo;, sub = &amp;ldquo;&amp;rdquo;) %&amp;gt;% # Convert to ASCII format
               tolower                            %&amp;gt;% # Make lower case
               word_tokenizer                         # Break terms into tokens
it_test     &amp;lt;- itoken(test_tokens, ids = test$from_name, progressbar = FALSE)
test_dtm    &amp;lt;- create_dtm(it_test, vectorizer)
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;And then we use our model to predict the user for each of the posts in our test data set. To do this we use the &lt;code&gt;predict()&lt;/code&gt; method for &lt;code&gt;randomForest&lt;/code&gt; objects, and output the response class with the majority vote amongst all of the decision trees:&lt;/p&gt;

&lt;p&gt;{% highlight r %}
test_predict &amp;lt;- predict(rf_model, as.matrix(test_dtm), type = &amp;ldquo;response&amp;rdquo;)
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;So, how did we do? Let&amp;rsquo;s see how many of these were correctly predicted:&lt;/p&gt;

&lt;p&gt;{% highlight r %}
table(test_predict == rownames(test_dtm))
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;{% highlight text %}&lt;/p&gt;

&lt;h2 id=&#34;false-true&#34;&gt;FALSE  TRUE&lt;/h2&gt;

&lt;h2 id=&#34;760-473&#34;&gt;760   473&lt;/h2&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;This model predicts the poster only 38.4 % of the time, which isn&amp;rsquo;t particularly good.&lt;/p&gt;

&lt;h1 id=&#34;model-improvements&#34;&gt;Model Improvements&lt;/h1&gt;

&lt;p&gt;So can we improve this? Yes, probably. The first thing that I can try is to be a little more clever in the way that I parameterise the data. So rather than simply counting words, I will instead use &lt;em&gt;n-grams&lt;/em&gt; &amp;ndash; combinations of &lt;code&gt;n&lt;/code&gt; words that will be more sensitive to the types of phrases that different people typically use. Obviously increasing &lt;code&gt;n&lt;/code&gt; in this case will also increase the memory and run time considerably, so there are limits to what we can feasibly do. Also, it is probably worth noting that removal of stop words is less likely to be the best way to go about this, as this will affect the structure of the n-grams. So this time let us leave the stop words in, but parameterise with &lt;code&gt;3-grams&lt;/code&gt;. I will also limit the count to those n-grams used at least 10 times:&lt;/p&gt;

&lt;p&gt;{% highlight r %}
vocab &amp;lt;- create_vocabulary(it_train, ngram = c(1L, 3L)) ## use 1-, 2- and 3-grams
vocab &amp;lt;- vocab %&amp;gt;%
         prune_vocabulary(term_count_min = 10) ## Only keep n-grams with count greater than 10
vectorizer &amp;lt;- vocab_vectorizer(vocab)
dtm_train  &amp;lt;- create_dtm(it_train, vectorizer)
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Note here that we used the notation &lt;code&gt;1L, 3L&lt;/code&gt;, which tells &lt;code&gt;R&lt;/code&gt; to explicitly use integer values rather than numeric values. In many cases this has little to no effect, but in programming an integer variable will take up much less memory (4 bytes per element) than a double precision floating point number (8 bytes per element).&lt;/p&gt;

&lt;p&gt;Another thing that we can do to improve the model fit is that we can attempt to normalise our DTM to account for the fact that different Facebook messages may be longer or shorter than others. Typically the &amp;ldquo;documents&amp;rdquo; in this case (the messages) are very small so I imagine this will have only a minimal effect. Here I will use the &lt;em&gt;term frequency-inverse document frequency&lt;/em&gt; (TF-IDF) transformation. The idea here is to not only normalise the data, but also to scale the terms such that terms that are more common (i.e. those used regularly in all posts) are down-weighted, whilst those that are more specific to a small number of users (and will thus be more predictive) are up-weighted.&lt;/p&gt;

&lt;p&gt;{% highlight r %}
tfidf           &amp;lt;- TfIdf$new()
train_dtm_tfidf &amp;lt;- fit_transform(train_dtm, tfidf)
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Finally there is some fine tunning that can be made to the model fitting procudure. Here we are dealing with a very sparse set of data, since most of the counts are zero in this matrix (not everybody uses every word or set of words). This can cause issues with the random forest model. In addition, there may be some imbalance in the classes (for instance as we saw above different individuals post more often than others).&lt;/p&gt;

&lt;p&gt;Now I don&amp;rsquo;t claim to be an expert in machine learning, and random forests in particular are not my forte. However, different selections for the parameters can have big effects on the quality of the model. The two main parameters for a random forest are the number of trees (&lt;code&gt;ntree&lt;/code&gt;) and the number of features that are evaluated at each branch in the trees (&lt;code&gt;mtry&lt;/code&gt;). The higher the better for the number of trees, although run-time can be a hindrance on this. For the second parameter, I have seen it suggested that the square root of the number of features is a good place to start, and this is the default for classification anyway. So let&amp;rsquo;s try increasing the number of trees, and running this on the TF-IDF transformed 3-gram data:&lt;/p&gt;

&lt;p&gt;{% highlight r %}
rf_model_tfidf &amp;lt;- randomForest(x = as.matrix(train_dtm_tfidf),
                               y = as.factor(rownames(train_dtm_tfidf)),
                               ntree = 1000)
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;One note to make here is that this is slllllllloooooooooowwwwwwwwww! This needed to be run overnight to finish. Using something like python is probably a better bet when running machine learning algorithms like this, and I will probably do another post later in the future to look at some alternative ways to do this.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s take a look at whether or not this model is more effective at predicting the user:&lt;/p&gt;

&lt;p&gt;{% highlight r %}
dtm_test       &amp;lt;- create_dtm(it_test, vectorizer)
test_dtm_tfidf &amp;lt;- fit_transform(test_dtm, tfidf)
test_predict &amp;lt;- predict(rf_model_tfidf, as.matrix(test_dtm_tfidf), type = &amp;ldquo;response&amp;rdquo;)
table(test_predict == rownames(test_dtm))
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;{% highlight text %}&lt;/p&gt;

&lt;h2 id=&#34;false-true-1&#34;&gt;FALSE  TRUE&lt;/h2&gt;

&lt;h2 id=&#34;751-482&#34;&gt;751   482&lt;/h2&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Wow, so now we have improved the prediction to a whopping 39.1%. Hmm. An improvement of 0.7% was not &lt;em&gt;quite&lt;/em&gt; as much as I was hoping for.&lt;/p&gt;

&lt;h1 id=&#34;logistic-regression&#34;&gt;Logistic Regression&lt;/h1&gt;

&lt;p&gt;Okay, so let&amp;rsquo;s try a different model to see if that has any effect. I am going to fit a &lt;a href=&#34;https://en.wikipedia.org/wiki/Logistic_regression&#34; target=&#34;_blank&#34;&gt;logistic regression&lt;/a&gt;. Regression is simply an attempt to fit a linear approximation to a set of data that minimises the difference between the modeled value and the true value (the &lt;em&gt;residuals&lt;/em&gt;). I will do a more thorough post on statistical modelling in the future, but for now think of regression models as being an attempt to fit a line of best fit between some variable $y$ that you suspect is dependent on some other variables $x_1, x_2, &amp;hellip;, x_n$. The idea then is to use this model to predict $y$ based on new measurements of $x_1, x_2, &amp;hellip;, x_n$. So here we are trying to fit a model that will provide us with an estimate of the user based on the words used in the post.&lt;/p&gt;

&lt;p&gt;Here I will use the &lt;a href=&#34;https://cran.r-project.org/web/packages/glmnet/index.html&#34; target=&#34;_blank&#34;&gt;glmnet&lt;/a&gt; package to fit the logistic regression. Logistic regression is a subset of Generalised Linear Models (GLM), which are an extension of ordinary linear regression allowing for errors that are not normally distributed through the use of a link function. Since we have multiple possible classes in the dependent variable, this will be a multinomial logistic regression:&lt;/p&gt;

&lt;p&gt;{% highlight r %}
library(&amp;ldquo;glmnet&amp;rdquo;)
glm_model_tfidf &amp;lt;- cv.glmnet(x = train_dtm_tfidf, y = as.factor(train$from_name),
                              family = &amp;lsquo;multinomial&amp;rsquo;,
                              alpha = 1,
                              type.measure = &amp;ldquo;deviance&amp;rdquo;,
                              nfolds = 5,
                              thresh = 1e-3,
                              maxit = 1e3)
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;This is an n-fold cross-validated GLM (hence &lt;code&gt;cv.glmnet&lt;/code&gt;), which is a method of validation for the model that splits the data into &lt;code&gt;n&lt;/code&gt; equally sized subsets, then uses &lt;code&gt;n-1&lt;/code&gt; subsets as training data and the remaining subset as the validation data to test the accuracy of the model. This is repeated &lt;code&gt;n&lt;/code&gt; times, and the average is used. This is actually a better method than I have used in these data (selecting a test data set and running the model on the remaining subset) as every sample is used in the validation, which avoids over-fitting.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;family&lt;/code&gt; parameter gives the model family that defines the error model, which in turn determines the link function to be used. In this case we are using multinomial logistic regression, so the predicted response is a vector of probabilities between 0 and 1 &amp;ndash; one for each potential response &amp;ndash; all adding to 1. The link function, which defines the relationship between the linear predictor and the mean of the distribution function, is the &lt;code&gt;logit&lt;/code&gt; function, which in the binary case gives the log odds of the prediction ($X\beta = ln (\mu/(1-\mu)$).&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;alpha&lt;/code&gt; value will utilise an L1 regularisation of the data to account for the sparsity that we see in the data. The &lt;code&gt;type.measure&lt;/code&gt; value determines the measurement to use to determine the cross validation, in this case the misclassification error. &lt;code&gt;nfolds&lt;/code&gt; gives the value of &lt;code&gt;k&lt;/code&gt; for the k-fold cross validation, &lt;code&gt;thresh&lt;/code&gt; gives the threshold for the convergence of the coordinate descent loop, and &lt;code&gt;maxit&lt;/code&gt; gives the maximum number of iterations to perform.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s see if this is any better:&lt;/p&gt;

&lt;p&gt;{% highlight r %}
test_predict &amp;lt;- predict(glm_model_tfidf, as.matrix(test_dtm_tfidf), type = &amp;ldquo;response&amp;rdquo;)
table(colnames(test_predict)[apply(test_predict, MAR = 1, which.max)] == rownames(test_dtm))
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;{% highlight text %}&lt;/p&gt;

&lt;h2 id=&#34;false-true-2&#34;&gt;FALSE  TRUE&lt;/h2&gt;

&lt;h2 id=&#34;752-481&#34;&gt;752   481&lt;/h2&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Nope. We still only see about 39% accurately assigned.&lt;/p&gt;

&lt;h1 id=&#34;discussion&#34;&gt;Discussion&lt;/h1&gt;

&lt;p&gt;Okay, so it is possible (highly probable?) that I have made some mistakes in this analysis, and that I could vastly improve the creation of the DTM, but I think it is more propbable that these posts are simply not distinct enough to determine individuals writing styles. I guess in a group with such a narrow focus, it is inevitable that people will be posting very similar content to one another. There is after all only so many ways to ask &amp;ldquo;Suunto or Garmin&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s examine why we are struggling to distinguish these posts in a little more detail. Below is a heatmap showing the probability for each of the 48 potential posters, predicted for all 1,233 of the posts in the validation data set. A heatmap is a kind of 3-dimensional plot, where colour is used to represent the third dimension. So the 48 potential posters are shown on the x-axis, the 1,233 posts are shown on the y-axis, and the magnitude of the estimated probability for user &lt;code&gt;i&lt;/code&gt; based on post &lt;code&gt;j&lt;/code&gt; is represented by a colour from red (0% probability) to white (100% probability). Note that here I have scaled the data using a square root so that smaller probabilities (which we expect to see) are more visible. The rows and columns are arranged such that more similar values are closer together.&lt;/p&gt;

&lt;p&gt;{% highlight r %}
library(&amp;ldquo;gplots&amp;rdquo;)
heatmap.2(sqrt(test_predict[,,1]), trace = &amp;ldquo;none&amp;rdquo;, margins = c(10,0), labRow = FALSE)
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;similar_posts.png&#34; alt=&#34;Heatmap showing similarity between posters on the URC Facebook group&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So the biggest problem here is that the vast majority of the posts are estimated as most likely coming from either Neil Bryant, Stef Schuermans or James Adams. And actually, the ones that it gets correct are almost all from one of these posters:&lt;/p&gt;

&lt;p&gt;{% highlight r %}
pie(sort(table(rownames(test_dtm)[colnames(test_predict)[apply(test_predict, MAR = 1, which.max)] == rownames(test_dtm)])))
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;similar_posts_pie.png&#34; alt=&#34;Pie chart showing the most active posters within the URC Facebook group&#34; /&gt;&lt;/p&gt;

&lt;p&gt;I wonder whether these guys are skewing the model because of their, ahem, above average posting habits. But frankly at this stage I&amp;rsquo;m kind of bored, so I think that I will leave it there. Another time maybe. Ultimately I believe that these posts are simply too short and bereft of salient information to be useful for making predictions.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Suunto Or Garmin? The Age Old Question.</title>
      <link>/post/2018-04-18-suunto-or-garmin/</link>
      <pubDate>Wed, 18 Apr 2018 00:00:00 +0000</pubDate>
      <guid>/post/2018-04-18-suunto-or-garmin/</guid>
      <description>

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#note&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1&lt;/span&gt; Note&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#introduction&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2&lt;/span&gt; Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rfacebook&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3&lt;/span&gt; Rfacebook&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#temporary-token&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.1&lt;/span&gt; Temporary Token&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#fboauth&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.2&lt;/span&gt; fbOAuth&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ultra-running-community&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4&lt;/span&gt; Ultra Running Community&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#likes-comments-and-shares&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;5&lt;/span&gt; Likes, Comments and Shares&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#top-contributors&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;6&lt;/span&gt; Top Contributors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#when-are-people-posting&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;7&lt;/span&gt; When are people posting?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#most-popular-posts&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;8&lt;/span&gt; Most Popular Posts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#how-often-do-people-actually-talk-about-ultras&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;9&lt;/span&gt; How Often Do People Actually Talk About Ultras?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#suunto-or-garmin&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;10&lt;/span&gt; Suunto or Garmin?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#summing-up&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;11&lt;/span&gt; Summing Up&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#session-info&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;12&lt;/span&gt; Session Info&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id=&#34;note&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;1&lt;/span&gt; Note&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;This blog post was originally written in 2017 for a less formal personal blog with a focus on ultramarathon running, which is a hobby that I am quite passionate about. I have decided to include all of my data science related blog posts here to keep things centralised, but please excuse the more informal language used throughout.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;introduction&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;2&lt;/span&gt; Introduction&lt;/h1&gt;
&lt;p&gt;In &lt;a href=&#34;/post/2018-04-15-ultrarunner-or-ultra-runner/&#34;&gt;my last post&lt;/a&gt;, I took a look at ways to pull data down from Twitter and analyse some specific trends. It was quite interesting for me to see how easy it is to access these data, and there is a huge amount to be gleened from these sorts of data. The idea of this post is to use a similar approach to pull data from the Ultra Running Community page on &lt;a href=&#34;https://www.facebook.com&#34;&gt;Facebook&lt;/a&gt;, and then to use these data to play around further with the &lt;code&gt;dplyr&lt;/code&gt;, &lt;code&gt;tidyr&lt;/code&gt; and &lt;code&gt;ggplot2&lt;/code&gt; R packages. Just for funsies, I’m also going to have a bit of a crack at some machine learning concepts. In particular, a question that seems to comes up pretty regularly is whether the best GPS watch for running is from &lt;a href=&#34;http://www.suunto.com&#34;&gt;Suunto&lt;/a&gt; or &lt;a href=&#34;https://www.garmin.com&#34;&gt;Garmin&lt;/a&gt;. I figured I could save us all some time and answer the question once and for all…&lt;/p&gt;
&lt;p&gt;Just a little aside here; I think that some people missed the point last time. I honestly don’t care much about these questions, they are just a jumping off point for me to practice some of the data analysis techniques that come up in my work. The best way to get better at something is to practice, so these posts are just a way of combining something I love with a more practical purpose. The idea of this blog is for me to practice these things until they become second nature. Of course in the process, I may just find something interesting along the way.&lt;/p&gt;
&lt;p&gt;Probably not though.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;rfacebook&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;3&lt;/span&gt; Rfacebook&lt;/h1&gt;
&lt;p&gt;Following on from my experiences playing around with the &lt;a href=&#34;https://twitter.com&#34;&gt;Twitter&lt;/a&gt; API, I decided to have a look to see if there were similar programmatic ways to access Facebook data. This can be accomplished using the &lt;a href=&#34;https://cran.r-project.org/web/packages/Rfacebook/&#34;&gt;Rfacebook&lt;/a&gt; package in R, which is very similar to the &lt;code&gt;TwitteR&lt;/code&gt; package that I used previously. This package accesses the Facebook &lt;a href=&#34;https://developers.facebook.com/docs/graph-api&#34;&gt;Graph API Explorer&lt;/a&gt;, allowing access to a huge amount of data from the Facebook social &lt;em&gt;graph&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;So first of all, let’s install the &lt;code&gt;Rfacebook&lt;/code&gt; package. We can install the stable version from the Comprehensive R Archive Network (&lt;a href=&#34;https://cran.r-project.org&#34;&gt;CRAN&lt;/a&gt;):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;install.packages(&amp;quot;Rfacebook&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or install the more up-to-date but less stable developmental version from Github:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(&amp;quot;devtools&amp;quot;)
install_github(&amp;quot;pablobarbera/Rfacebook/Rfacebook&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I am using the developmental version here. There are several additional packages that also need to be installed:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;install.packages(c(&amp;quot;httr&amp;quot;, &amp;quot;rjson&amp;quot;, &amp;quot;httpuv&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As with &lt;code&gt;TwitteR&lt;/code&gt;, access to the API is controlled through the use of API tokens. There are two ways of doing this - either by registering as a developer and generating an app as I did with &lt;code&gt;TwitteR&lt;/code&gt;, or through the use of a temporary token which gives you access for a limited period of 2 hours. Let’s look at each of these in turn:&lt;/p&gt;
&lt;div id=&#34;temporary-token&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.1&lt;/span&gt; Temporary Token&lt;/h2&gt;
&lt;p&gt;To generate a temporary token, just go to the &lt;a href=&#34;https://developers.facebook.com/tools/explorer/&#34;&gt;Graph API Explorer&lt;/a&gt; page and generate a new token by clicking on &lt;code&gt;Get Token&lt;/code&gt; -&amp;gt; &lt;code&gt;Get Access Token&lt;/code&gt;. You need to select the permissions that you want to grant access for, which will depend on what you are looking do:&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;Graph-API-Explorer.png&#34; alt=&#34;Create Temporary Access Token&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;Create Temporary Access Token&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;I just granted permission to everything for this analysis. Once you have an access token, this can be used as the &lt;code&gt;token&lt;/code&gt; parameter when using functions such as &lt;code&gt;getUsers()&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;fboauth&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.2&lt;/span&gt; fbOAuth&lt;/h2&gt;
&lt;p&gt;The above is the most simple method, but this access token will only last for 2 hours, at which point you will need to generate a new one. If you want a longer term solution, you can set up &lt;a href=&#34;https://en.wikipedia.org/wiki/OAuth&#34;&gt;Open Authorization&lt;/a&gt; access in a similar way to for the &lt;code&gt;TwitteR&lt;/code&gt; package. The downside is that you lose the ability to search friend networks unless your friends are also using the app that you generate - and I don’t want to inflict that on people just so that I can &lt;del&gt;steal their identity&lt;/del&gt; analyse their networks.&lt;/p&gt;
&lt;p&gt;This method is almost identical to the process used for generating the OAuth tokens in the &lt;code&gt;TwitteR&lt;/code&gt; app, and a good description of how to do it can be found in this &lt;a href=&#34;http://thinktostart.com/analyzing-facebook-with-r/&#34;&gt;blog post&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;However, I am feeling pretty lazy today and so I will just use the temporary method.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;ultra-running-community&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;4&lt;/span&gt; Ultra Running Community&lt;/h1&gt;
&lt;p&gt;With nearly 18,000 members, the Ultra Running Community Facebook page is a very active community of ultrarunners from around the world. Runners are able to ask questions, share blogs, and generally speak with like-minded individuals about everything from gear selection to how best to prevent chaffing when running. It’s been going since June 2012, so there are a fair few posts available to look through.&lt;/p&gt;
&lt;p&gt;So let’s load in all of the posts from the URC page:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(&amp;quot;Rfacebook&amp;quot;)
token &amp;lt;- &amp;quot;XXXXXX&amp;quot;  ## Insert your temporary token from Graph API Explorer
URC &amp;lt;- getGroup(&amp;quot;259647654139161&amp;quot;, token, n=50000)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This command will create an object of class &lt;code&gt;data.frame&lt;/code&gt; containing the most recent 50,000 posts available in the Facebook Group with ID &lt;code&gt;259647654139161&lt;/code&gt; (which is the internal ID for the Ultra Running Community page). The page was set up in June 2012 By Neil Bryant, and currently (as of 20th March 2017) contains a total of 24,836 posts. So this command will actually capture every single post.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;data.frame&lt;/code&gt; is somewhat of the workhorse of R, and looks to the user like a spreadsheet like you would expect to see in Excel. Behind the scene it is actually a list of lists, with each column representing a particular measurement or descriptive annotation of that particular datum. The ideal situation is to design your data frame such that every row is an individual measurement, and every column is some aspect relating to that measurement. This can sometimes go against the instinctual way that you might store data, but makes downstream analyses much simpler.&lt;/p&gt;
&lt;p&gt;As an example, suppose that you were measuring something (blood glucose levels, weight, lung capacity, VO2 max, etc.) at three times of the day for 2 individuals. Your natural inclination may be to design your table in this way:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th&gt;Sample&lt;/th&gt;
&lt;th&gt;Measurement 1&lt;/th&gt;
&lt;th&gt;Measurement 2&lt;/th&gt;
&lt;th&gt;Measurement 3&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Sample1&lt;/td&gt;
&lt;td&gt;0.3&lt;/td&gt;
&lt;td&gt;0.4&lt;/td&gt;
&lt;td&gt;0.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;Sample2&lt;/td&gt;
&lt;td&gt;0.6&lt;/td&gt;
&lt;td&gt;0.6&lt;/td&gt;
&lt;td&gt;0.7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;But actually the optimum way to represent this is to treat each measurement as a different row in your data table, and use a descriptive categorical variable to represent the repeated measurements:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th&gt;Sample&lt;/th&gt;
&lt;th&gt;Measurement&lt;/th&gt;
&lt;th&gt;Replicate&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Sample1&lt;/td&gt;
&lt;td&gt;0.3&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;Sample1&lt;/td&gt;
&lt;td&gt;0.4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Sample1&lt;/td&gt;
&lt;td&gt;0.3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;Sample2&lt;/td&gt;
&lt;td&gt;0.6&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Sample2&lt;/td&gt;
&lt;td&gt;0.6&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;Sample2&lt;/td&gt;
&lt;td&gt;0.7&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;You can then add additional information relating to each individual measurement, which can be factored into your model down the line.&lt;/p&gt;
&lt;p&gt;In this case, we have a data frame where each row is a post on the URC feed, and each column gives you information on the post such as who wrote it, what the post says, when it was written, any links involved, and how many likes, comments and shares each post has. We can take a quick look at what the data.frame looks like by using the &lt;code&gt;str()&lt;/code&gt; function. This will tell us a little about each column, such as the data format (character, numeric, logical, factor, etc.) and the first few entries in each column:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str(URC)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;data.frame&amp;#39;:    24836 obs. of  11 variables:
##  $ from_id       : chr  &amp;quot;10203232759527000&amp;quot; &amp;quot;10154582131480554&amp;quot; &amp;quot;10206266800967107&amp;quot; &amp;quot;10153499987966664&amp;quot; ...
##  $ from_name     : chr  &amp;quot;Steph Wade&amp;quot; &amp;quot;Esther Bramley&amp;quot; &amp;quot;Tom Chapman&amp;quot; &amp;quot;Polat Dede&amp;quot; ...
##  $ message       : chr  &amp;quot;Anyone who runs in Speedcross 3s tried Sportiva? I&amp;#39;ve had several pairs of Speedcross  but thinking about tryin&amp;quot;| __truncated__ &amp;quot;Hi guys server pain in knee two weeks after 41miler. Ran 3 miles Tuesday no problem. Pain started at 5m and got&amp;quot;| __truncated__ &amp;quot;mega depressed; need advice. Running really well over xmas, since then, painful hip &amp;amp; groin, chasing itb, glute&amp;quot;| __truncated__ NA ...
##  $ created_time  : chr  &amp;quot;2017-03-19T08:38:15+0000&amp;quot; &amp;quot;2017-03-18T12:19:26+0000&amp;quot; &amp;quot;2017-03-18T16:30:54+0000&amp;quot; &amp;quot;2017-03-19T08:42:38+0000&amp;quot; ...
##  $ type          : chr  &amp;quot;status&amp;quot; &amp;quot;status&amp;quot; &amp;quot;status&amp;quot; &amp;quot;photo&amp;quot; ...
##  $ link          : chr  NA NA NA &amp;quot;https://www.facebook.com/tahtaliruntosky/photos/a.659614340816057.1073741827.659609490816542/1145262965584523/?type=3&amp;quot; ...
##  $ id            : chr  &amp;quot;259647654139161_1064067560363829&amp;quot; &amp;quot;259647654139161_1063418100428775&amp;quot; &amp;quot;259647654139161_1063562803747638&amp;quot; &amp;quot;259647654139161_1064068937030358&amp;quot; ...
##  $ story         : logi  NA NA NA NA NA NA ...
##  $ likes_count   : num  0 0 0 0 0 2 2 58 7 1 ...
##  $ comments_count: num  5 23 9 0 25 9 4 64 77 12 ...
##  $ shares_count  : num  0 1 0 0 0 0 0 0 3 0 ...&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;likes-comments-and-shares&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;5&lt;/span&gt; Likes, Comments and Shares&lt;/h1&gt;
&lt;p&gt;The first step in any data analysis is to check that the data make sense. You’ve probably heard the old adage “garbage in; garbage out”, so data cleaning is an essential first step to ensure that we are not basing our conclusions on erroneous information from the beginning. There are far too many posts here to look at them all by hand, but there are a few things we can certainly have a look at to check that the values make sense.&lt;/p&gt;
&lt;p&gt;For instance, let’s take a look at the number of likes, comments and shares. We would expect all of these values to be positive whole numbers, so this is something that is easy to check. To do this, I will be making use of the &lt;a href=&#34;https://ggplot2.tidyverse.org&#34;&gt;ggplot2&lt;/a&gt; package, which allows for some incredibly powerful plotting in R. The idea is to define the plot in terms of &lt;em&gt;aesthetics&lt;/em&gt;, where different elements of the plot (x and y values, colour, size, shape, etc.) can be mapped to elements of your data.&lt;/p&gt;
&lt;p&gt;In this case I want to plot a distribution plot where the colour of the plot is mapped to whether we are looking at likes, comments or shares. To do this, I need to rearrange the data such that the &lt;code&gt;likes_count&lt;/code&gt;, &lt;code&gt;comments_count&lt;/code&gt; and &lt;code&gt;shares_count&lt;/code&gt; columns are in a single column &lt;code&gt;counts&lt;/code&gt;, with an additional column defining whether it is a like, a comment, or a share count (as described in the example above).&lt;/p&gt;
&lt;p&gt;I will use the &lt;a href=&#34;https://cran.r-project.org/web/packages/tidyr/tidyr.pdf&#34;&gt;tidyr&lt;/a&gt;, &lt;a href=&#34;https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html&#34;&gt;stringr&lt;/a&gt; and &lt;a href=&#34;https://cran.r-project.org/web/packages/dplyr/vignettes/introduction.html&#34;&gt;dplyr&lt;/a&gt; packages to rearrange the data:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(&amp;quot;tidyr&amp;quot;)
library(&amp;quot;dplyr&amp;quot;)
library(&amp;quot;stringr&amp;quot;)
like_comment_share &amp;lt;- URC                                                 %&amp;gt;% 
                      gather(count_type, count, likes_count:shares_count) %&amp;gt;%
                      select(count_type, count)
head(like_comment_share)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    count_type count
## 1 likes_count     0
## 2 likes_count     0
## 3 likes_count     0
## 4 likes_count     0
## 5 likes_count     0
## 6 likes_count     2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;tidyr&lt;/code&gt;, &lt;code&gt;stringr&lt;/code&gt; and &lt;code&gt;dplyr&lt;/code&gt; are incredibly powerful packages written by Hadley Wickham, which provide a simple to understand &lt;em&gt;grammar&lt;/em&gt; to apply to the filtering and tweaking of data frames in R. In particular, these can be used to convert the data into the &lt;em&gt;tidy&lt;/em&gt; format described above, allowing very simple and intuitive plotting with &lt;code&gt;ggplot2&lt;/code&gt;. One particularly useful feature is the ability to use the &lt;code&gt;%&amp;gt;%&lt;/code&gt; command to pipe the output to perform multiple data frame modifications.&lt;/p&gt;
&lt;p&gt;In the above code, we pipe the raw data &lt;code&gt;URC&lt;/code&gt; into the &lt;code&gt;gather()&lt;/code&gt; function, which will take the three columns from &lt;code&gt;likes_count&lt;/code&gt; through to &lt;code&gt;shares_count&lt;/code&gt; and split them into two new columns: &lt;code&gt;count_type&lt;/code&gt; which will be one of &lt;code&gt;shares_count&lt;/code&gt;, &lt;code&gt;likes_count&lt;/code&gt; and &lt;code&gt;comments_count&lt;/code&gt; , and &lt;code&gt;count&lt;/code&gt; which will take the value from the specified column. So essentially this produces a new data set with 3 times as many rows. This is then piped into &lt;code&gt;select()&lt;/code&gt; which will select the relevant columns.&lt;/p&gt;
&lt;p&gt;First let’s just check that they are are all positive integers as expected:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;all(like_comment_share$count == as.integer(like_comment_share$count))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;[1] TRUE&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;all(like_comment_share$count &amp;gt;= 0)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;[1] TRUE&lt;/p&gt;
&lt;p&gt;Annoyingly there is no easy way to check that a vector of numbers is made up of integers, so this line will check that the numbers do not change after converting to integers. Similarly, we use &lt;code&gt;all()&lt;/code&gt; to check that all of the counts are greater than or equal to zero. They are as we would hope.&lt;/p&gt;
&lt;p&gt;Then we can use &lt;code&gt;ggplot2&lt;/code&gt; for the plotting:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(&amp;quot;ggplot2&amp;quot;)
ggplot(like_comment_share, aes(x = log10(count+1), col = count_type, fill = count_type)) + 
  geom_density(alpha = 0.1) +
  labs(x = &amp;quot;Count (log10)&amp;quot;, y = &amp;quot;Density&amp;quot;) +
  theme(axis.text    = element_text(size = 16),
        axis.title   = element_text(size = 20),
        legend.text  = element_text(size = 18),
        legend.title = element_text(size = 24))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-04-18-Suunto-Or-Garmin/index_files/figure-html/2017-04-15-like_comment_share-1.png&#34; width=&#34;3000&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Here we use this output to plot a distribution plot showing the distribution of counts for the three different metrics – shares, comments and likes. We use the &lt;code&gt;count&lt;/code&gt; as the &lt;code&gt;x&lt;/code&gt; aesthetic, and &lt;code&gt;count_type&lt;/code&gt; as both the &lt;code&gt;col&lt;/code&gt; and &lt;code&gt;fill&lt;/code&gt; aesthetics to colour them. The main function &lt;code&gt;ggplot()&lt;/code&gt; will specify the aesthetics, and then we add additional elements to the plot by using the &lt;code&gt;+&lt;/code&gt; command. Here we add the &lt;code&gt;geom_density()&lt;/code&gt; element to plot the data in a density plot (the &lt;code&gt;alpha&lt;/code&gt; value will make the colours transparent for overplotting), the &lt;code&gt;labs()&lt;/code&gt; function will change the plot labels, and the &lt;code&gt;theme()&lt;/code&gt; function let’s you change aspects of the figure text, such as the size.&lt;/p&gt;
&lt;p&gt;Note that here I have plotted the &lt;span class=&#34;math inline&#34;&gt;\(log_{10}\)&lt;/span&gt; of the counts, which reduces the effects of outliers. Also note that I have added 1 to the counts. This is because &lt;span class=&#34;math inline&#34;&gt;\(log_{10}(0)\)&lt;/span&gt; is undefined. The idea here is that a count of 1 will get a value of 0, a count of 10 gets a value of 1, a count of 100 gets a value of 2, etc.&lt;/p&gt;
&lt;p&gt;So what does this tell us? Well not too much really. Not many people share posts from the page, but there aren’t too many that don’t get comments or likes. So it is a very active community. Posts tend to have more comments than likes, which makes sense because you can only like something once, but can comment as many times as you want. But the main thing that this shows is that these counts all seem to be in the right sort of expected range.&lt;/p&gt;
&lt;p&gt;Often exploratory plots like this can be useful to highlight problems in the raw data. One such example might be if a negative count existed in these data, which could happen due to input errors but quite clearly does not represent a valid count. As it happens, since these data are not manually curated, it is highly unlikely that such errors will be present, but you should never assume anything about any given data set.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;top-contributors&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;6&lt;/span&gt; Top Contributors&lt;/h1&gt;
&lt;p&gt;Let’s take a look at the all-time most common contributors to the page, again using the &lt;code&gt;ggplot2&lt;/code&gt; package:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;top_contributors &amp;lt;- URC              %&amp;gt;% 
                    count(from_name) %&amp;gt;%
                    top_n(50, n)     %&amp;gt;%
                    arrange(desc(n))
ggplot(top_contributors, 
       aes(x = factor(from_name, levels = top_contributors$from_name), 
           y = n,
           fill = n)) + 
  geom_bar(stat = &amp;quot;identity&amp;quot;) +
  scale_fill_gradient(low=&amp;quot;blue&amp;quot;, high=&amp;quot;red&amp;quot;) +
  labs(x = &amp;quot;&amp;quot;, y = &amp;quot;Number of Posts&amp;quot;) +
  theme(axis.title  = element_text(size = 18),
        axis.text.x = element_text(size = 12, angle = 45, hjust = 1),
        axis.text.y = element_text(size = 14),
        legend.position = &amp;quot;none&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-04-18-Suunto-Or-Garmin/index_files/figure-html/2017-04-15-contributors-1.png&#34; width=&#34;3000&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Here I have first used &lt;code&gt;dplyr&lt;/code&gt; to count up the number of posts per user and select the top 50 contributors, then used &lt;code&gt;ggplot2&lt;/code&gt; to plot a barplot showing the number of posts per person. I have used the &lt;code&gt;scale_fill_gradient()&lt;/code&gt; element to colour the bars based on their height, such that those with the highest number of posts are coloured red, whilst those with the lowest are coloured blue.&lt;/p&gt;
&lt;p&gt;The top contributor to the page is Neil Bryant (757 posts), who is the founder member so this makes sense. James Adams is the second biggest contributor (489 posts), and he has less of an excuse really.&lt;/p&gt;
&lt;p&gt;Let’s take a look at James’ posting habits:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(&amp;quot;xts&amp;quot;)
jamesadams &amp;lt;- URC                                                        %&amp;gt;%
              filter(from_name == &amp;quot;James Adams&amp;quot;)                         %&amp;gt;% 
              mutate(created_time = as.POSIXct(created_time))            %&amp;gt;%
              count(created_time)
jamesadams_xts &amp;lt;- xts(jamesadams$n, order.by = jamesadams$created_time)
jamesadams_month &amp;lt;- apply.monthly(jamesadams_xts, FUN = sum)
plot(jamesadams_month, ylab = &amp;quot;Number of Posts&amp;quot;, main = &amp;quot;&amp;quot;, cex.lab = 1.7, cex.axis = 1.4)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-04-18-Suunto-Or-Garmin/index_files/figure-html/2017-04-15-JamesAdams-1.png&#34; width=&#34;3000&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Here I have used the package &lt;code&gt;xts&lt;/code&gt; to deal with the &lt;code&gt;POSIXct&lt;/code&gt; date format. In particular this will deal correctly with months with zero counts. James has been pretty active since summer 2013 (probably publicising &lt;a href=&#34;https://www.amazon.com/Running-Stuff-James-Adams/dp/1784622621&#34;&gt;his book&lt;/a&gt;), but his activity has been on the decline throughout 2016 – the price you pay when your family size doubles I guess.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;when-are-people-posting&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;7&lt;/span&gt; When are people posting?&lt;/h1&gt;
&lt;p&gt;Next we can break the posts down by the day on which they are posted:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;URC      &amp;lt;- URC %&amp;gt;%
            mutate(dow = factor(weekdays(as.POSIXct(created_time)), labels = c(&amp;quot;Monday&amp;quot;, &amp;quot;Tuesday&amp;quot;, &amp;quot;Wednesday&amp;quot;, &amp;quot;Thursday&amp;quot;, &amp;quot;Friday&amp;quot;, &amp;quot;Saturday&amp;quot;, &amp;quot;Sunday&amp;quot;)))
post_day &amp;lt;- URC %&amp;gt;%
            count(dow)
ggplot(post_day, aes(x = dow, y = n, fill = dow)) + 
  geom_bar(stat = &amp;quot;identity&amp;quot;) + 
  labs(x = &amp;quot;&amp;quot;, y = &amp;quot;Number of Posts&amp;quot;) + 
  theme(axis.text.x = element_text(size = 20, angle = 45, hjust = 1),
        axis.text.y = element_text(size = 16),
        axis.title  = element_text(size = 20),
        legend.position = &amp;quot;none&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-04-18-Suunto-Or-Garmin/index_files/figure-html/2017-04-15-posting_day-1.png&#34; width=&#34;3000&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Similarly to previously, here I have used &lt;code&gt;dplyr&lt;/code&gt; to reduce the full data down to a table of counts of posts per day of the week, then plotted them using &lt;code&gt;ggplot2&lt;/code&gt;. Surprisingly (to me anyway) there is no increase in activity during the weekend. I guess most of us are checking Facebook during working hours and busy running at the weekend…&lt;/p&gt;
&lt;p&gt;Wednesdays are interestingly bereft of posts though for some reason. Could this be people checking URC at work on Monday and Tuesday through boredom, only to find themselves told off and having to catch up on work by Wedesday? Then by the time the weekend rolls around we’re all back liking away with impunity ready to go through the whole process again the next week.&lt;/p&gt;
&lt;p&gt;Let’s look at the same plot for the 1,000 most popular posts (based on likes):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;post_day &amp;lt;- URC                      %&amp;gt;%
            top_n(1000, likes_count) %&amp;gt;%
            count(dow)
ggplot(post_day, aes(x = dow, y = n, fill = dow)) + 
  geom_bar(stat = &amp;quot;identity&amp;quot;) + 
  labs(x = &amp;quot;&amp;quot;, y = &amp;quot;Number of Posts&amp;quot;) + 
  theme(axis.text.x = element_text(size = 20, angle = 45, hjust = 1),
        axis.text.y = element_text(size = 16),
        axis.title  = element_text(size = 20),
        legend.position = &amp;quot;none&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-04-18-Suunto-Or-Garmin/index_files/figure-html/2017-04-15-posting_day_most_likes-1.png&#34; width=&#34;3000&#34; /&gt;&lt;/p&gt;
&lt;p&gt;So from this it is clear that if you want people to like your post, you should post on a Tuesday or a Thursday. Quite why people might be feeling so much more likely to click that all important like button on these dayas, I have no idea. But hey, stats don’t lie.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;most-popular-posts&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;8&lt;/span&gt; Most Popular Posts&lt;/h1&gt;
&lt;p&gt;So looking at the popular posts above got me thinking about how best to actually define a “popular” post. Is it a post with a lot of likes, or a post that everybody is commenting on? Let’s take a look at the top 5 posts based on each criteria:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print.AsIs(URC %&amp;gt;% arrange(desc(likes_count)) %&amp;gt;% top_n(5, likes_count) %&amp;gt;% select(message))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;                                                                                                                                                                                                                                                                       message&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1 Thinking how far I’ve come and getting a bit emotional. .3 year ago i was a size 20/22 and couldnt run to end of the street. Yesterday i ran 30 mile as a training run and wasn’t even aching afterwards. Now nearly 45 and a size 10 and never felt better. I love my life!!!!
2 I saw this picture couple years ago and I found it very inspiring so I thought I’d share it. is a 12-year-old childhood cancer survivor who loves to run with his dad.
3 Not sure if swear words are accepted. 088208820882
4 “What you doing up here?” said the sheep.Pike last night, not a soul to be seen…
5 0880&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print.AsIs(URC %&amp;gt;% arrange(desc(comments_count)) %&amp;gt;% top_n(5, comments_count) %&amp;gt;% select(message))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   message&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1 For me claiming something you haven’t earned is not only immoral it’s fraudulent. And it’s a huge insult to all who’ve attempted the feat before you and legitimately fallen short. What do you guys think?
2 Anyone else do race to the stones and found it a rip off? I was not impressed with most things. were good such as medics and lots of water but who wants fudge bars and cadburies at aid stations. like a money making race to me, especially considering all the sponsorship they had. ’ve got lots of other rants about it but let’s hear anyone else’s thoughts first
3 New Game.am trying to convince some new ultra runners that you do not need to spend a load of money on kit to put one foot in front of the other a few more times. This is difficult given that half the posts in forums seems to be asking for recommendations or giving recommendations as to how one might waste money on kit.out of interest, what was the value of the kit you wore in your last ultra? Including nutrition. Obviously you will have to guess if you had them as a gift or can’t remember. Surely someone is going to have less than £100?
4 I had a small sabre rattling session last night with someone on this group. Nothing major by any stretch of the imagination - we just have opposing views on DNF. But it got me curios to what the opinions of others are on this subject. Is failing to finish something that you would risk your life to avoid? Is it something to fear? Is it something that will eventually happen to us all? Is it something that we can learn from? Etc,etc. Your thoughts please
5 i cannot wait to watch the EPSN footage - amazing stuff. It is a shame Robert has his doubters though.: was described as “trolling”, which was an over the top description (agree with the comments there)&lt;/p&gt;
&lt;p&gt;It seems to me that the posts with more likes tend to be posts with a much more positive message than those with most comments. The top liked posts are those from people who have overcome some form of adversity (such as the top liked post with 1,369 likes from Mandy Norris who had awesomely run 30 miles after losing half her body weight), whilst the top commented posts tend to be more controversial posts (such as the top commented post with 287 comments about Mark Vaz’s fraudulent JOGLE “World Record”).&lt;/p&gt;
&lt;p&gt;Let’s take a look at how closely these two poularity measures are correlated in the Ultra Running Community:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(URC, aes(x = comments_count, y = likes_count)) +
  geom_point(shape = 19, alpha = 0.2, size = 5) + 
  geom_smooth(method = &amp;quot;lm&amp;quot;, se = TRUE) +
  geom_point(data = URC %&amp;gt;% top_n(5, comments_count), aes(x = comments_count, y = likes_count, color = &amp;quot;red&amp;quot;, size = 5)) +
  geom_point(data = URC %&amp;gt;% top_n(5, likes_count), aes(x = comments_count, y = likes_count, color = &amp;quot;blue&amp;quot;, size = 5)) +
  labs(x = &amp;quot;Number of Comments&amp;quot;, y = &amp;quot;Number of Likes&amp;quot;) + 
  theme(axis.text   = element_text(size = 16),
        axis.title  = element_text(size = 20),
        legend.position = &amp;quot;none&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-04-18-Suunto-Or-Garmin/index_files/figure-html/2017-04-15-likes_vs_comments-1.png&#34; width=&#34;3000&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Here we are plotting a correlation scatterplot between the number of likes and the number of comments for each post. I have a set an alpha value of 0.2 for the scatterplot so that the individual points are made more see-through. That way, overplotting can be seen by darker coloured plots. I have also added in a line of best fit generated by fitting a linear model (&lt;code&gt;method= lm&lt;/code&gt;), together with an estimate of the standard error shown by the grey surrounding of the blue line (&lt;code&gt;se = TRUE&lt;/code&gt;). Finally I have highlighted the top 5 commented posts in blue, and the top 5 liked posts in red.&lt;/p&gt;
&lt;p&gt;It is pretty clear from this plot that there is virtually no correlation between the number of comments and the number of likes, particularly for those with more likes or comments. In general the posts with more likes do not have the most comments (and vice versa), suggesting that in general we like the nice posts, but comment on the ones that upset us. In fact, it looks as if Mandy’s post is the only exception, with both the highest number of likes but also a high number of comments (220).&lt;/p&gt;
&lt;p&gt;We can calculate the correlation between these measures, which is a measure of the linear relationship between two variables. A value of 1 indicates that they are entirely dependent on one another, whilst a value of 0 indicates that the two are entirely independent of one another. A value of -1 indicates an inverse depdnedancy, such that an increase in one variable is associated with a similar decrease in the other variable. Given the difference in the scales between likes and comments, I will use the &lt;em&gt;Spearman correlation&lt;/em&gt;, which looks at correlation between the ranks of the data and therefore ensures that each unit increment is 1 for both variables meaning that it is robust to outliers. The Spearman correlation between these two variables is &lt;code&gt;0.27&lt;/code&gt;, so there is virtually no correlation between likes and comments.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;how-often-do-people-actually-talk-about-ultras&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;9&lt;/span&gt; How Often Do People Actually Talk About Ultras?&lt;/h1&gt;
&lt;p&gt;It seems recently that there is more talk of charlatans and frauds than races, and a lot of people have commented on the fact that there seems to be less and less actual discussion of ultras recently. So let’s see if this is the case, by tracking how often the term &lt;em&gt;ultra&lt;/em&gt; is actually used over time:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ultraposts &amp;lt;- URC                                                        %&amp;gt;%
              filter(str_detect(message, &amp;quot;ultra&amp;quot;))                       %&amp;gt;% 
              mutate(created_time = as.POSIXct(created_time))            %&amp;gt;%
              count(created_time)
ultraposts_xts &amp;lt;- xts(ultraposts$n, order.by = ultraposts$created_time)
ultraposts_month &amp;lt;- apply.monthly(ultraposts_xts, FUN = sum)
plot(ultraposts_month, ylab = &amp;quot;Number of Ultra Posts&amp;quot;, main = &amp;quot;&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-04-18-Suunto-Or-Garmin/index_files/figure-html/2017-04-15-ultra_usage-1.png&#34; width=&#34;3000&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Over the last year or so, the number of people in the group has risen dramatically, and yet it certainly seems that fewer people are actually discussing ultras these days. I guess read into that what you will – perhaps the feed is indeed dominated by Suunto vs Garmin questions?&lt;/p&gt;
&lt;p&gt;Hell, let’s find out.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;suunto-or-garmin&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;10&lt;/span&gt; Suunto or Garmin?&lt;/h1&gt;
&lt;p&gt;So let’s take a look at the real question that everybody cares about – which is more popular, Suunto or Garmin. All my cards on the table; I have a Suunto Peak Ambit 3, but if it helps I had to Google that because I really don’t keep up on these things. I’m really not a gear not, and prefer to make do. The only reason that I got this is that my previous watch died a death, and I like to use a watch for navigation. I didn’t pay for it – at that price I couldn’t bring myself to fork out the money. But it was a gift, and I am very pleased with it. It has a great battery life, and is pretty simple when loading data to my computer. Despite being a stats guy, I don’t normally focus much on my own data, but actually it has been interesting to see how slow I have become recently due to an ongoing injury. Perhaps it will help me to push myself in training onece it is sorted.&lt;/p&gt;
&lt;p&gt;But as I understand it, the Garmin Fenix 3 does exactly the same stuff. Is one better than the other? I couldn’t possibly say. Many people have tried, but I suspect that it comes down to personal preference rather than there being some objective difference between the two.&lt;/p&gt;
&lt;p&gt;But just for the hell of it, let’s see how often people talk about the two. I will be simply using fuzzy matching to look for any use of the terms “suunto” or “garmin” in the post. Fuzzy matching is able to spot slight misspellings, such as “Sunto” or “Garmin”, and is carried out using the base &lt;code&gt;agrep()&lt;/code&gt; function in R:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;suunto &amp;lt;- agrep(&amp;quot;suunto&amp;quot;, URC$message, ignore.case = TRUE)
garmin &amp;lt;- agrep(&amp;quot;garmin&amp;quot;, URC$message, ignore.case = TRUE)
pie(c(length(setdiff(suunto, garmin)), length(setdiff(garmin, suunto)), length(intersect(suunto, garmin))), labels = c(&amp;quot;Suunto&amp;quot;, &amp;quot;Garmin&amp;quot;, &amp;quot;Both&amp;quot;), cex = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-04-18-Suunto-Or-Garmin/index_files/figure-html/2017-04-15-suunto_vs_garmin-1.png&#34; width=&#34;3000&#34; /&gt;&lt;/p&gt;
&lt;p&gt;So of the 24,836 posts on the URC page, 237 (0.95 %) mention Suunto, whilst 552 (2.22 %) mention Garmin. Only 77 (0.3 %) mention both, which I assume are the posts specifically asking which of the two is best. Given the way some people moan about how often this question comes up, these numbers are actually surprisingly small I think. But based on this it seems that Garmin is more popular, although it would be interesting to look at the actual responses on those “VS” posts to see what the outcome actually was in each case.&lt;/p&gt;
&lt;p&gt;Having said that, there is nothing to suggest what these posts about Garmin’s are actually saying. They may be generally saying that they hate Garmins. So I am going to play around with a bit of sentiment analysis using the &lt;code&gt;qdap&lt;/code&gt; package. Essentially this is a machine learning algorithm that has been trained to identify the sentiment underlying a post, with positive values representing a generally positive sentiment (and vice versa). So let’s break down the Garmin and Suunto posts to see how they stack up:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(&amp;quot;qdap&amp;quot;)

## Convert to ASCII and get rid of upper case
suunto_msg &amp;lt;- URC$message[suunto]                %&amp;gt;%
              iconv(&amp;quot;latin1&amp;quot;, &amp;quot;ASCII&amp;quot;, sub = &amp;quot;&amp;quot;) %&amp;gt;%
              tolower                                         
garmin_msg &amp;lt;- URC$message[garmin]                %&amp;gt;%
              iconv(&amp;quot;latin1&amp;quot;, &amp;quot;ASCII&amp;quot;, sub = &amp;quot;&amp;quot;) %&amp;gt;%
              tolower                                            

## Calculate the sentiment polarity
suunto_sentiment &amp;lt;- polarity(gsub(&amp;quot;[[:punct:]]&amp;quot;, &amp;quot;&amp;quot;, suunto_msg))
garmin_sentiment &amp;lt;- polarity(gsub(&amp;quot;[[:punct:]]&amp;quot;, &amp;quot;&amp;quot;, garmin_msg))

## Plot in a stacked barplot
sent_dat &amp;lt;- data.frame(Watch     = c(rep(&amp;quot;Suunto&amp;quot;, length(suunto)), 
                                     rep(&amp;quot;Garmin&amp;quot;, length(garmin))),
                       Sentiment = c(suunto_sentiment$all$polarity,
                                     garmin_sentiment$all$polarity))
ggplot(sent_dat, aes(x = Sentiment, col = Watch, fill = Watch)) + 
  geom_density(alpha = 0.1) +
  labs(x = &amp;quot;Sentiment Polarity&amp;quot;, y = &amp;quot;Density&amp;quot;) +
  theme(axis.text    = element_text(size = 16),
        axis.title   = element_text(size = 20),
        legend.text  = element_text(size = 18),
        legend.title = element_text(size = 24))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-04-18-Suunto-Or-Garmin/index_files/figure-html/2017-04-15-suunto_vs_garmin_sentiment-1.png&#34; width=&#34;3000&#34; /&gt;&lt;/p&gt;
&lt;p&gt;So a value of zero on this distribution plot suggests a neutral sentiment to the post, a positive number suggests a positive sentiment, and a negative number suggests a negative sentiment. While the majority of the posts seem to be fairly neutral in both cases, it certainly seems that the majority of the Garmin posts are positive whilst the Suunto posts are more neutral with many positive &lt;em&gt;and&lt;/em&gt; negative posts.&lt;/p&gt;
&lt;p&gt;We can actually put a number on this, for whether or not there is truly a statistically significant difference between the distribution of sentiment scores for the two watches. To do this, we will us a statistical test that checks how likely it is that we would see a difference of the magnitude seen here given that there is no difference between what people actually think of the watch. This is the so-called “null-hypothesis”, and essentially says that there is no difference, and any differences that we do see are purely random errors. We can test this hypothesis using one of a number of different tests, with the aim to see whether there is evidence that we can reject this null hypothesis, thus suggesting that there is indeed a true difference between the distributions. So we never really “prove” that there is a difference, but instead show that there is suitable evidence to disprove the null hypothesis.&lt;/p&gt;
&lt;p&gt;To do this some test statistic is calculated and is tested to see if it is significantly different than what you would expect to see by chance. Typically this is assessed using a “p-value”, which is one of the most misunderstood measurements in statistics. This value represents the probability that you would see a test statistic &lt;em&gt;at least as high&lt;/em&gt; as that measured purely by chance, even if both sets of data were drawn from the same distribution. So both the Garmin and Suunto scores are a tiny subset of all possible opinions of people in the world, the population distribution. Our two sample populations are either drawn from an overall population where there is no difference, or from two distinct populations for people who have a view one way or the other.&lt;/p&gt;
&lt;p&gt;It is pretty clear from the above figure that these values are not normally distributed (a so-called “bell-curve” distribution), so we cannot use a simple t-test which basically tests the difference in the means between two distributions (after taking the variance into account). Instead we would be better off using a non-parametric test which does not require the data to be parameterised into some fixed probability density function. The &lt;a href=&#34;https://en.wikipedia.org/wiki/Kolmogorov–Smirnov_test&#34;&gt;Kolmogorov Smirnov test&lt;/a&gt; is one method that can be used, and works by looking at how the cummulative distribution functions of two distinct samples differ:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ks.test(subset(sent_dat, Watch == &amp;quot;Suunto&amp;quot;)[[&amp;quot;Sentiment&amp;quot;]], subset(sent_dat, Watch == &amp;quot;Garmin&amp;quot;)[[&amp;quot;Sentiment&amp;quot;]])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in ks.test(subset(sent_dat, Watch == &amp;quot;Suunto&amp;quot;)[[&amp;quot;Sentiment&amp;quot;]],
## subset(sent_dat, : p-value will be approximate in the presence of ties&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Two-sample Kolmogorov-Smirnov test
## 
## data:  subset(sent_dat, Watch == &amp;quot;Suunto&amp;quot;)[[&amp;quot;Sentiment&amp;quot;]] and subset(sent_dat, Watch == &amp;quot;Garmin&amp;quot;)[[&amp;quot;Sentiment&amp;quot;]]
## D = 0.093653, p-value = 0.1091
## alternative hypothesis: two-sided&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we run a two-sided test, which simply means that we have no &lt;em&gt;a priori&lt;/em&gt; reason to suspect one distribution to be greater than the other. We could do a one-sided test where the alternative hypothesis that we are testing is “A is greater than B”, rather than the two-sided test where we are testing the alternative hypothesis that “A is not equal to B”. &lt;span class=&#34;math inline&#34;&gt;\(D\)&lt;/span&gt; is the maximum distance between the empirical distribution functions, and &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; is the p-value. Typically, a threshold used to reject the null hypothesis is for &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; to be less than 0.05 (5 %), although it is fairly arbitrary. But in this case, we would conclude that there is not sufficient evidence to reject the null hypothesis.&lt;/p&gt;
&lt;p&gt;As an alternative, we can instead use the &lt;a href=&#34;https://en.wikipedia.org/wiki/Mann–Whitney_U_test&#34;&gt;Wilcoxon rank sum test&lt;/a&gt; (also called the Mann-Whitney &lt;em&gt;U&lt;/em&gt; test). The idea is to rank all of the data, sum up the ranks from one of the samples, and use this to calculate the test statistic &lt;span class=&#34;math inline&#34;&gt;\(U\)&lt;/span&gt; (which takes into account the sample sizes). So if the distributions are pretty similar, the sum of the ranks will be similar for sample 1 and sample 2. If there is a big difference, one sample will have more higher ranked values than the other, resulting in a higher value for &lt;span class=&#34;math inline&#34;&gt;\(U\)&lt;/span&gt;. Let’s take a look at this:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;wilcox.test(subset(sent_dat, Watch == &amp;quot;Suunto&amp;quot;)[[&amp;quot;Sentiment&amp;quot;]], subset(sent_dat, Watch == &amp;quot;Garmin&amp;quot;)[[&amp;quot;Sentiment&amp;quot;]])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Wilcoxon rank sum test with continuity correction
## 
## data:  subset(sent_dat, Watch == &amp;quot;Suunto&amp;quot;)[[&amp;quot;Sentiment&amp;quot;]] and subset(sent_dat, Watch == &amp;quot;Garmin&amp;quot;)[[&amp;quot;Sentiment&amp;quot;]]
## W = 59157, p-value = 0.03066
## alternative hypothesis: true location shift is not equal to 0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the test statistic here is actually &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt;, but in this case &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(U\)&lt;/span&gt; are equivalent. So this test would result in us rejecting the null hypothesis with the same threshold as above. So which one is correct? Well, this is a great example of why you should never trust statistics. Both of these are perfectly reasonable tests to perform in this case but give different results. Many people would simply choose the one that gives the lowest p-value, but this is pretty naughty and is often called “p-hacking”. At the end of the day, a p-value higher than 0.05 does not mean that there is &lt;em&gt;not&lt;/em&gt; a true difference between the distributions, just that the current data does not provide enough evidence to reject the null hypothesis.&lt;/p&gt;
&lt;p&gt;So my conclusion from this is that I made the wrong decision, and will from now on look upon my useless Suunto watch with hatred and resentment. I can only hope that this post will save anyone else from making such an awful mistake.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;summing-up&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;11&lt;/span&gt; Summing Up&lt;/h1&gt;
&lt;p&gt;It has been quite &lt;em&gt;fun&lt;/em&gt; playing around with these data tonight, and I have had an opportunity to try out a few new techniques that I have wanted to play with for a while. As ever, there is loads more that can be gleaned from these data, but I should probably do something a little more productive right now. Like sleeping. I have actually done a while load more playing with machine learning algorithms of my own, but this post has already become a little too unruly so I will post this later as a separate post.&lt;/p&gt;
&lt;p&gt;But in summary, people on the Ultra Running Community page spend far too much time posting during working hours, seem to be talking less and less about ultra running, and definitely prefer Garmins to Suuntos. So this has all been completely worth it.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;session-info&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;12&lt;/span&gt; Session Info&lt;/h1&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessionInfo()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.6.1 (2019-07-05)
## Platform: x86_64-apple-darwin15.6.0 (64-bit)
## Running under: macOS Sierra 10.12.6
## 
## Matrix products: default
## BLAS:   /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib
## LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib
## 
## locale:
## [1] en_GB.UTF-8/en_GB.UTF-8/en_GB.UTF-8/C/en_GB.UTF-8/en_GB.UTF-8
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] qdap_2.3.2             RColorBrewer_1.1-2     qdapTools_1.3.3       
##  [4] qdapRegex_0.7.2        qdapDictionaries_1.0.7 xts_0.11-2            
##  [7] zoo_1.8-6              ggplot2_3.2.0          stringr_1.4.0         
## [10] dplyr_0.8.3            tidyr_1.0.0            randomForest_4.6-14   
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_1.0.2          lattice_0.20-38     xlsxjars_0.6.1     
##  [4] gtools_3.8.1        assertthat_0.2.1    zeallot_0.1.0      
##  [7] digest_0.6.20       slam_0.1-45         R6_2.4.0           
## [10] plyr_1.8.4          chron_2.3-54        backports_1.1.4    
## [13] evaluate_0.14       blogdown_0.16       pillar_1.4.2       
## [16] rlang_0.4.0         lazyeval_0.2.2      data.table_1.12.2  
## [19] gdata_2.18.0        rmarkdown_1.14      gender_0.5.2       
## [22] labeling_0.3        igraph_1.2.4.1      RCurl_1.95-4.12    
## [25] munsell_0.5.0       compiler_3.6.1      xfun_0.8           
## [28] pkgconfig_2.0.2     htmltools_0.3.6     reports_0.1.4      
## [31] tidyselect_0.2.5    tibble_2.1.3        gridExtra_2.3      
## [34] bookdown_0.12       codetools_0.2-16    XML_3.98-1.20      
## [37] crayon_1.3.4        withr_2.1.2         bitops_1.0-6       
## [40] openNLP_0.2-6       grid_3.6.1          gtable_0.3.0       
## [43] lifecycle_0.1.0     magrittr_1.5        scales_1.0.0       
## [46] xlsx_0.6.1          stringi_1.4.3       reshape2_1.4.3     
## [49] NLP_0.2-0           openNLPdata_1.5.3-4 xml2_1.2.0         
## [52] venneuler_1.1-0     ellipsis_0.2.0.1    vctrs_0.2.0        
## [55] wordcloud_2.6       tools_3.6.1         glue_1.3.1         
## [58] purrr_0.3.3         plotrix_3.7-6       parallel_3.6.1     
## [61] yaml_2.2.0          tm_0.7-6            colorspace_1.4-1   
## [64] rJava_0.9-11        knitr_1.23&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Ultramarathon, Ultra Marathon or Ultra-Marathon?</title>
      <link>/post/2018-04-15-ultrarunner-or-ultra-runner/</link>
      <pubDate>Sun, 15 Apr 2018 00:00:00 +0000</pubDate>
      <guid>/post/2018-04-15-ultrarunner-or-ultra-runner/</guid>
      <description>

&lt;h1 id=&#34;note&#34;&gt;Note&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;This blog post was originally written in 2017 for a less formal personal blog with a focus on ultramarathon running, which is a hobby that I am quite passionate about. I have decided to include all of my data science related blog posts here to keep things centralised, but please excuse the more informal language used throughout.&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;welcome&#34;&gt;Welcome!&lt;/h1&gt;

&lt;p&gt;Well, welcome to my new blog I guess. I have had a bit of a hiatus from writing recently but I am trying to get back into the habit over on my running-related blog &lt;a href=&#34;http://constantforwardmotion.blogspot.com&#34; target=&#34;_blank&#34;&gt;http://constantforwardmotion.blogspot.com&lt;/a&gt;. Over there I will be mainly moaning about my injury woes (and maybe talking about some of my more ridiculous races if I ever get back to being able to run again), but this blog is a little bit different. In the past I have played around with various bits of data for some quite interesting (I think anyway) posts (e.g. &lt;a href=&#34;http://constantforwardmotion.blogspot.co.uk/2013/08/thames-path-100-2013-race-analysis.html&#34; target=&#34;_blank&#34;&gt;this post looking at the 2013 Centurion Running Thames Path 100 mile race&lt;/a&gt;). I am a data analyst by trade, and I am about to start a whole new stage of my career, working as a Senior Post Doc at the &lt;a href=&#34;http://www.port.ac.uk&#34; target=&#34;_blank&#34;&gt;University of Portsmouth&lt;/a&gt; where I will be building my own Bioinformatcs lab. Scary stuff.&lt;/p&gt;

&lt;p&gt;Anyway, I decided to set this blog up as a more technical place to play around with various data analysis techniques, new algorithms, new packages, etc. Since it is something that I am pretty passionate about, there is likely to be a bit of a running theme throughout, but really I will be looking at data from a whole load of different sources. I often play around with &amp;ldquo;fun&amp;rdquo; challenges like those set by &lt;a href=&#34;https://projecteuler.net&#34; target=&#34;_blank&#34;&gt;Project Euler&lt;/a&gt; and &lt;a href=&#34;https://www.kaggle.com&#34; target=&#34;_blank&#34;&gt;Kaggle&lt;/a&gt;, so I figured that it may be useful for me to put some of these out there in case my dumb mistakes when learning these things can help somebody else in the future. As the great philosopher Jake from &lt;a href=&#34;https://en.wikipedia.org/wiki/Adventure_Time&#34; target=&#34;_blank&#34;&gt;Adventure Time&lt;/a&gt;, once said:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Dude, sucking at something is the first step towards being sorta good at something&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So, here is the first post in what I hope will become a regular source of potentially interesting data wrangling. I just wanted to do something simple to start with, and one thing that I have always wanted to play with is the Twitter API for accessing the myriad completely valid and interesting opinions of the millions of Twitter users out there&amp;hellip; Hopefully I will keep away from the shadier parts of the interwebz, but in all seriousness there is a huge amount of useful stuff floating around out there.&lt;/p&gt;

&lt;p&gt;So quite why I picked this particular question as my first post I have no idea. With billions of opinions and social interactions available to me, I have chosen to answer the following rather inconsequential question:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Is it an &amp;ldquo;Ultramarathon&amp;rdquo;, &amp;ldquo;Ultra Marathon&amp;rdquo; or &amp;ldquo;Ultra-Marathon&amp;rdquo;?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;My idea of a good time is running a really, really long way, usually for a whole day or sometimes even more. Any race over a marathon in distance is called an &amp;ldquo;ultramarathon&amp;rdquo; - i.e. it is beyond the marathon. Now, there is a huge amount of baggage attached to this, and some people seem to really get their panties in a bunch over the term. Does it &amp;ldquo;count&amp;rdquo; as an ultramarathon if I run back to the car after a marathon? Does it &amp;ldquo;count&amp;rdquo; as an ultramarathon if I walk most of it? Does it &amp;ldquo;count&amp;rdquo; as an ultramarathon if I run a marathon a day for a whole week? There&amp;rsquo;s a lot of questions about &amp;ldquo;counting&amp;rdquo;, but I&amp;rsquo;ve never been very good at counting personally (says the mathematician&amp;hellip;). I actually really dislike the word myself as it smacks a little of elitism, and I prefer to just think of it as running. A 10K is a running race, a marathon is a running race, and a 100 miler is a running race. Let&amp;rsquo;s just leave it at that.&lt;/p&gt;

&lt;p&gt;Anyway, one thing that I have never seen definitively answered is what the correct nomenclature should actually be, and I find myself switching willy nilly between the three possible spellings as the winds change. I&amp;rsquo;ve probably used all three in this post. So I thought that I would let the people speak, and see what the general consensus is of the Twitterati. And let&amp;rsquo;s face it, no ultrarunner worth their salt would run without Tweeting about it. So let&amp;rsquo;s take a look at which term is used most often on Twitter and settle this mass debate that I am having with myself (chortle) once and for all.&lt;/p&gt;

&lt;h1 id=&#34;setting-up-the-twitter-api&#34;&gt;Setting up the twitter API&lt;/h1&gt;

&lt;p&gt;Twitter uses &lt;a href=&#34;https://apps.twitter.com&#34; target=&#34;_blank&#34;&gt;OAuth&lt;/a&gt; as a way to control programmatic access to its information without requiring passwords. Essentially, Twitter grants you an access token which is used to grant you access to the client information via a web service without actually giving you direct access to the client machine. It&amp;rsquo;s pretty easy to set up. Once you have a Twitter account set up, go to &lt;a href=&#34;https://apps.twitter.com&#34; target=&#34;_blank&#34;&gt;https://apps.twitter.com&lt;/a&gt; and click on the &amp;ldquo;Create New App&amp;rdquo; button. This will bring up the following page:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;Twitter_create_app.png&#34; alt=&#34;Create a new app in Twitter&#34; /&gt;&lt;/p&gt;

&lt;p&gt;I filled this in with details of this blog, and created a new app. Note that to avoid errors further down the line, you need to set the &amp;ldquo;Callback URL&amp;rdquo; field to &lt;code&gt;http://127.0.0.1:1410&lt;/code&gt; which will return to your localhost on port 1410 following authentication. Press &amp;ldquo;Create your Twitter application&amp;rdquo; to create your app. This will take you to a page with information about your new app, including a tab at the top of the page called &amp;ldquo;Keys and Access Tokens&amp;rdquo;. The &amp;ldquo;API Key&amp;rdquo; and &amp;ldquo;API Secret&amp;rdquo; can then be used to access the API.&lt;/p&gt;

&lt;p&gt;One important change to make to the basic settings is to click on the &amp;ldquo;Permissions&amp;rdquo; tab and make sure that your app is set up to have permissions to &amp;ldquo;Read, Write and Access direct messages&amp;rdquo;. Be sure to regenerate your access tokens after making any changes.&lt;/p&gt;

&lt;h1 id=&#34;twitter&#34;&gt;TwitteR&lt;/h1&gt;

&lt;p&gt;Since R is my go-to analysis package, I will be using the &lt;code&gt;TwitteR&lt;/code&gt; package from Jeff Gentry to access the API. You can also access through scripting languages like perl and python, which I will likely explore in the future. You can install &lt;code&gt;TwitteR&lt;/code&gt; from the &lt;a href=&#34;https://cran.r-project.org&#34; target=&#34;_blank&#34;&gt;Comprehensive R Archive Network&lt;/a&gt; by doing the following:&lt;/p&gt;

&lt;p&gt;{% highlight r %}
install.packages(&amp;ldquo;twitteR&amp;rdquo;)
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Or alternatively you can install the less stable, but more up-to-date, development version from GitHub:&lt;/p&gt;

&lt;p&gt;{% highlight r %}
install_github(&amp;ldquo;geoffjentry/twitteR&amp;rdquo;)
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;This requires the &lt;code&gt;devtools&lt;/code&gt; package to be installed as well.&lt;/p&gt;

&lt;p&gt;We should now be set up, but actually I found that I also needed to install some additional packages so that OAuth credentials can be correctly captured in the browser-based authentication:&lt;/p&gt;

&lt;p&gt;{% highlight r %}
install.packages(&amp;ldquo;httpuv&amp;rdquo;)
install.packages(&amp;ldquo;httr&amp;rdquo;)
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Now we need to set up our authorisation (put your API key and secret in place of these placeholders):&lt;/p&gt;

&lt;p&gt;{% highlight r %}
library(&amp;ldquo;twitteR&amp;rdquo;)
setup_twitter_oauth(&amp;ldquo;API key&amp;rdquo;, &amp;ldquo;API secret&amp;rdquo;)
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;This will open up a browser session where you can authenticate your API app. After this, close the browser and you are ready to go!&lt;/p&gt;

&lt;h1 id=&#34;ultramarathon-ultra-marathon-or-ultra-marathon&#34;&gt;Ultramarathon, Ultra Marathon, or Ultra-Marathon?&lt;/h1&gt;

&lt;p&gt;So now we are all set up and we can take a look at how to access the API. The workhorse of the &lt;code&gt;twitteR&lt;/code&gt; package is the &lt;code&gt;searchTwitter()&lt;/code&gt; function. This can search for something like a hashtag or key word, and can use basic boolean logic such as &lt;code&gt;AND&lt;/code&gt; (&lt;code&gt;+&lt;/code&gt;) and &lt;code&gt;OR&lt;/code&gt; (&lt;code&gt;-&lt;/code&gt;). The API actually only allows you to access information from a short time in the past, so we can only get Tweets from the last week or so. So let&amp;rsquo;s get the most recent Tweets relating to ultrarunning and count how many Tweets over the last few days have used the three different terms:&lt;/p&gt;

&lt;p&gt;{% highlight r %}
library(&amp;ldquo;twitteR&amp;rdquo;)
numtweets      &amp;lt;- 500000
um_tweets_all  &amp;lt;- searchTwitter(&amp;ldquo;ultramarathon|ultra marathon&amp;rdquo;, n = numtweets)
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;{% highlight text %}&lt;/p&gt;

&lt;h2 id=&#34;warning-in-dorppapicall-search-tweets-n-params-params&#34;&gt;Warning in doRppAPICall(&amp;ldquo;search/tweets&amp;rdquo;, n, params = params,&lt;/h2&gt;

&lt;h2 id=&#34;retryonratelimit-retryonratelimit-500000-tweets-were-requested-but-the&#34;&gt;retryOnRateLimit = retryOnRateLimit, : 500000 tweets were requested but the&lt;/h2&gt;

&lt;h2 id=&#34;api-can-only-return-961&#34;&gt;API can only return 961&lt;/h2&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;{% highlight r %}
um_tweets_trim &amp;lt;- strip_retweets(um_tweets_all, strip_manual=TRUE, strip_mt=TRUE)
um_tweets_text &amp;lt;- sapply(um_tweets_trim, function (x) x$getText())
um_tweets_text &amp;lt;- um_tweets_text[grep(&amp;ldquo;ultramarathon|ultra marathon|ultra-marathon&amp;rdquo;, um_tweets_text, ignore.case = TRUE)]
um_count &amp;lt;- NULL
for (t in c(&amp;ldquo;ultramarathon&amp;rdquo;, &amp;ldquo;ultra-marathon&amp;rdquo;, &amp;ldquo;ultra marathon&amp;rdquo;)) {
  um_count[[t]] &amp;lt;- length(grep(t, um_tweets_text, ignore.case = TRUE))
}
par(mar = c(0,0,0,0))
pie(um_count, col = c(&amp;ldquo;grey90&amp;rdquo;,&amp;ldquo;grey70&amp;rdquo;,&amp;ldquo;grey50&amp;rdquo;))
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;ultramarathon_tweet_pie.png&#34; alt=&#34;plot of chunk 2017-03-15_ultramarathon_tweet_pie&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at this code. After loading the &lt;code&gt;twitteR&lt;/code&gt; package and specifying the number of Tweets to load, we access the Twitter API using &lt;code&gt;searchTwitter&lt;/code&gt; and load in the 500000 most recent Tweets with the terms &amp;ldquo;ultra&amp;rdquo;, &amp;ldquo;running&amp;rdquo;, or &amp;ldquo;ultrarunning&amp;rdquo; in them (there will be many fewer than this, but I want to capture every Tweet possible). This produces a list of 961 objects of class &lt;code&gt;status&lt;/code&gt;, which is a specially defined reference class as a container for Twitter statuses. Next we strip out all of the retweets to leave 585 Tweets, then pull out the text from the list objects (&lt;code&gt;sapply()&lt;/code&gt; applies the accessor function &lt;code&gt;getText()&lt;/code&gt; to all elements of the list). Since I am only interested in three specific terms, I use regular expressions to look only at Tweets containing one of these terms (giving 316 Tweets), and then count how many Tweets contain each of the three specific terms. Finally I generate a pie chart of the results (yes, yes, I know - I hate pie charts as well).&lt;/p&gt;

&lt;p&gt;A couple of things here. First of all, there are a lot of retweets. Of the 961 Tweets originally analysed, only 585 remain after removing the retweets. This means that 39.13% of these Tweets were retweets. Man, we ultrarunners aren&amp;rsquo;t very original are we? Unfortunately this therefore drastically reduces the number of Tweets that I am analysing. Secondly, because of the way the pattern matching is done we end up with a lot of Tweets with &amp;ldquo;ultra&amp;rdquo; or &amp;ldquo;running&amp;rdquo; in them that don&amp;rsquo;t match any of the three specific terms that I am looking at here. Also, this counting may be double counting some Tweets if both versions are used in a single Tweet. But I can&amp;rsquo;t be bothered taking such stupidity into account right now! ;)&lt;/p&gt;

&lt;p&gt;So with these caveats in place, it seems pretty clear that the correct term is most definitely &amp;ldquo;Ultra Marathon&amp;rdquo;. So there you go.&lt;/p&gt;

&lt;h1 id=&#34;ultrarunning-ultra-running-or-ultra-running&#34;&gt;Ultrarunning, Ultra Running or Ultra-Running?&lt;/h1&gt;

&lt;p&gt;Okay cool. So we know how to define the event. How about the act of running an ultra marathon? So let&amp;rsquo;s do the same again, this time looking at whether I should be saying &amp;ldquo;ultrarunning&amp;rdquo;, &amp;ldquo;ultra running&amp;rdquo;, or &amp;ldquo;ultra-running&amp;rdquo;. The code is practically identical, just using slightly different words in the regular expression:&lt;/p&gt;

&lt;p&gt;{% highlight r %}
ur_tweets_all  &amp;lt;- searchTwitter(&amp;ldquo;ultrarunning|ultra running&amp;rdquo;,  n = numtweets)
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;{% highlight text %}&lt;/p&gt;

&lt;h2 id=&#34;warning-in-dorppapicall-search-tweets-n-params-params-1&#34;&gt;Warning in doRppAPICall(&amp;ldquo;search/tweets&amp;rdquo;, n, params = params,&lt;/h2&gt;

&lt;h2 id=&#34;retryonratelimit-retryonratelimit-500000-tweets-were-requested-but-the-1&#34;&gt;retryOnRateLimit = retryOnRateLimit, : 500000 tweets were requested but the&lt;/h2&gt;

&lt;h2 id=&#34;api-can-only-return-11984&#34;&gt;API can only return 11984&lt;/h2&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;{% highlight r %}
ur_tweets_trim &amp;lt;- strip_retweets(ur_tweets_all, strip_manual=TRUE, strip_mt=TRUE)
ur_tweets_text &amp;lt;- sapply(ur_tweets_trim, function (x) x$getText())
ur_tweets_text &amp;lt;- ur_tweets_text[grep(&amp;ldquo;ultrarunning|ultra running|ultra-running&amp;rdquo;, ur_tweets_text, ignore.case = TRUE)]
ur_count &amp;lt;- NULL
for (t in c(&amp;ldquo;ultrarunning&amp;rdquo;, &amp;ldquo;ultra-running&amp;rdquo;, &amp;ldquo;ultra running&amp;rdquo;)) {
  ur_count[[t]] &amp;lt;- length(grep(t, ur_tweets_text, ignore.case = TRUE))
}
par(mar = c(0,0,0,0))
pie(ur_count, col = c(&amp;ldquo;grey90&amp;rdquo;,&amp;ldquo;grey70&amp;rdquo;,&amp;ldquo;grey50&amp;rdquo;))
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;ultrarunning_tweet_pie.png&#34; alt=&#34;plot of chunk 2017-03-15_ultrarunning_tweet_pie&#34; /&gt;&lt;/p&gt;

&lt;p&gt;There are a lot more Tweets relating to ultra &amp;ldquo;running&amp;rdquo; compared to ultra &amp;ldquo;marathon&amp;rdquo;, with 11984 Tweets in the starting data set. However, again we lose a lot of Tweets through retweets leaving us with only 2112 Tweets to play with. After trimming out Tweets that don&amp;rsquo;t follow the format that I am looking at here, we are left with only 179 &amp;ndash; even less than in the last analysis.&lt;/p&gt;

&lt;p&gt;In this case, it is less clear cut, and whilst the single word term &amp;ldquo;ultrarunning&amp;rdquo; is used most often, the two word &amp;ldquo;ultra running&amp;rdquo; is not far behind. Damn, I wanted a clearly defined outcome, but I guess I will let you off whichever one you choose to use. But god help anybody who chooses to hyphenate either term&amp;hellip;&lt;/p&gt;

&lt;h1 id=&#34;word-cloud&#34;&gt;Word Cloud&lt;/h1&gt;

&lt;p&gt;Since we have these Tweets available, let&amp;rsquo;s generate a word cloud to see what other terms are being talked about in relation to ultra marathons and ultrarunning. A word cloud takes some text and works out the most common words within it, then represents them in a cloud of words (funnily enough) with more common words being more prominent. Here we use the text mining package &lt;code&gt;tm&lt;/code&gt; for identifying and processing unique words from these Tweets, and the &lt;code&gt;wordcloud&lt;/code&gt; package for plotting them. The Tweets are loaded into a &lt;code&gt;Corpus&lt;/code&gt; object, and various mappings are performed to remove irrelevant text like punctuation, as well as commonly used words in English like &lt;em&gt;I&lt;/em&gt;, &lt;em&gt;We&lt;/em&gt;, &lt;em&gt;and&lt;/em&gt;, &lt;em&gt;the&lt;/em&gt;, etc. Note that I have converted the encoding of all of these Tweets into UTF-8 encoding as I was having issues using the &lt;code&gt;tolower()&lt;/code&gt; function when some Tweets contained non-UTF-8 characters. I have coloured the plot using the &lt;code&gt;brewer.pal()&lt;/code&gt; function from the &lt;code&gt;RColorBrewer&lt;/code&gt; package, which in this case generates a palette of 9 equally spaced colours ranging from Red to blue (via white). The parameters here will plot a maximum of 1,000 words, and will only consider a word if it is present more than 5 times. By not using a random order, the most prominent words are plotted at the center of the cloud:&lt;/p&gt;

&lt;p&gt;{% highlight r %}
library(&amp;ldquo;tm&amp;rdquo;)
library(&amp;ldquo;wordcloud&amp;rdquo;)
library(&amp;ldquo;SnowballC&amp;rdquo;)
all_tweets &amp;lt;- c(ur_tweets_text, um_tweets_text)
all_tweets &amp;lt;- iconv(all_tweets, &amp;ldquo;latin1&amp;rdquo;, &amp;ldquo;ASCII&amp;rdquo;, sub = &amp;ldquo;&amp;rdquo;)         ## Convert encodings
cloud_dat &amp;lt;- Corpus(VectorSource(all_tweets))                        ## Create Corpus
cloud_dat &amp;lt;- tm_map(cloud_dat, PlainTextDocument)                    ## Make plain text
cloud_dat &amp;lt;- tm_map(cloud_dat, content_transformer(tolower))         ## Convert to lower case
cloud_dat &amp;lt;- tm_map(cloud_dat, removePunctuation)                    ## Remove punctuation
cloud_dat &amp;lt;- tm_map(cloud_dat, removeWords, stopwords(&amp;ldquo;english&amp;rdquo;))    ## Remove common English words
par(mar = c(0,0,0,0))
wordcloud(cloud_dat, max.words = 1000, min.freq = 5, random.order = FALSE, colors = brewer.pal(9, &amp;ldquo;RdBu&amp;rdquo;))
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;ultramarathon_tweet_wordcloud.png&#34; alt=&#34;plot of chunk 2017-03-15_ultramarathon_tweet_wordcloud&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Kind of what you would expect, with &lt;em&gt;ultra&lt;/em&gt;, &lt;em&gt;marathon&lt;/em&gt;, &lt;em&gt;running&lt;/em&gt;, &lt;em&gt;ultramarathon&lt;/em&gt;, and &lt;em&gt;ultrarunning&lt;/em&gt; being most prominent. &lt;em&gt;training&lt;/em&gt; is also pretty common, so it&amp;rsquo;s good to know that there is some of that going on between Tweets. I&amp;rsquo;m also pleased to see that &lt;em&gt;tom&lt;/em&gt; is quite enriched, which I can only assume to be Tom from Bognor&amp;rsquo;s take-over of the internet. It&amp;rsquo;s also nice to see people talking about &lt;em&gt;shorts&lt;/em&gt;, but come on people &amp;ndash; it&amp;rsquo;s always shorts weather!&lt;/p&gt;

&lt;h1 id=&#34;final-word&#34;&gt;Final Word&lt;/h1&gt;

&lt;p&gt;This has been quite useful for me to get the hang of using the Twitter API, and I hope it has been a little interesting or useful for some of you. I am hoping that this will kick off regular use of this blog, and I will try and update it more regularly along with my less technical &lt;a href=&#34;http://constantforwardmotion.blogspot.com&#34; target=&#34;_blank&#34;&gt;running blog&lt;/a&gt; as I start using it to play with new toys in my work. And hey, at least now you know that they are called &lt;strong&gt;Ultra Marathons&lt;/strong&gt; and that I love &lt;strong&gt;Ultrarunning&lt;/strong&gt;. So we&amp;rsquo;ve all learned something today. And knowing is half the battle.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
